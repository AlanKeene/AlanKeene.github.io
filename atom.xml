<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三年二班陈同学 - Android</title>
  <icon>https://www.gravatar.com/avatar/25c1649ce608b07bd04ed65e3936d880</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.alankeene.com/"/>
  <updated>2021-05-31T15:33:47.156Z</updated>
  <id>https://www.alankeene.com/</id>
  
  <author>
    <name>Alan Keene</name>
    <email>alankeene0522@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于产品经理和程序员</title>
    <link href="https://www.alankeene.com/2021/0531/pm-and-coder.html"/>
    <id>https://www.alankeene.com/2021/0531/pm-and-coder.html</id>
    <published>2021-05-31T14:18:42.000Z</published>
    <updated>2021-05-31T15:33:47.156Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr208gt89vj30u00gw42s.jpg" alt="img"></p><p>一直在思考: <strong>一个可以写代码的产品经理的优势是什么？它有必要么？</strong></p><p>2021.05.22 在跑步的过程中终于憋出了一个目前还算比较认可的答案。</p><h2 id="1-说服力"><a href="#1-说服力" class="headerlink" title="1. 说服力"></a><strong>1. 说服力</strong></h2><p>当达到一定高度，当前方是一片迷茫和未知，当你做的是探索性的产品的时候，当你的技术也不清楚你要的产品逻辑或者忽悠你说这个需求实现不了的时候，当你们也只能摸着石头往前探索的时候，你还可以通过技术性的语言描述、画流程图、画UML类图、写伪代码等技术性的语言把你的想法和产品逻辑呈现出来。如果实在不行，你还可以自己动手来写。</p><p>这种产品能力+技术能力的结合产生的说服力可能会强一些，这样在真实的企业工作环境中更容易说服你的团队跟着你往前走，不容易让你的探索因推动不了而中道崩殂。</p><h2 id="2-把控力"><a href="#2-把控力" class="headerlink" title="2. 把控力"></a><strong>2. 把控力</strong></h2><p>如果对技术有一定的理解，在进行需求评估的时候，研发周期的安排、研发过程的管理、对产品演进节奏的把控可能会更准确一些。</p><p>另外，在团队协作的过程中沟通成本、协作成本会低一些，你的技术做出来的东西匹配你预期的概率会高一些，技术人员和产品经理之间因认知理解偏差导致干出来的活儿跟预期需求相差太大的概率会低一些，不至于要严重返工调整而导致项目进度 delay 严重，从而保障能按预期上线。</p><p>互联网产品的研发是一个综合性团队作战的大工程，在互联网产品的商业竞争中，同质化程度通常都比较高，有时候「<strong>快一步</strong>」就能决定很多东西。</p><h2 id="3-领导力"><a href="#3-领导力" class="headerlink" title="3. 领导力"></a><strong>3. 领导力</strong></h2><p>因为你们在做的事情之前没有很好的经验可以复制或参考，很多事情和想法都是还没有得到成功验证的。</p><p>在一片混沌的探索环境下，你如何能保障带领项目组团队是往一个正确的方向在走？这个时候仅仅有产品能力是不够的。它考验对技术的理解、对产品的理解和对商业洞察的结合。</p><p>另外，在产品的业务演进过程中，可以带领你的技术团队做一些很好的甚至比较超前的技术尝试，让你的技术团队在实现产品功能，满足业务发展需求的同时，也能获得技术上的成长和成功。产品经理和程序员是有方法可以共赢的。</p><h2 id="4-通过技术手段做一些先验产品尝试"><a href="#4-通过技术手段做一些先验产品尝试" class="headerlink" title="4. 通过技术手段做一些先验产品尝试"></a><strong>4. 通过技术手段做一些先验产品尝试</strong></h2><p>通过技术手段，有能力去思考和实施一些先验产品尝试，以降低探索性产品的试错成本和对用户的影响，这在产品演进过程中是非常有价值的，特别是用户体量大的产品。</p><p>而这些 soft skills，是一个没有技术背景的产品经理不容易习得或者习得成本很高的。</p><p>同样的，一个优秀的工程型程序员如果仅仅关注技术实现也是不够的，还需要对产品、对商业有一定的理解，如果是研究型的程序员那就另说了。</p><p><strong>一个优秀的产品经理不仅仅是一个产品经理，一个优秀的工程型程序员也不仅仅是一个程序员</strong>。</p><p>中国的互联网行业、软件行业已经度过了野蛮增长期，也度过了 copy 的时期，在接下来寻求高质量发展和持续性创新的过程中，希望我们能多一些优秀的产品经理和优秀的工程型程序员，为中国这个巨大的引擎提速增效，更快更好地走向复兴。</p>]]></content>
    
    <summary type="html">
    
      一个可以写代码的产品经理的优势是什么？它有必要么？
    
    </summary>
    
      <category term="我的产品思考" scheme="https://www.alankeene.com/categories/%E6%88%91%E7%9A%84%E4%BA%A7%E5%93%81%E6%80%9D%E8%80%83/"/>
    
    
      <category term="产品经理" scheme="https://www.alankeene.com/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
      <category term="程序员" scheme="https://www.alankeene.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>hexo g -d 突然部署失败 ChildProcess.&lt;anonymous&gt; hexo/node_modules/hexo-util/lib/spawn.js:37:17</title>
    <link href="https://www.alankeene.com/2020/1207/hexo-g-d-failed.html"/>
    <id>https://www.alankeene.com/2020/1207/hexo-g-d-failed.html</id>
    <published>2020-12-07T11:54:19.000Z</published>
    <updated>2020-12-07T12:39:16.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间忙于工作，有段时间没更新博客了，今天更新博客部署发现突然部署失败了。</p><p>刚开始根据报错信息，在网上搜索了一圈，各种答案都有，发现都不太准确，有的还说是git的版本问题要升到最新的git版本，为此我还升级了mac的系统和git的版本。但发现并不能解决问题。</p><p>最后，冷静下来分析报错的信息，突然有了方向，最后定位到是<strong>Coding 仓库的地址改变了导致的突然部署失败</strong>，也验证了自己的猜想是正确的。</p><p>我的博客是同时部署在 Github 和 Coding 上的，Coding 突然把仓库地址的规则改了，我也不知道，太坑了..</p><h1 id="原因分析思路"><a href="#原因分析思路" class="headerlink" title="原因分析思路"></a>原因分析思路</h1><p>分析问题的思路如下：</p><p><img src="/images/hexo-g-d-failed.png" alt="" title="hexo-g-d-failed"></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>上 Coding 仓库上查看修改后的仓库地址，把 Coding 的部署地址修改过来就好了。<br>Coding部署地址的配置地方在：hexo 文件夹根目录的 _config.yml 文件里。如下：</p><p><img src="/images/Coding-deploy-address.png" alt="" title="Coding-deploy-address"></p><p>修改之后保存配置问题，重新 hexo g -d 生成并部署就可以部署成功了。问题解决。</p><p>至于博客源码仓库，我也是存放在Coding上的（之前Github还不支持私有仓库），不过上传博客源码的时候不用修改仓库目录， git push 的时候会自动重定向为Coding修改后的仓库地址。</p>]]></content>
    
    <summary type="html">
    
      Coding仓库地址更改了导致 hexo g -d 突然部署失败
    
    </summary>
    
      <category term="hexo博客" scheme="https://www.alankeene.com/categories/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo部署失败" scheme="https://www.alankeene.com/tags/hexo%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5/"/>
    
  </entry>
  
  <entry>
    <title>mac zsh 配置 adb 环境变量 &quot;zsh command not found adb&quot;</title>
    <link href="https://www.alankeene.com/2020/0315/command-not-found-adb.html"/>
    <id>https://www.alankeene.com/2020/0315/command-not-found-adb.html</id>
    <published>2020-03-15T14:18:12.000Z</published>
    <updated>2020-03-15T14:27:31.822Z</updated>
    
    <content type="html"><![CDATA[<p>“zsh: command not found: adb” 的解决方法：</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p><strong>已经成功安装了 Android Studio.</strong></p><p>打开 iTerm 终端依次输入下面命令：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">echo</span> <span class="string">'export ANDROID_HOME=/Users/<span class="variable">$USER</span>/Library/Android/sdk'</span> &gt;&gt; ~/.zshrc</span><br><span class="line">echo <span class="string">'export PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$ANDROID_HOME</span>/tools:<span class="variable">$ANDROID_HOME</span>/platform-tools'</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>然后保存设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>即可完成 adb 环境变量的配置。可通过     <code>adb version</code> 验证是否配置成功。</p><p><img src="https://img-blog.csdnimg.cn/20200308235357747.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Njg0MDg1,size_16,color_FFFFFF,t_70" alt="zsh下配置adb"></p>]]></content>
    
    <summary type="html">
    
      mac zsh 配置 adb 环境变量
    
    </summary>
    
      <category term="Android" scheme="https://www.alankeene.com/categories/Android/"/>
    
    
      <category term="adb" scheme="https://www.alankeene.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>华强北复活</title>
    <link href="https://www.alankeene.com/2019/1130/sz-huaqiangbei.html"/>
    <id>https://www.alankeene.com/2019/1130/sz-huaqiangbei.html</id>
    <published>2019-11-30T15:31:19.000Z</published>
    <updated>2019-11-30T15:53:54.661Z</updated>
    
    <content type="html"><![CDATA[<p><a id="more"></a>  <img src="/images/huaqiangbei.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      赛格重生、华强复活。
    
    </summary>
    
      <category term="个人随笔" scheme="https://www.alankeene.com/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="华强北" scheme="https://www.alankeene.com/tags/%E5%8D%8E%E5%BC%BA%E5%8C%97/"/>
    
  </entry>
  
  <entry>
    <title>探索CameraX (一) CameraX 是什么</title>
    <link href="https://www.alankeene.com/2019/0709/cameraX-overview.html"/>
    <id>https://www.alankeene.com/2019/0709/cameraX-overview.html</id>
    <published>2019-07-09T07:49:07.000Z</published>
    <updated>2019-07-09T10:36:11.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Google 最近推出了 Jetpack 新组件：CameraX。</p><p>Google 官方的介绍：”CameraX is a Jetpack support library, built to help you make camera app development easier.” 很好地诠释了这个库诞生的初衷和用途：<strong>帮助相机APP开发者更简单更轻松地实现摄像头功能的开发</strong>。</p><p>这对于做 Camera 开发的工程师来说是个好消息。</p><h1 id="CameraX-介绍"><a href="#CameraX-介绍" class="headerlink" title="CameraX 介绍"></a>CameraX 介绍</h1><p>在 Android 应用中要实现 Camera 功能还是比较困难的，为了保证在各品牌手机设备上的兼容性、响应速度等体验细节，Camera 应用的开发者往往需要花很大的时间和精力进行测试，甚至需要手动在数百种不同设备上进行测试。CameraX 正是为解决这个痛点而诞生的。</p><p>CameraX 是基于 Camera2 API 实现的，向后兼容到 Android 5.0（API Level 21）。</p><p>CameraX 的优势在于：</p><ul><li>CameraX 和 Lifecycle 结合在一起，方便开发者管理生命周期。且相比较 camera2 减少了大量样板代码的使用。</li><li>兼容至 Android L (API 21)，从而确保兼容到市面上绝大多数手机</li><li>开发者可以通过扩展的形式使用和原生摄像头应用同样的功能（如：人像、夜间模式、HDR、滤镜、美颜）</li><li>Google 自己还打造了 CameraX 自动化测试实验室，对摄像头功能进行深度测试，确保能覆盖到更加广泛的设备。相当于 Google 帮我们把设备兼容测试工作给做了。</li></ul><p>对于开发者来说，简单易用的 API、更少的模版代码、更强的兼容性，意味着更高的开发和测试效率。而丰富的扩展性则意味着开发者可以为用户们带来更多基于摄像头的光影体验。</p><blockquote><p>特别注明：CameraX 目前处于 alpha 版本，Google 官方并不推荐在生产环境中使用。可能会有较多的bug，后期 API 也可能有变化。</p></blockquote><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>据 Google 官方介绍说，目前已经有不少团队开始尝试使用 CameraX，并且带来了很不错的效果。包括：Camera360、TikTok、Snapchat、Twitter 等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简要介绍了 CameraX 是什么，它的出现是为了解决现在的什么痛点以及它有什么优势。还介绍了目前有哪些团队正在采用和实践 CameraX。</p><p>期待 CameraX 能带来更多的新特性～</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.android.com/training/camerax" target="_blank" rel="noopener">CameraX overview</a></p><p><a href="https://juejin.im/post/5d1c36f4e51d4510774a88bb" target="_blank" rel="noopener">摄像头功能开发不再复杂，CameraX 助您轻松打造光影体验</a></p><p><a href="https://joebirch.co/2019/05/15/exploring-camerax-on-android-camera-view/" target="_blank" rel="noopener">Exploring CameraX on Android: Camera View</a></p><p><a href="https://mp.weixin.qq.com/s/geCmI9XovmxyaA437JIewg" target="_blank" rel="noopener">Google Jetpack 新组件 CameraX 介绍与实践</a></p>]]></content>
    
    <summary type="html">
    
      摄像头功能开发不再复杂，CameraX 助您轻松打造光影体验
    
    </summary>
    
      <category term="Android" scheme="https://www.alankeene.com/categories/Android/"/>
    
    
      <category term="CameraX" scheme="https://www.alankeene.com/tags/CameraX/"/>
    
  </entry>
  
  <entry>
    <title>面试题：计算 n！阶乘的结果的末尾有几个0</title>
    <link href="https://www.alankeene.com/2019/0708/calculate-zero-in-factorial.html"/>
    <id>https://www.alankeene.com/2019/0708/calculate-zero-in-factorial.html</id>
    <published>2019-07-08T04:19:34.000Z</published>
    <updated>2019-07-08T09:30:28.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先基于一个事实：我们不可能真的把 n! 的结果计算出来，再去数结果的末尾有几个0；n 很小还好，如果n很大，甚至趋近于无穷大，我们是不可能这样做的。原因主要有二：</p><ol><li>一般计算机的计算能力和存储能力也有限，是计算不出那么大的数的。</li><li>即使计算机能算出来，这样做也很耗时，可能要算很久。</li></ol><p>连计算机都算不出来，那我们怎么办呢？别慌，虽然我们不能直接算出结果，但我们可以把问题一步步拆解。</p><h1 id="拆解思路"><a href="#拆解思路" class="headerlink" title="拆解思路"></a>拆解思路</h1><p>首先，我们想什么情况下会产生一个0？</p><p>诶，一个数乘以 10，在末尾就会多出一个 0。而 10 = 5 * 2。</p><p>一组数相乘的结果末尾有几个0，取决于这组数因式分解后有<strong>几对 </strong>5 和 2 的因子。</p><p>针对于 n! 这个题目，有这样一个事实：把相乘的数因式分解后，2 的个数肯定大于 5 的个数。</p><p>所以，这个问题可以拆解为：只要求出因式分解后有几个 5 的因子即可，5的个数即是末尾出现的0的个数。</p><h1 id="解法一：直接法"><a href="#解法一：直接法" class="headerlink" title="解法一：直接法"></a>解法一：直接法</h1><p>这种解法的思路是：直接将 n! 中的每个数，按照 5 来因式分解，最后把出现的 5 的个数加起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateZeroInFactorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 循环判断所有的乘数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果这个乘数可以对 5 进行因式分解，再看这个乘数可以分解出几个5</span></span><br><span class="line">      <span class="keyword">int</span> a = i;</span><br><span class="line">      <span class="keyword">while</span>(a % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        a = a / <span class="number">5</span>;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种算法的时间复杂度为 O(nlog(n))，那有没有更快的算法呢？</p><h1 id="解法二：-log-n-解法"><a href="#解法二：-log-n-解法" class="headerlink" title="解法二： log(n) 解法"></a>解法二： log(n) 解法</h1><p>分析：</p><ol><li>n! 这些乘数中，每隔 5 个数，肯定会有一个数<strong>至少</strong>能拆出一个 5 因子。所以 n / 5  = <strong>至少</strong>会出现的 5 的个数。</li><li>上面说<strong>至少</strong>，因为 n / 5 并不能完全算出 5 因子的个数，比如若某个数 25 = 5 * 5，分解后得到的 5 也算一个，所以能被 25 因式分解相当于会出现 2 个 5 因子，而第一步中除以 5 算个数的时候已经算了一个了，所以相当于比之前会多一个 5 因子。</li><li>依此类推，能被 25 <em> 5 = 125 因式分解的相当于比之前按 25 因式分解的时候又多出一个 5 因子。能被 125 </em> 5 = 625 因式分解的相当于比按 125 因式分解时又多出一个 5 因子。还有 625 * 5 ……</li></ol><p>所以，n! 的结果可以拆分为多少个 5 因子呢？</p><p>n/5 + n/25 + n /125 + n/625 + ….</p><p>比如 128！的阶乘的结果末尾有几个0呢？</p><p>128/5 +128/25 + 128/125 = 25+5+1 = 31 个</p><p>又如：1247! 的阶乘的结果末尾有几个0呢？</p><p>1247/5 + 1247/25 + 1247/125 + 1247/625 = 249+49+9+1 = 308 个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateZeroInLogN</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    count += n / <span class="number">5</span>;</span><br><span class="line">    n /= <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种算法的时间复杂度为 O(log(n))，效率会高很多，而且仅需几行代码。</p>]]></content>
    
    <summary type="html">
    
      编码实现：计算 n！阶乘的结果的末尾有几个0
    
    </summary>
    
      <category term="面试题" scheme="https://www.alankeene.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="算法" scheme="https://www.alankeene.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>解决 hexo d 提示：ssh_exchange_identification：read：Connection reset by peer 的问题</title>
    <link href="https://www.alankeene.com/2019/0702/Connection-reset-by-peer.html"/>
    <id>https://www.alankeene.com/2019/0702/Connection-reset-by-peer.html</id>
    <published>2019-07-02T07:07:39.000Z</published>
    <updated>2019-07-02T08:56:46.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天写完博客，用 hexo d 部署到 github，突然报了个错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error: ssh_exchange_identification: read: Connection reset by peer</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>最后发现是上网环境导致的，因为现在在图书馆，连的是图书馆的 wifi，<strong>可能是图书馆的防火墙或者代理服务器</strong>导致不能连接到 github，换个上网网络就能 hexo d 提交了。</p><p>所以如果你的上网环境从家里换成公司或者其他公共场合，就要注意了，可能是提供网络的路由器或者机构的防火墙搞的鬼哦。</p><p>最后发现原来是被图书馆的 wifi 网络整蛊了之后，有点抓狂，在此记录一下问题以及解决问题的思路，希望对遇到同样问题的人有所帮助。</p><h1 id="解决问题的思路过程"><a href="#解决问题的思路过程" class="headerlink" title="解决问题的思路过程"></a>解决问题的思路过程</h1><p>咦，奇了怪了，前几天明明还好好的，突然就提交不了了，看日志大意是：SSH验证失败，连接被重置了。</p><ol><li><p>看到 <code>Please make sure you have the correct access rightsand the repository exists.</code> ，刚开始怀疑是不是远程仓库的密钥过期了，因为我之前遇到过密钥过期导致提交不上的情况，所以赶紧去远端仓库查看一下密钥的有效期限，发现并没有过期。排除这种可能。✖️</p></li><li><p>会不会是 SSH 密钥的问题？去确认一下，远端仓库密钥没有更改过，回想一下最近本机也没有重新生成过 SSH key，所以这种可能也排除。✖️</p></li><li><p>实在没有想到好的解决方法，OK，google，在 StackOverFlow 上发现说这种异常的连接重置，原因可能是：<code>服务器进程退出时没有关闭连接，或者crash，或者防火墙或代理、或者负载平衡器干扰连接</code> 导致的。</p><p><a href="https://stackoverflow.com/a/27692498/9031185" target="_blank" rel="noopener">https://stackoverflow.com/a/27692498/9031185</a></p><p>OK，我确实开了代理，检查一下防火墙是否关闭，把代理也关了，重试还是没解决。也排除。✖️</p></li><li><p>缩小关键字，继续搜索，搜索 <code>hexo ssh_exchange_identification: read: Connection reset by peer</code> ，最终搜索到了相关性更强的有价值的参考方案。</p><p><a href="http://dtoucoin.com/2017/05/20/Github的Push操作后提示Connection-reset-by-peer问题解决方法/" target="_blank" rel="noopener">http://dtoucoin.com/2017/05/20/Github的Push操作后提示Connection-reset-by-peer问题解决方法/</a></p></li><li><p>最后定位到：是图书馆 wifi 网络的防火墙或者代理服务器导致的连接不到 github。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>遇到让你感到莫名其妙的问题时，先要理清思路，其次要有耐心，逐个可能性去排除，逐步逼近真相，找到最后的成因。</li><li>在用搜索引擎搜索解决方案时，要注意先想好跟问题相关性较强的关键词，否则会搜出很多相关性很弱的答案，既混淆你的思路和判断，又耗费你很多时间。</li><li>遇到之前能正常工作，突然就不能正常工作了这类问题时，要重点从对比前后的 <strong>变量</strong> 入手，看现象出现前和现在相比，哪些因素发生了变化？哪些环境发生了变化？通常都是某个特定的因素变化了，而导致的现在的现象。</li></ol>]]></content>
    
    <summary type="html">
    
      原因：图书馆 wifi 网络的防火墙或者代理服务器导致不能连接到 github。
    
    </summary>
    
      <category term="日常解决问题集锦" scheme="https://www.alankeene.com/categories/%E6%97%A5%E5%B8%B8%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    
    
      <category term="hexo" scheme="https://www.alankeene.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>面试题：寻找一个字符串中出现次数最多的字符以及出现的次数</title>
    <link href="https://www.alankeene.com/2019/0619/Find-char-appear-more-frequently-in-String.html"/>
    <id>https://www.alankeene.com/2019/0619/Find-char-appear-more-frequently-in-String.html</id>
    <published>2019-06-19T12:00:29.000Z</published>
    <updated>2019-06-20T07:15:06.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解法一：用删除法实现-挺巧妙的一种"><a href="#解法一：用删除法实现-挺巧妙的一种" class="headerlink" title="解法一：用删除法实现 (挺巧妙的一种)"></a>解法一：用删除法实现 (挺巧妙的一种)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindTheMostAppearChar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    deleteMethodToAchieve();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用删除法实现 （挺巧妙的）</span></span><br><span class="line"><span class="comment">     * 解题思路：每次取出字符串的第一个字符，将字符串中与第一个字符相同的字符全部删掉，</span></span><br><span class="line"><span class="comment">     * 然后通过计算删除前后字符串的长度来确定该字符在字符串出现的次数，最终比较出出现次数最多的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteMethodToAchieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String string = scanner.nextLine().trim();</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">0</span>;</span><br><span class="line">        String max_str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (string.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String firstChar = string.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> length = string.length();</span><br><span class="line">            string = string.replaceAll(firstChar, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (length - string.length() &gt; max_length) &#123;</span><br><span class="line">                max_length = length - string.length();</span><br><span class="line">                max_str = firstChar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"出现次数最多的字符是："</span> + max_str + <span class="string">"，出现的次数："</span> + max_length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二：用查找法实现"><a href="#解法二：用查找法实现" class="headerlink" title="解法二：用查找法实现"></a>解法二：用查找法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindTheMostAppearChar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    hashMapMethodToAchieve();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用字符数组查找法实现</span></span><br><span class="line"><span class="comment">     * 解题思路：先将字符串拆分成字符数组，然后转存到 HashMap 集合中，</span></span><br><span class="line"><span class="comment">     * 该集合的key为字符串中出现的字符，value为对应字符串出现的次数。</span></span><br><span class="line"><span class="comment">     * 最后只需要在HashMap集合中找到Value值最大的key即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hashMapMethodToAchieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String string = scanner.nextLine().trim();</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="comment">// 将字符串转换成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = string.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// key为出现的字符，value 为该字符出现的次数，将字符数组转存在 HashMap 中</span></span><br><span class="line">        <span class="keyword">if</span> (arr != <span class="keyword">null</span> &amp;&amp; arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(arr[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 若不为空，说明已经存在相同的字符，则 value 值在原来的基础上加1</span></span><br><span class="line">                    map.put(arr[i],map.get(arr[i]) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(arr[i], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 查找出出现次数最多的字符以及出现的次数也有多种写法</span></span><br><span class="line">      FindTheMostCharByMap(map); <span class="comment">// 查找写法一：用 Iterator 遍历 Map 来查找</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// FindTheMostCharByMapEntry(map); // 查找写法二：用 Map.Entry 提高效率</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// FindTheMostCharByForLoop(map, arr); // 查找写法三：直接用 for 循环来遍历查找</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 查找写法一：用 Iterator 遍历 Map 来查找</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> statice <span class="keyword">void</span> <span class="title">FindTheMostCharByMap</span><span class="params">(Map&lt;Character, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; keys = map.keySet(); <span class="comment">// 获取所有的key</span></span><br><span class="line">        Iterator iterator = keys.iterator(); <span class="comment">// 实例化 Iterator</span></span><br><span class="line">        Character maxKey = (Character) iterator.next(); <span class="comment">//定义第一个为最大的value和对应的key</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = map.get(maxKey);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Character temp = (Character) iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; map.get(temp)) &#123;</span><br><span class="line">                maxKey = temp;</span><br><span class="line">                maxValue = map.get(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"出现次数最多的字符是："</span> + maxKey + <span class="string">", 出现的次数："</span> + maxValue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 查找写法二：用 Map.Entry 提高效率</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FindTheMostCharByMapEntry</span><span class="params">(Map&lt;Character, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        Iterator iterator = map.entrySet().iterator();</span><br><span class="line">        Map.Entry entry = (Map.Entry) iterator.next();</span><br><span class="line">        <span class="keyword">char</span> maxKey = (<span class="keyword">char</span>) entry.getKey(); <span class="comment">// 获取key</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = (<span class="keyword">int</span>) entry.getValue(); <span class="comment">// 获取value</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            entry = (Map.Entry) iterator.next();</span><br><span class="line">            <span class="keyword">char</span> tempKey = (<span class="keyword">char</span>) entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> tempValue = (<span class="keyword">int</span>) entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; tempValue) &#123;</span><br><span class="line">                maxKey = tempKey;</span><br><span class="line">                maxValue = tempValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    System.out.println(<span class="string">"出现次数最多的字符是："</span> + maxKey + <span class="string">", 出现的次数："</span> + maxValue);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 查找写法三：直接用 for 循环来遍历查找</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FindTheMostCharByForLoop</span><span class="params">(Map&lt;Character, Integer&gt; map, <span class="keyword">char</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = map.get(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> maxKey = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; map.get(arr[i])) &#123;</span><br><span class="line">                maxValue = map.get(arr[i]);</span><br><span class="line">                maxKey = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    System.out.println(<span class="string">"出现次数最多的字符是："</span> + maxKey + <span class="string">", 出现的次数："</span> + maxValue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法三：排序法实现"><a href="#解法三：排序法实现" class="headerlink" title="解法三：排序法实现"></a>解法三：排序法实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindTheMostAppearChar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    sortMethodToAchieve();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用排序法实现</span></span><br><span class="line"><span class="comment">     * 解题思路：先将字符串转换成字符数组，然后对字符数组进行排序，</span></span><br><span class="line"><span class="comment">     * 统计每个字符重复出现的次数，最后比较得出出现次数最多的字符以及出现次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortMethodToAchieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String string = scanner.nextLine().trim();</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="keyword">char</span>[] arr = string.toCharArray();</span><br><span class="line">        Arrays.sort(arr); <span class="comment">// 对数组进行排序</span></span><br><span class="line">        <span class="keyword">char</span> maxValue = <span class="string">'a'</span>; <span class="comment">// 记录出现次数最多的元素</span></span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>; <span class="comment">// 记录出现次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">                    maxCount = count;</span><br><span class="line">                    maxValue = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"出现次数最多的字符是："</span> + maxValue + <span class="string">", 出现的次数："</span> + maxCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      要求编写代码实现：寻找一个字符串中出现次数最多的字符以及出现的次数。
    
    </summary>
    
      <category term="面试题" scheme="https://www.alankeene.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://www.alankeene.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="字符串查找" scheme="https://www.alankeene.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Android 事件分发过程源码阅读总结</title>
    <link href="https://www.alankeene.com/2019/0308/view-dispatch-process.html"/>
    <id>https://www.alankeene.com/2019/0308/view-dispatch-process.html</id>
    <published>2019-03-08T09:17:53.000Z</published>
    <updated>2020-12-20T05:52:39.170Z</updated>
    
    <content type="html"><![CDATA[<p>Android 事件分发过程的源码主要分为四大过程：</p><ol><li>Activity 对点击事件的处理过程</li><li>Window 对点击事件的处理过程</li><li>顶级 ViewGroup 对点击事件的处理过程</li><li>View 对点击事件的处理过程</li></ol><a id="more"></a><h1 id="Activity-对点击事件的处理过程"><a href="#Activity-对点击事件的处理过程" class="headerlink" title="Activity 对点击事件的处理过程"></a>Activity 对点击事件的处理过程</h1><p>当一个点击事件产生后，事件先传递给当前的 Activity，由 Activity 的 dispatchTouchEvent 方法进行事件派发。在内部具体的工作是由 Window 来完成的，Activity 将事件传递给了 Window。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow.superDispatchTouchEvent(ev)) &#123; </span><br><span class="line">        <span class="comment">// 若 getWindow.superDispatchTouchEvent(ev) 返回true，则说明事件被 Window 处理了，整个事件就结束了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 若 getWindow.superDispatchTouchEvent(ev) 返回 false，则说明事件没人处理，会调用Activity的onTouchEvent 方法处理</span></span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Window-对点击事件的处理过程"><a href="#Window-对点击事件的处理过程" class="headerlink" title="Window 对点击事件的处理过程"></a>Window 对点击事件的处理过程</h1><p>Window 是个抽象类，它的唯一实现类是 PhoneWindow，PhoneWindow 通过 superDispatchTouchEvent 方法内部调用 DecorView 的 superDispatchTouchEvent 方法将事件传递给 DecorView。由于 DecorView 继承自 FrameLayout，它是我们 Activity 布局的容器，是顶级的父 View，所以最终事件会传递给顶级的根 View，即我们通过 setContentView 设置的 View，一般来说都是 ViewGroup。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event); <span class="comment">// PhoneWindow 将事件传递给 DecorView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="顶级-ViewGroup-对点击事件的处理过程"><a href="#顶级-ViewGroup-对点击事件的处理过程" class="headerlink" title="顶级 ViewGroup 对点击事件的处理过程"></a>顶级 ViewGroup 对点击事件的处理过程</h1><p>ViewGroup 接收到事件后的处理过程主要分为两大部分：</p><ol><li>ViewGroup 对 ACTION_DOWN 事件的处理过程</li><li>ViewGroup 对非 ACTION_DOWN 事件的处理过程</li></ol><h2 id="ViewGroup-对-ACTION-DOWN-事件的处理过程"><a href="#ViewGroup-对-ACTION-DOWN-事件的处理过程" class="headerlink" title="ViewGroup 对 ACTION_DOWN 事件的处理过程"></a>ViewGroup 对 ACTION_DOWN 事件的处理过程</h2><ol><li>ViewGroup 先判断是否是 ACTION_DOWN 事件，如果是 DOWN 事件，则将 target 置空，接下来会调用 ViewGroup 的 onInterceptTouchEvent 方法判断 ViewGroup 是否要拦截这个事件，如果拦截，则后续的 ACTION_MOVE、ACTION_UP 都由 ViewGroup 处理，不会传递给子 View，并且 ViewGroup 的 onInterceptTouchEvent 不会再被调用。(因为ViewGroup已经知道自己要拦截这次事件了，就不需要再次判断了)</li><li>如 ViewGroup 的 onInterceptTouchEvent 返回 false，则表示 ViewGroup 不拦截此次 DOWN 事件，接下来会调用子 View 的 dispatchTouchEvent 方法继续往下分发，如果子 View 处理该事件，则将子 View 标记为处理该事件的 target，并且子 View 的 dispatchTouchEvent 方法返回 true。如果子 View 也不处理，则调用 super.dispatchTouchEvent 方法往上返回给父 View。</li></ol><h2 id="ViewGroup-对非-ACTION-DOWN-事件的处理过程"><a href="#ViewGroup-对非-ACTION-DOWN-事件的处理过程" class="headerlink" title="ViewGroup 对非 ACTION_DOWN 事件的处理过程"></a>ViewGroup 对非 ACTION_DOWN 事件的处理过程</h2><ol><li><p>先判断有无 target(即 target 是否为空)，如果 target 为空，则 ViewGroup 的 dispatchTouchEvent 方法返回 true，说明 ViewGroup 处理后续所有的非 DOWN 事件。</p></li><li><p>如果 target 不为空，则判断 disallowIntercept 禁止拦截标志，如果 disallowIntercept = true，说明子 View 设置了 FLAG_DISALLOW_INTERCEPT 标志禁止 ViewGroup 拦截非 DOWN 事件(当然前提是 ViewGroup 不拦截 DOWN 事件)，则会调用 target.dispatchTouchEvent 方法，交给子 View 去往下分发。</p></li><li><p>如果 disallowIntercept = false，说明子 View 不禁止 ViewGroup 去拦截非 DOWN 事件，则 ViewGroup 会调用自己的 onInterceptTouchEvent 方法进一步判断自己是否需要拦截。</p><p>如果 ViewGroup 拦截说明 ViewGroup 要拦截此次非 DOWN 事件，则会将 target 置空，ViewGroup 的 onInterceptTouchEvent 方法返回 true，后续的事件都会交给 ViewGroup 去处理，不会传给子 View，onInterceptTouchEvent 也不会再次调用。</p><p>如果 ViewGroup 不拦截，则会调用 target.dispatchTouchEvent 方法继续往下分发，由 target.dispatchTouchEvent 方法确定返回值。</p></li></ol><h2 id="View-对事件的处理过程"><a href="#View-对事件的处理过程" class="headerlink" title="View 对事件的处理过程"></a>View 对事件的处理过程</h2><ol><li><p>如果子 View 不处理事件，则会调用 super.dispatchTouchEvent 方法将事件往回传给父 View。</p></li><li><p>如果子 View 处理该事件，则会先判断是否设置了 onTouchListener 监听器，如果设置了 onTouchListener，则会回调其 onTouch 方法，并且 onTouchEvent 方法将不会被调用。</p><p>如果没设置 onTouchListener，则会调用 onTouchEvent 方法，在 onTouchEvent 方法内部会判断是否设置了 onClickListener 监听器，如果设置了则会回调 onClickListener 的 onClick 方法。</p></li></ol><p>   推荐阅读：</p><p>   <a href="https://www.alankeene.com/2019/0308/view-dispatch-basic-knowledge.html">Android事件分发机制的一些基本知识</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 事件分发过程的源码主要分为四大过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Activity 对点击事件的处理过程&lt;/li&gt;
&lt;li&gt;Window 对点击事件的处理过程&lt;/li&gt;
&lt;li&gt;顶级 ViewGroup 对点击事件的处理过程&lt;/li&gt;
&lt;li&gt;View 对点击事件的处理过程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.alankeene.com/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.alankeene.com/tags/Android/"/>
    
      <category term="事件分发" scheme="https://www.alankeene.com/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android事件分发机制的一些基本知识</title>
    <link href="https://www.alankeene.com/2019/0308/view-dispatch-basic-knowledge.html"/>
    <id>https://www.alankeene.com/2019/0308/view-dispatch-basic-knowledge.html</id>
    <published>2019-03-08T08:02:47.000Z</published>
    <updated>2020-12-20T05:52:44.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一种学得快的方法，就是不要一次学太多。</p></blockquote><h1 id="什么是View的事件分发"><a href="#什么是View的事件分发" class="headerlink" title="什么是View的事件分发"></a>什么是View的事件分发</h1><p>在 Android 中，用户的在屏幕上的点击事件被抽象成 MotionEvent 这个类，点击事件的类型中比较重要的有 ACTION_DOWN、ACTION_MOVE、ACTION_UP 三种类型。当一个 MotionEvent 事件产生后，系统 需要把这个事件传递给一个具体的 View 来处理，而 MotionEvent 的这个分发过程，就叫 View 的事件分发过程。 </p><a id="more"></a><h1 id="点击事件分发过程中有几个重要方法？他们之间的关系是怎么的？"><a href="#点击事件分发过程中有几个重要方法？他们之间的关系是怎么的？" class="headerlink" title="点击事件分发过程中有几个重要方法？他们之间的关系是怎么的？"></a>点击事件分发过程中有几个重要方法？他们之间的关系是怎么的？</h1><p>有三个重要的方法： dispatchTouchEvent 、onInterceptTouchEvent、onTouchEvent 。</p><p>他们之间的关系即代表了 View 的分发规则，用下面一段伪代码来表示会比较清晰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123; <span class="comment">// 开始分发该事件</span></span><br><span class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>; <span class="comment">// 事件是否消费</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123; <span class="comment">// 父View是否拦截该事件</span></span><br><span class="line">        consume = onTouchEvent(ev); <span class="comment">// 父View处理该事件，判断是否要消费</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev); <span class="comment">// 交给子View，继续往下分发。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume; <span class="comment">// 返回值表示是否消费当前事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对这三个方法的作用进一步描述：</p><p><code>dispatchTouchEvent</code>：用来进行事件的分发，返回结果受当前 View 的 onTouchEvent 方法和下级 View 的 dispatchTouchEvent 方法决定，表示是否消费当前事件。此方法在事件传递给当前 View 时调用。</p><p><code>onInterceptTouchEvent</code>：用来判断是否拦截某个事件。如果当前 View 拦截了某个事件，那么同一事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。此方法在 <code>dispatchTouchEvent</code> 方法中被调用。</p><p><code>onTouchEvent</code>：用来处理点击事件，返回结果表示是否消费当前的事件，如果不消费，则在同一事件序列中，当前 View 无法再次接收到事件。此方法在 <code>dispatchTouchEvent</code> 方法中被调用。</p><h1 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h1><p>这里说的事件分发机制是指从 ViewGroup 开始的事件分发机制，我们平时说的 View 的事件分发机制也是指从 ViewGroup 开始的事件分发机制。</p><h2 id="点击事件的传递过程"><a href="#点击事件的传递过程" class="headerlink" title="点击事件的传递过程"></a>点击事件的传递过程</h2><p>点击事件的传递过程： Activity —&gt; Window —&gt; View</p><p>即事件总是先传递给 Activity，Activity 再传递给 Window，Window 再传递给顶级 View，顶级 View (如 DecorView) 接收到事件后，就会按照事件分发机制去分发事件，找到需要消费当前事件的消费者。</p><h2 id="事件分发机制-1"><a href="#事件分发机制-1" class="headerlink" title="事件分发机制"></a>事件分发机制</h2><p>对于一个根 ViewGroup 来说，当点击事件产生后，首先会传递给它，这时它的 dispatchTouchEvent 方法会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true，就表示它要拦截当前事件，接着事件就会交给 ViewGroup 来处理，这时它的 onTouchEvent 方法会被调用。</p><p>如果 ViewGroup 的 onInterceptTouchEvent 方法返回 false，就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 dispatchTouchEvent 方法就会被调用，如此反复直到事件被最终处理。</p><h2 id="一个-View-是如何处理点击事件的？"><a href="#一个-View-是如何处理点击事件的？" class="headerlink" title="一个 View 是如何处理点击事件的？"></a>一个 View 是如何处理点击事件的？</h2><p>它会首先判断是否设置了 onTouchListener，如果设置了则会回调 onTouchListener 的 onTouch 方法，这时事件如何处理要看 onTouch 方法的返回值。如果 onTouch 方法返回 true，表示 onTouch 方法要处理这个事件，则 onTouchEvent 将不会再被调用；如果 onTouch 方法返回 false，表示 onTouch 方法不处理这个事件，则 onTouchEvent 方法会被调用。</p><p>在 onTouchEvent 方法中，如果当前设置的监听器中有 onClickListener，那么 onClickListener 的 onClick 方法会被回调。</p><p>调用优先级：onTouchListener  &gt;  onTouchEvent  &gt;  onClickListener</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有一种学得快的方法，就是不要一次学太多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;什么是View的事件分发&quot;&gt;&lt;a href=&quot;#什么是View的事件分发&quot; class=&quot;headerlink&quot; title=&quot;什么是View的事件分发&quot;&gt;&lt;/a&gt;什么是View的事件分发&lt;/h1&gt;&lt;p&gt;在 Android 中，用户的在屏幕上的点击事件被抽象成 MotionEvent 这个类，点击事件的类型中比较重要的有 ACTION_DOWN、ACTION_MOVE、ACTION_UP 三种类型。当一个 MotionEvent 事件产生后，系统 需要把这个事件传递给一个具体的 View 来处理，而 MotionEvent 的这个分发过程，就叫 View 的事件分发过程。 &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.alankeene.com/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.alankeene.com/tags/Android/"/>
    
      <category term="事件分发" scheme="https://www.alankeene.com/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java8 和 Java9 的主要新特性</title>
    <link href="https://www.alankeene.com/2019/0304/java-new-features.html"/>
    <id>https://www.alankeene.com/2019/0304/java-new-features.html</id>
    <published>2019-03-04T02:42:13.000Z</published>
    <updated>2019-03-04T03:32:32.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-8-的主要新特性"><a href="#Java-8-的主要新特性" class="headerlink" title="Java 8 的主要新特性"></a>Java 8 的主要新特性</h1><h2 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1.Lambda 表达式"></a>1.Lambda 表达式</h2><p>Lambda 允许把函数作为一个方法的参数传递进方法中。</p><p>作用：解决 Java 被诟病的匿名内部类的问题。</p><h2 id="2-接口中可增加了默认方法"><a href="#2-接口中可增加了默认方法" class="headerlink" title="2.接口中可增加了默认方法"></a>2.接口中可增加了默认方法</h2><p>作用：在接口中也可以有实现方法了。</p><h2 id="3-HashMap-底层数据结构的变化"><a href="#3-HashMap-底层数据结构的变化" class="headerlink" title="3.HashMap 底层数据结构的变化"></a>3.HashMap 底层数据结构的变化</h2><p>java 8 之前，HashMap 底层的数据结构是数组+链表实现的， Java 8  之后是数组+链表+红黑树实现的，当链表的长度超过 8 之后，会转换成红黑树。</p><p>作用：解决因哈希冲突导致的链表过长，查询效率低的问题。</p><h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4.Stream API"></a>4.Stream API</h2><p>新添加 Stream API (java.util.stream)，把真正函数式编程的风格引入 Java。</p><h2 id="5-提供一个新的-JavaScript-引擎"><a href="#5-提供一个新的-JavaScript-引擎" class="headerlink" title="5.提供一个新的 JavaScript 引擎"></a>5.提供一个新的 JavaScript 引擎</h2><p>Java 8 提供了一个新的 Nashorn JavaScript 引擎，它允许在 JVM 上运行特定的 JavaScript 应用。</p><p>作用：解决日益增长的 Java 跟 JS 交互混合的需求。</p><h1 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h1><h2 id="1-模块系统"><a href="#1-模块系统" class="headerlink" title="1.模块系统"></a>1.模块系统</h2><p>模块是一个包的容器，Java 9 最大的变化之一是引入模块系统。（Jigsaw 项目）</p><p>作用：解决大型项目模块化开发的需求。</p><h2 id="2-支持-HTTP-2-标准"><a href="#2-支持-HTTP-2-标准" class="headerlink" title="2.支持 HTTP/2 标准"></a>2.支持 HTTP/2 标准</h2><p>HTTP/2 标准是 HTTP 协议的最新版本，新的 HTTPClient API 支持 Websocket 和 HTTP2 流以及服务器推送特性。</p><h2 id="3-提供创建不可变集合的静态工厂方法"><a href="#3-提供创建不可变集合的静态工厂方法" class="headerlink" title="3.提供创建不可变集合的静态工厂方法"></a>3.提供创建不可变集合的静态工厂方法</h2><p>List、Set、Map 接口中，提供新的静态工厂方法直接创建不可变的集合实例。</p><p>作用：创建不可变集合更方便，一行代码就搞定，节省了开销。</p><h2 id="4-私有接口方法"><a href="#4-私有接口方法" class="headerlink" title="4.私有接口方法"></a>4.私有接口方法</h2><p>在接口中也允许编写 private 修饰的私有方法了。</p><p>作用：增强了接口的功能，提高了可扩展性。</p><h2 id="5-轻量级的-JSON-API"><a href="#5-轻量级的-JSON-API" class="headerlink" title="5.轻量级的 JSON API"></a>5.轻量级的 JSON API</h2><p>内置了一个轻量级的 JSON API。</p><h2 id="6-引入响应式流-API"><a href="#6-引入响应式流-API" class="headerlink" title="6.引入响应式流 API"></a>6.引入响应式流 API</h2><p>Java 9 引入了新的响应式流 API。</p><p>作用：支持响应式编程的需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;!— more --&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.alankeene.com/categories/Java/"/>
    
    
      <category term="Java8" scheme="https://www.alankeene.com/tags/Java8/"/>
    
      <category term="Java9" scheme="https://www.alankeene.com/tags/Java9/"/>
    
  </entry>
  
  <entry>
    <title>Window 的添加过程</title>
    <link href="https://www.alankeene.com/2019/0303/add-window-process.html"/>
    <id>https://www.alankeene.com/2019/0303/add-window-process.html</id>
    <published>2019-03-03T10:02:53.000Z</published>
    <updated>2020-12-20T05:51:47.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Window-的添加过程"><a href="#Window-的添加过程" class="headerlink" title="Window 的添加过程"></a>Window 的添加过程</h1><p>Window(或者说View) 是怎么添加到 Android 系统中然后展示给用户的？让我们来探索一下 Window 的添加过程。</p><a id="more"></a><h2 id="Window-添加过程的入口方法"><a href="#Window-添加过程的入口方法" class="headerlink" title="Window 添加过程的入口方法"></a>Window 添加过程的入口方法</h2><p>要探索添加的过程，必须先在源代码中找到添加 Window 的入口方法。</p><p>Window 的添加需要通过 WindowManager 的 <code>addView</code> 方法实现，但 WindowManager 是个接口，它的真正实现类是 WindowManagerImpl 类，但 WindowManagerImpl 也并没有直接实现对 Window 的添加、删除、更新操作，而是通过桥接模式将所有操作委托给 WindowManagerGlobal 去实现。最终会调用 WindowManagerGlobal 类的 <code>addView</code> 方法真正开启 View 的添加过程。</p><p>所有，Window 添加过程的真正入口方法实际上是 WindowManagerGlobal 类的 <code>addView</code>  方法。</p><h2 id="Window-添加过程的主要流程"><a href="#Window-添加过程的主要流程" class="headerlink" title="Window 添加过程的主要流程"></a>Window 添加过程的主要流程</h2><p>WindowManagerGlobal 的 <code>addView</code> 方法主要分为三大步：</p><p>1.检查参数 params 是否是 WindowManager.LayoutParams，如果不是说明参数不合法，则会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123; <span class="comment">// 检查 params 参数是否合法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建 ViewRootImpl，并将 View 添加到列表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">44root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display); <span class="comment">// 创建 ViewRootImpl</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view); <span class="comment">// 将View添加到mView列表中，mView 存储的是所有Window对应的View</span></span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.通过 ViewRootImpl 的 <code>setView</code> 方法来添加更新界面并通过 IPC 的方式调用 WindowManagerService 的 <code>addWindow</code> 方法完成 Window 的添加过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">44...</span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            root.setView(view, wparams, panelParentView); <span class="comment">// ViewRootImpl的setView 方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那 ViewRootImpl 的<code>setView</code> 方法是如何实现界面的更新的呢？</p><p><code>setView</code> 方法中会调用 <code>requestLayout()</code> 方法去完成异步刷新请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"EmptyCatchBlock"</span>, <span class="string">"PointlessBooleanExpression"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ViewRootImpl"</span>;</span><br><span class="line">4...</span><br><span class="line">    <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">    <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">    <span class="comment">// any other events from the system.</span></span><br><span class="line">    requestLayout();           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再查看 <code>requestLayout</code> 方法的源码，看它干了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">         checkThread();</span><br><span class="line">         mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">         scheduleTraversals(); <span class="comment">// scheduleTraversals 方法是View绘制的入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，是调用了 <code>scheduleTraversals</code> 方法进行绘制，我们知道 <code>scheduleTraversals</code> 是 View 执行绘制过程的入口方法，该方法会经过测量、布局、绘制这三个过程把 View 绘制出来。</p><p>那 View 绘制出来以后是怎么通过IPC调用的方式添加到 Window 中的呢？</p><p>我们知道，WindowManager 是外界访问 Window 的入口，所以最终 WindowManager 会通过 IPC 的方式调用 WindowManagerService 的 <code>addWindow</code> 方法，这样一来， Window 的添加请求就交给了 WindowManagerService 来处理了，然后 WindowManagerService 会经过一系列的操作将 View 添加到 Window 中并展示出来。</p><p>作为应用层开发者来说，了解到这个程度个人觉得就可以了，没必要去深究 WindowManagerService 的实现细节，至于 WindowManagerService 是如何处理 Window 的添加请求的，感兴趣的读者可以去查看源码。</p><p>​        参考书籍：《Android 开发艺术探索》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Window-的添加过程&quot;&gt;&lt;a href=&quot;#Window-的添加过程&quot; class=&quot;headerlink&quot; title=&quot;Window 的添加过程&quot;&gt;&lt;/a&gt;Window 的添加过程&lt;/h1&gt;&lt;p&gt;Window(或者说View) 是怎么添加到 Android 系统中然后展示给用户的？让我们来探索一下 Window 的添加过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.alankeene.com/categories/Android/"/>
    
    
      <category term="Window" scheme="https://www.alankeene.com/tags/Window/"/>
    
  </entry>
  
  <entry>
    <title>Window、WindowManager、View 之间的关系</title>
    <link href="https://www.alankeene.com/2019/0303/window-and-windowmanager.html"/>
    <id>https://www.alankeene.com/2019/0303/window-and-windowmanager.html</id>
    <published>2019-03-03T09:08:50.000Z</published>
    <updated>2020-12-20T05:43:58.414Z</updated>
    
    <content type="html"><![CDATA[<p>如果问你这三个问题，你的理解是什么呢。</p><ol><li>Window 和 WindowManager 是什么关系？</li><li>Window 和 View 是什么关系？</li><li>WindowManager 和 View 是什么关系？</li></ol><a id="more"></a><h1 id="Window-和-WindowManager-是什么关系？"><a href="#Window-和-WindowManager-是什么关系？" class="headerlink" title="Window 和 WindowManager 是什么关系？"></a>Window 和 WindowManager 是什么关系？</h1><p>Widow 是个抽象类，在 Android 中所有的视图都是通过 Window 来呈现的，包括 Activity、Dialog、Toast，它们的视图实际上都是附加在 Window 上的。Window 的具体实现类是 PhoneWindow。而 WindowManager 是外界访问 Window 的入口，WindowManager 和 WindowManagerService 之间通过 IPC 进行通信，从而实现对 Window 的访问和操作。</p><h1 id="Window-和-View-是什么关系？"><a href="#Window-和-View-是什么关系？" class="headerlink" title="Window 和 View 是什么关系？"></a>Window 和 View 是什么关系？</h1><p>Window 是 View 的承载者，而 View 是 Window 的体现者。两者之间通过 ViewRootImpl 建立联系。</p><p>怎么理解这句话呢？</p><p>Window 是 View 的承载者：Android 中的所有视图都是附加在 Window 上呈现出来的 。</p><p>View 是 Window 的体现者：因为 Window 是个抽象的概念，并不实际存在，View 才是 Window 存在的实体。</p><p>而 ViewRootImpl 是用来建立 Window 和 View 之间的联系的，是两者之间的纽带。</p><h1 id="WindowManager-和-View-是什么关系？"><a href="#WindowManager-和-View-是什么关系？" class="headerlink" title="WindowManager 和 View 是什么关系？"></a>WindowManager 和 View 是什么关系？</h1><p>WindowManager 是 View 的直接管理者，对 View 的添加、删除、更新操作都是通过 WindowManager 来完成的，对应于 WindowManager 的 <code>addView</code>、<code>removeView</code>、<code>updateViewLayout</code> 三个方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果问你这三个问题，你的理解是什么呢。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Window 和 WindowManager 是什么关系？&lt;/li&gt;
&lt;li&gt;Window 和 View 是什么关系？&lt;/li&gt;
&lt;li&gt;WindowManager 和 View 是什么关系？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.alankeene.com/categories/Android/"/>
    
    
      <category term="Window" scheme="https://www.alankeene.com/tags/Window/"/>
    
      <category term="WindowManager" scheme="https://www.alankeene.com/tags/WindowManager/"/>
    
  </entry>
  
  <entry>
    <title>赛格还会重生吗？</title>
    <link href="https://www.alankeene.com/2019/0302/sz-saige.html"/>
    <id>https://www.alankeene.com/2019/0302/sz-saige.html</id>
    <published>2019-03-02T06:17:29.000Z</published>
    <updated>2019-03-02T06:30:15.337Z</updated>
    
    <content type="html"><![CDATA[<p><a id="more"></a><img src="/images/sz-saige.jpeg" alt="" title="深圳赛格"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="https://www.alankeene.com/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="赛格" scheme="https://www.alankeene.com/tags/%E8%B5%9B%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>一个有趣的问题，如何用HashSet来存储重复的字符串？</title>
    <link href="https://www.alankeene.com/2019/0223/how-to-store-same-string-in-hashset.html"/>
    <id>https://www.alankeene.com/2019/0223/how-to-store-same-string-in-hashset.html</id>
    <published>2019-02-23T13:46:05.000Z</published>
    <updated>2020-12-20T05:33:18.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一种学得快的方法，就是不要一次学太多。</p></blockquote><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>今天，我们来探讨一个实际中不常用但却比较有意思的问题。它能帮助你理解 “HashSet中的键值是唯一的，不可重复的” 这句话的真正含义，也考验你对问题的思考深度。<a id="more"></a></p><blockquote><p>注：实际应用中，我们一般是用 ArrayList 集合来存储相同的字符串的，不会用 HashSet 来存。</p></blockquote><p>我们平时都看到或听说 HashSet 是不能用来存放重复的字符串的，是真的存放不了吗？如果面试问你这个问题，你能给出解决方案吗？</p><h3 id="2-参考解答"><a href="#2-参考解答" class="headerlink" title="2. 参考解答"></a>2. 参考解答</h3><p>先给出参考解答，然后我们再来分析为什么。 </p><p><strong>解答：</strong><br>虽然我们不能用 HashSet 来存放 String 类型重复的字符串，但我们可以用 HashSet 来存储 StringBuilder 类型重复的字符串呀。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 HashSet 来存放 String 类型的重复的字符串会发生什么？</span></span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hs1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">        hs1.add(s1);</span><br><span class="line">        hs1.add(s2);</span><br><span class="line">        hs1.add(s3);</span><br><span class="line">        System.out.println(<span class="string">"hs1:"</span>+hs1); <span class="comment">// 重复的字符串是存不进去的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 HashSet 来存放 StringBuilder 类型的重复的字符串又会发生什么？</span></span><br><span class="line"></span><br><span class="line">        HashSet&lt;StringBuilder&gt; hs2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder(<span class="string">"aaa"</span>);</span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"aaa"</span>);</span><br><span class="line">        StringBuilder sb3 = <span class="keyword">new</span> StringBuilder(<span class="string">"aaa"</span>);</span><br><span class="line">        hs2.add(sb1);</span><br><span class="line">        hs2.add(sb2);</span><br><span class="line">        hs2.add(sb3);</span><br><span class="line">        System.out.println(<span class="string">"hs2:"</span>+hs2); <span class="comment">// 咦，结果发现重复的字符串也能存进去了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 那为什么呢？我们来打印一个各个对象的hashCode看一下</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s1的hashCode:"</span>+s1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"s2的hashCode:"</span>+s2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"s3的hashCode:"</span>+s3.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sb1的hashCode:"</span>+sb1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sb2的hashCode:"</span>+sb2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sb3的hashCode:"</span>+sb3.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hs1:[aaa]</span><br><span class="line">hs2:[aaa, aaa, aaa]</span><br><span class="line">s1的hashCode:<span class="number">96321</span></span><br><span class="line">s2的hashCode:<span class="number">96321</span></span><br><span class="line">s3的hashCode:<span class="number">96321</span></span><br><span class="line">sb1的hashCode:<span class="number">356573597</span></span><br><span class="line">sb2的hashCode:<span class="number">1735600054</span></span><br><span class="line">sb3的hashCode:<span class="number">21685669</span></span><br></pre></td></tr></table></figure></p><p>从打印结果来看，我们是不能用 HashSet 来存放 String 类型的重复字符串的(如hs1)，但我们是可以用HashSet来存放 StringBuilder 类型的重复字符串。</p><h3 id="3-为什么？"><a href="#3-为什么？" class="headerlink" title="3. 为什么？"></a>3. 为什么？</h3><p>从打印的 hashCode 来看，String 类型，相同字符串的不同 String 对象哈希值是一样的。而对于 StringBuilder 类型，相同字符串的不同对象哈希值是不同的。</p><p>要知道这个问题的答案，我们首先得了解 JDK 是如何判断两个对象是否相同的。</p><h4 id="那-JDK-是如何判断两个对象是否相同的呢？"><a href="#那-JDK-是如何判断两个对象是否相同的呢？" class="headerlink" title="那 JDK 是如何判断两个对象是否相同的呢？"></a>那 JDK 是如何判断两个对象是否相同的呢？</h4><p><strong>参考解答：</strong></p><p>JDK 会先判断两个对象的 hashCode 是否相同，如果 hashCode 不同，则说明肯定是两个不同的对象了；如果 hashCode 相同再通过 equals() 方法进行进一步比较，如果 equals 方法返回 true，则说明两个对象是相同的，如果equals方法返回 false 说明两个对象不同。</p><p>具体验证思路如果你感兴趣，请查看: <a href="https://www.alankeene.com/2019/0222/how-jdk-distinguish-object.html">JDK 是如何判断两个对象是否相同的？判断的流程是什么？</a></p><h4 id="那为什么相同字符串的不同-String-对象哈希值是一样的，而且还被-JDK-判断为相同的对象了呢？"><a href="#那为什么相同字符串的不同-String-对象哈希值是一样的，而且还被-JDK-判断为相同的对象了呢？" class="headerlink" title="那为什么相同字符串的不同 String 对象哈希值是一样的，而且还被 JDK 判断为相同的对象了呢？"></a><strong>那为什么相同字符串的不同 String 对象哈希值是一样的，而且还被 JDK 判断为相同的对象了呢？</strong></h4><p>因为 String 类复写了 Object 类的 hashCode() 和 equals() 方法，并实现了自己的 hashCode 值生成算法和 equals 的比较规则，具有相同字符串内容的不同 String 对象在初始化时生成的 hashCode 值是一样的，并且 String 类 equals() 方法比较的是两个字符串的内容，而不是内存地址值，这两个条件同时成立， 这使得 JDK 把具有相同内容的不同 String 对象判断为相同的对象了，就不会存入 HashSet 集合中。</p><h4 id="而-StringBuilder-为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？"><a href="#而-StringBuilder-为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？" class="headerlink" title="而 StringBuilder 为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？"></a><strong>而 StringBuilder 为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？</strong></h4><p>查看 StringBuilder 类的源码你会发现，因为 StringBuilder 并没有复写 Object 类的 hashCode() 方法和 equals() 方法，StringBuilder 用的是父类 Object 类的 hashCode 生成算法，也就是用 native 层的 hashCode 生成算法，很大概率产生的哈希值是不一样的，即使产生了一样的哈希值，Object 类的 equals() 方法比较的是两个对象的内存地址，而不是两个对象的内容，这就使得 JDK 把具有相同内容的 StringBuilder 对象判断为不同的对象，就可以存入 HashSet 集合中了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有一种学得快的方法，就是不要一次学太多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;今天，我们来探讨一个实际中不常用但却比较有意思的问题。它能帮助你理解 “HashSet中的键值是唯一的，不可重复的” 这句话的真正含义，也考验你对问题的思考深度。
    
    </summary>
    
      <category term="Java 内功强化系列" scheme="https://www.alankeene.com/categories/Java-%E5%86%85%E5%8A%9F%E5%BC%BA%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Java" scheme="https://www.alankeene.com/tags/Java/"/>
    
      <category term="HashSet" scheme="https://www.alankeene.com/tags/HashSet/"/>
    
      <category term="String" scheme="https://www.alankeene.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>JDK是如何判断两个对象是否相同的？判断的流程是什么？</title>
    <link href="https://www.alankeene.com/2019/0222/how-jdk-distinguish-object.html"/>
    <id>https://www.alankeene.com/2019/0222/how-jdk-distinguish-object.html</id>
    <published>2019-02-21T16:17:40.000Z</published>
    <updated>2020-12-20T05:34:05.661Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一种学得快的方法，就是不要一次学太多。</p></blockquote><p>JDK 是如何判断两个对象是否相同的呢？判断的流程是什么？</p><p><strong>参考解答：</strong><br>JDK 会先判断两个对象的hashCode是否相同，如果hashCode不同，则说明肯定是两个不同的对象了；如果hashCode相同再通过equals()方法进行进一步比较，如果equals方法返回true，则说明两个对象是相同的，如果equals方法返回false说明两个对象不同。<a id="more"></a></p><h4 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h4><p>怎么来验证这个问题呢？我们知道HashSet是不允许存储相同的键值的。所以我们可以用HashSet存储两个相同的键值来模拟，看 JDK 是如何做判断和识别的，从而验证我们的猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先自定义一个类并复写 hashCode 和 equals 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"判断 hashCode"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回1，说明所有新建的对象的哈希值都为1，也就是相同</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"判断 equals"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们用HashSet来存储两个自定义的CustomClass的对象，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        HashSet&lt;CustomClass&gt; hs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        CustomClass cs1 = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        CustomClass cs2 = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        hs.add(cs1);</span><br><span class="line">        hs.add(cs2);</span><br><span class="line">        System.out.println(<span class="string">"----hs添加完毕"</span>);</span><br><span class="line">        System.out.println(<span class="string">"hs:"</span>+hs); <span class="comment">// 打印一下hashSet集合看里面存放了什么</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">判断 hashCode </span><br><span class="line">判断 hashCode</span><br><span class="line">判断 equals</span><br><span class="line">----hs添加完毕</span><br><span class="line">判断 hashCode <span class="comment">// 此处的判断是打印输出语句执行时调用的，与分析本问题无关</span></span><br><span class="line">hs:[com.alankeene.javalib.collections.CustomClass@<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>结果分析：<br>执行 <code>hs.add(cs1)</code> 语句的时候，JDK 会先判断 cs1 所指向对象的hashCode，因为是第一次往HashSet集合里面存放元素，该元素 hashCode 在集合中肯定是还没存在的，这是个新的元素，所以直接存放进集合中，不用调用 cs1 所指向对象的 equals 方法。<br>当执行 <code>hs.add(cs2)</code> 语句时，这是第二次往集合里存放元素，有新的元素 cs2 要添加进来，那先要调用 cs2 所指向对象的 hashCode 方法看看它的哈希值是不是与集合中已有元素的哈希值重复了，发现重复了，哈希值都是1，那有可能是同一个对象，那就要调用 cs2 所指向对象的 equals 方法做进一步判断，发现 equals 方法返回 true，则判断为是重复的元素，就不往集合里添加了。</p><p>所以最终打印 HashSet 集合的时候可以看到，集合中只存放了一个元素。</p><p>我们再反证一下，把 equals 方法改为返回 false，模拟两个hashCode相同，但是是两个不同的对象的情景。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"判断 hashCode"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回1，说明所有新建的对象的哈希值都为1，也就是相同</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"判断 equals"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果会如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">判断 hashCode </span><br><span class="line">判断 hashCode</span><br><span class="line">判断 equals</span><br><span class="line">----hs添加完毕</span><br><span class="line">判断 hashCode <span class="comment">// 此处的判断是打印输出语句执行时调用的，与分析本问题无关</span></span><br><span class="line">判断 hashCode <span class="comment">// 此处的判断是打印输出语句执行时调用的，与分析本问题无关</span></span><br><span class="line">hs:[com.alankeene.javalib.collections.CustomClass@<span class="number">1</span>, com.alankeene.javalib.collections.CustomClass@<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>会发现，HashSet集合中存放了两个元素了，说明虽然 cs1 和 cs2 的哈希值相同，但是 JDK 判断为不同的元素并存入集合中了。</p><p>由此，验证了我们的猜想。JDK 是先判断 hashCode，如果 hashCode 相同再通过 equals 去判断两个对象是否相同的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有一种学得快的方法，就是不要一次学太多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JDK 是如何判断两个对象是否相同的呢？判断的流程是什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考解答：&lt;/strong&gt;&lt;br&gt;JDK 会先判断两个对象的hashCode是否相同，如果hashCode不同，则说明肯定是两个不同的对象了；如果hashCode相同再通过equals()方法进行进一步比较，如果equals方法返回true，则说明两个对象是相同的，如果equals方法返回false说明两个对象不同。
    
    </summary>
    
      <category term="Java 内功强化系列" scheme="https://www.alankeene.com/categories/Java-%E5%86%85%E5%8A%9F%E5%BC%BA%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Java" scheme="https://www.alankeene.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>你有没有想过，为什么Java中String是不可变的？</title>
    <link href="https://www.alankeene.com/2019/0219/why-string-imutable.html"/>
    <id>https://www.alankeene.com/2019/0219/why-string-imutable.html</id>
    <published>2019-02-19T08:49:34.000Z</published>
    <updated>2020-12-20T05:36:34.871Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一种学得快的方法，就是不要一次学太多。</p></blockquote><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><p>有三点：<br>1）String 在底层是用一个 private final 修饰的字符数组 value 来存储字符串的。final 修饰符保证了 value 这个引用变量是不可变的，private 修饰符则保证了 value 是类私有的，不能通过对象实例去访问和更改 value 数组里存放的字符。</p><blockquote><p>注：有很多地方说 String 不可变是 final 起的作用，其实不严谨。因为即使我不用 final 修改 value ，但初始化完成后我能保证以后都不更改 value 这个引用变量和 value[] 数组里存放的值，它也是从没变化过的。final 只是保证了 value 这个引用变量是不能更改的，但不能保证 value[] 数组里存放的字符是不能更改的。如果把 private 改为 public 修饰，String类的对象是可以通过访问 value 去更改 value[] 数组里存放的字符的，这时 String 就不再是不可变的了。所以不如说 private 起的作用更大一些。后面我们会通过 <code>代码1处</code> 去验证。 </p></blockquote><p>2）String 类并没有对外暴露可以修改 value[] 数组内容的方法，并且 String 类内部对字符串的操作和改变都是通过新建一个 String 对象去完成的，操作完返回的是新的 String 对象，并没有改变原来对象的 value[] 数组。</p><blockquote><p>注：String 类如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，也是不能保证 String 是不可变的。后面我们会通过 <code>代码2处</code> 去验证。</p></blockquote><p>3）String 类是用 final 修饰的，保证了 String 类是不能通过子类继承去破坏或更改它的不可变性的。</p><blockquote><p>注：如果 String 类不是用 final 修饰的，也就是 String 类是可以被子类继承的，那子类就可以改变父类原有的方法或属性。后面我们会通过 <code>代码3处</code> 去验证。 </p></blockquote><p>以上三个条件同时满足，才让 String 类成了不可变类，才让 String 类具有了一旦实例化就不能改变它的内容的属性。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value; <span class="comment">// 用 private final 修饰的字符数组存储字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;\</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = var1.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = var1.hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(var1, var1.length);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试问题</strong>：String 类是用什么数据结构来存储字符串的？<br>由上面 String 的源码可见，<strong>String 类是用数组的数据结构来存储字符串的</strong>。</p><h4 id="代码1处："><a href="#代码1处：" class="headerlink" title="代码1处："></a>代码1处：</h4><p>我们来看看如果把 private 修饰符换成 public，看看会发生什么？<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 先来模拟一个String类，初始化的时候将 String 转成 value 数组存储</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;  <span class="comment">// 修饰符改成了 public </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = str.toCharArray(); <span class="comment">// 初始化时转为字符数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getValue()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WhyStringImutable str = <span class="keyword">new</span> WhyStringImutable(<span class="string">"abcd"</span>);</span><br><span class="line">        System.out.println(<span class="string">"原str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue()); <span class="comment">// 打印str对象中存放的字符数组</span></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        str.value[<span class="number">1</span>] = <span class="string">'e'</span>; <span class="comment">// 通过对象实例访问value数组并修改其内容</span></span><br><span class="line">        System.out.println(<span class="string">"修改后str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue()); <span class="comment">// 打印str对象中存放的字符数组</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原str中value数组的内容为：</span><br><span class="line">abcd</span><br><span class="line">----------</span><br><span class="line">修改后str中value数组的内容为：</span><br><span class="line">aecd</span><br></pre></td></tr></table></figure></p><p>由此可见，private 修改为 public 后，String 是可以通过对象实例访问并修改所保存的value 数组的，并不能保证 String 的不可变性。</p><h4 id="代码2处："><a href="#代码2处：" class="headerlink" title="代码2处："></a>代码2处：</h4><p>我们如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，看看又会发生什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = str.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外暴露可以修改 value 数组的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value[i] = ch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getValue()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WhyStringImutable str = <span class="keyword">new</span> WhyStringImutable(<span class="string">"abcd"</span>);</span><br><span class="line">        System.out.println(<span class="string">"原str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue()); <span class="comment">// 打印str对象中存放的字符数组</span></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        str.setValue(<span class="number">1</span>,<span class="string">'e'</span>); <span class="comment">// 通过set方法改变指定位置的value数组元素</span></span><br><span class="line">        System.out.println(<span class="string">"修改后str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue()); <span class="comment">// 打印str对象中存放的字符数组</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原str中value数组的内容为：</span><br><span class="line">abcd</span><br><span class="line">----------</span><br><span class="line">修改后str中value数组的内容为：</span><br><span class="line">aecd</span><br></pre></td></tr></table></figure></p><p>由此可见，如果对外暴露了可以更改 value[] 数组内容的方法，也是不能保证 String 的不可变性的。</p><h4 id="代码3处："><a href="#代码3处：" class="headerlink" title="代码3处："></a>代码3处：</h4><p>如果 WhyStringImutable 类去掉 final 修饰，其他的保持不变，又会怎样呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = str.toCharArray(); <span class="comment">// 初始化时转为字符数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getValue()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 写一个子类继承自WhyStringImutable 并修改原来父类的属性，实现子类自己的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableChild</span> <span class="keyword">extends</span> <span class="title">WhyStringImutable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] value; <span class="comment">// 修改字符数组为 public 修饰，不要 final </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutableChild</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = str.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutableChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WhyStringImutableChild str = <span class="keyword">new</span> WhyStringImutableChild(<span class="string">"abcd"</span>);</span><br><span class="line">        System.out.println(<span class="string">"原str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue());</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        str.value[<span class="number">1</span>] = <span class="string">'s'</span>;</span><br><span class="line">        System.out.println(<span class="string">"修改后str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原str中value数组的内容为：</span><br><span class="line">abcd</span><br><span class="line">----------</span><br><span class="line">修改后str中value数组的内容为：</span><br><span class="line">ascd</span><br></pre></td></tr></table></figure></p><p>由此可见，如果 String 类不是用 final 修饰的，是可以通过子类继承来修改它原来的属性的，所以也是不能保证它的不可变性的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上所分析，String 不可变的原因是 JDK 设计者巧妙的设计了如上三点，保证了String 类是个不可变类，让 String 具有了不可变的属性。考验的是工程师构造数据类型，封装数据的功力，而不是简单的用 final 来修饰，背后的设计思想值得我们理解和学习。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>从上面的分析，我们知道，String 确实是个不可变的类，但我们就真的没办法改变 String 对象的值了吗？不是的，<strong>通过反射可以改变 String 对象的值</strong>。</p><p>但是请谨慎那么做，<strong>因为一旦通过反射改变对应的 String 对象的值，后面再创建相同内容的 String 对象时都会是反射改变后的值</strong>，这时候在后面的代码逻辑执行时就会出现让你 “摸不着头脑” 的现象，具有迷惑性，出了奇葩的问题你也很难排除到原因。后面在 <code>代码4处</code> 我们会验证这个问题。</p><p>先来看看如何通过反射改变 String 对象的内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(<span class="string">"反射前 str:"</span>+str);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">char</span>[] aa = (<span class="keyword">char</span>[]) field.get(str);</span><br><span class="line">            aa[<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"反射后 str："</span>+str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反射前 str:<span class="number">123</span></span><br><span class="line">反射后 str：<span class="number">113</span> <span class="comment">// 可见，反射后，str 的值确实改变了</span></span><br></pre></td></tr></table></figure></p><h4 id="代码4处"><a href="#代码4处" class="headerlink" title="代码4处:"></a>代码4处:</h4><p>下面我们来验证<strong>因为一旦通过反射改变对应的 String 对象的值，后面再创建相同内容的 String 对象时都会是反射改变后的值</strong>的问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(<span class="string">"反射前 str:"</span>+str);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">char</span>[] aa = (<span class="keyword">char</span>[]) field.get(str);</span><br><span class="line">            aa[<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"反射后 str："</span>+str);</span><br><span class="line">        </span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">      System.out.println(<span class="string">"str2:"</span>+str2); <span class="comment">// 我们来看 str2 会输出什么，会输出 113？</span></span><br><span class="line">        System.out.println(<span class="string">"判断是否是同一对象："</span>+str == str2); <span class="comment">// 判断 str 和 str2 的内存地址值是否相等</span></span><br><span class="line">        System.out.println(<span class="string">"判断内容是否相同："</span>+str.equals(str2)); <span class="comment">// 判断 str 和 str2 的内容是否相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">反射前 str:<span class="number">123</span></span><br><span class="line">反射后 str：<span class="number">113</span></span><br><span class="line">str2:<span class="number">113</span> <span class="comment">// 竟然不是123？？而是输出113，说明 str2 也是反射修改后的值。</span></span><br><span class="line">判断是否是同一对象：<span class="keyword">false</span> <span class="comment">// 输出 false，说明在内存中确实创建了两个不同的对象</span></span><br><span class="line">判断内容是否相同：<span class="keyword">true</span>   <span class="comment">// 输出true，说明依然判断为两个对象内容是相等的</span></span><br></pre></td></tr></table></figure></p><p>由上面的输出结果，我们可知，反射后再新建相同内容的字符串对象时会是反射修改后的值，这就造成了很大迷惑性，在实际开发中要谨慎这么做。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有一种学得快的方法，就是不要一次学太多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;解答：&quot;&gt;&lt;a href=&quot;#解答：&quot; class=&quot;headerlink&quot; title=&quot;解答：&quot;&gt;&lt;/a&gt;解答：&lt;/h4&gt;&lt;p&gt;有三点：&lt;br&gt;1）String 在底层是用一个 private final 修饰的字符数组 value 来存储字符串的。final 修饰符保证了 value 这个引用变量是不可变的，private 修饰符则保证了 value 是类私有的，不能通过对象实例去访问和更改 value 数组里存放的字符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：有很多地方说 String 不可变是 final 起的作用，其实不严谨。因为即使我不用 final 修改 value ，但初始化完成后我能保证以后都不更改 value 这个引用变量和 value[] 数组里存放的值，它也是从没变化过的。final 只是保证了 value 这个引用变量是不能更改的，但不能保证 value[] 数组里存放的字符是不能更改的。如果把 private 改为 public 修饰，String类的对象是可以通过访问 value 去更改 value[] 数组里存放的字符的，这时 String 就不再是不可变的了。所以不如说 private 起的作用更大一些。后面我们会通过 &lt;code&gt;代码1处&lt;/code&gt; 去验证。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2）String 类并没有对外暴露可以修改 value[] 数组内容的方法，并且 String 类内部对字符串的操作和改变都是通过新建一个 String 对象去完成的，操作完返回的是新的 String 对象，并没有改变原来对象的 value[] 数组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：String 类如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，也是不能保证 String 是不可变的。后面我们会通过 &lt;code&gt;代码2处&lt;/code&gt; 去验证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3）String 类是用 final 修饰的，保证了 String 类是不能通过子类继承去破坏或更改它的不可变性的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：如果 String 类不是用 final 修饰的，也就是 String 类是可以被子类继承的，那子类就可以改变父类原有的方法或属性。后面我们会通过 &lt;code&gt;代码3处&lt;/code&gt; 去验证。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上三个条件同时满足，才让 String 类成了不可变类，才让 String 类具有了一旦实例化就不能改变它的内容的属性。
    
    </summary>
    
      <category term="Java 内功强化系列" scheme="https://www.alankeene.com/categories/Java-%E5%86%85%E5%8A%9F%E5%BC%BA%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="String" scheme="https://www.alankeene.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio mac 快捷键</title>
    <link href="https://www.alankeene.com/2019/0106/AndroidStudio-mac-shortcuts.html"/>
    <id>https://www.alankeene.com/2019/0106/AndroidStudio-mac-shortcuts.html</id>
    <published>2019-01-06T04:38:27.000Z</published>
    <updated>2019-01-07T05:45:48.522Z</updated>
    
    <content type="html"><![CDATA[<p><center>Android Studio 常用 mac 快捷键</center></p><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">⌃+⇧+Space</td><td style="text-align:center">初始化对象时，输入 new 后，按此快捷键快速输入类名</td></tr><tr><td style="text-align:center">⌥⌘B</td><td style="text-align:center">快速导航到抽象方法的实现类</td></tr><tr><td style="text-align:center">⌥⌘V</td><td style="text-align:center">mEditorPane.setBorder(BorderFatory.createEmptyBorder(5,5,5,5));<br>选中<code>BorderFatory.createEmptyBorder(5,5,5,5)</code>, 然后按此快捷键，自动提取出如下代码：<br>Border emptyBorder = BorderFactory.createEmptyBorder(5,5,5,5);<br>myEditorPane.setBorder(emptyBorder);</td></tr><tr><td style="text-align:center">⌃Space</td><td style="text-align:center">新建一个变量时，按此快捷键，编辑器会推荐一个变量名</td></tr><tr><td style="text-align:center">⌘P</td><td style="text-align:center">如果光标位于方法调用的括号之间，则按⌘P将显示有效参数列表。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      持续收集在 Android Studio 上开发常用的 mac 快捷键，提高代码编写效率，记录在这，以免忘了的时候经常需要去搜索，同时方便需要的人。
    
    </summary>
    
      <category term="记录" scheme="https://www.alankeene.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="mac快捷键" scheme="https://www.alankeene.com/tags/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Pre-built binaries not found for fsevents@1.1.3 and node@11.6.0</title>
    <link href="https://www.alankeene.com/2019/0102/fsevents-didnot-soppurt-node11.html"/>
    <id>https://www.alankeene.com/2019/0102/fsevents-didnot-soppurt-node11.html</id>
    <published>2019-01-02T14:40:08.000Z</published>
    <updated>2019-02-19T17:29:54.148Z</updated>
    
    <content type="html"><![CDATA[<p>用 <code>npm install</code> 安装 fsevent 插件， 发现如下图提示：</p><p>   <img src="/images/fsevets-download-fail.png" alt="" title="fsevets-download-fail"></p><p>搜索了一圈发现原来是 fsevents 目前还没支持 node v11+，笔者用的是 <code>brew install node</code> 下载的 node，默认下载的是最新的版本，用 <code>node -v</code> 命令查看 node 的版本呢，笔者的 node 是 v11.6.0。<a id="more"></a></p><p>详情请参阅：</p><ul><li><p><a href="https://github.com/strongloop/fsevents/issues/244" target="_blank" rel="noopener">Build binary for Node 11</a></p></li><li><p><a href="https://github.com/strongloop/fsevents/issues/170" target="_blank" rel="noopener">No binary found on s3 for Node v8.0</a></p></li></ul><p>知道了原因那在 mac 下如何快速降低 node 的版本呢？</p><p>看这：</p><ul><li><a href="https://apple.stackexchange.com/a/207883" target="_blank" rel="noopener">https://apple.stackexchange.com/a/207883</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 &lt;code&gt;npm install&lt;/code&gt; 安装 fsevent 插件， 发现如下图提示：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;/images/fsevets-download-fail.png&quot; alt=&quot;&quot; title=&quot;fsevets-download-fail&quot;&gt;&lt;/p&gt;
&lt;p&gt;搜索了一圈发现原来是 fsevents 目前还没支持 node v11+，笔者用的是 &lt;code&gt;brew install node&lt;/code&gt; 下载的 node，默认下载的是最新的版本，用 &lt;code&gt;node -v&lt;/code&gt; 命令查看 node 的版本呢，笔者的 node 是 v11.6.0。
    
    </summary>
    
      <category term="日常解决问题集锦" scheme="https://www.alankeene.com/categories/%E6%97%A5%E5%B8%B8%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    
    
      <category term="fsevents" scheme="https://www.alankeene.com/tags/fsevents/"/>
    
      <category term="node" scheme="https://www.alankeene.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>最安全的hexo多台电脑同步博客解决方案--非新建分支</title>
    <link href="https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html"/>
    <id>https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html</id>
    <published>2019-01-02T07:42:05.000Z</published>
    <updated>2019-02-19T17:27:21.665Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常有这样一个需求场景：需要在多台电脑间完成 Hexo 博客的撰写和发布，这就涉及到如何多台电脑同步博客的问题。</p><p>我最近也遇到了这个问题，网上看了很多方案，都是通过新建一个分支来存放博客源文件。但这样一来，我很多第三方插件配置的密钥信息不就暴露了吗？会不会存在数据安全隐患？有没有什么办法不暴露这些信息？对了，用一个私有仓库来存放博客源文件不就结了嘛。虽然 Github 的私有仓库是收费的，但是我的博客是同时部署在 Github 和 Coding 的，而 Coding 是可以新建私有仓库的。Nice，完美解决。</p><p>当我准备写遍博客来分享（xuan yao）这个解决方案时，最后还是荣幸的发现一遍文章已经分享了这个方案，只是在搜索引擎中不太好搜出来。本着“不重复造轮子的原则”，笔者就不重写了，而且他已经写的很好了。但是有几个问题需要特别注意一下：</p><ol><li><p>该文中删除主题的 .git 配置，如果你有多个主题文件夹的话，需要都删除(如 NexT 主题)。然后删除的命令那位笔者不小心写错了，应该是：<br> <code>rm -rf ./themes/next/.git/</code></p><p> 用这条命令来删除你对应主题文件夹里的.git 文件夹，注意 .git 是一个隐藏文件夹。</p></li><li><p><code>.gitignore</code> 文件夹在 Hexo 的根目录下可能已经存在了，可以打开和该文中的忽略事项比对一下，如果一样，接着 <code>git init</code> 初始化 git 仓库就好；如果没有该 <code>.gitignore</code> 文件夹就新建一个添加相应忽略事项再 <code>git init</code> 初始化。</p></li><li><p><strong>这点需要特别注意，否则可能导致迁移失败：</strong><br> 虽然我们第 1 步中删除了主题的 .git 配置，第 2 步中Hexo项目根目录的 <code>.gitignore</code> 文件也并没有忽略掉 <code>theme</code> 这个文件夹。<strong>但是！！</strong> NexT 主题的文件夹原来是用 git 来管理的，里面还有一个 <code>.gitignore</code> 文件，把 <code>themes/next/source/lib</code> 目录下的很多文件给忽略掉了。<br> 这就导致了你上传到私有仓库时，你以为你把 <code>themes</code>  文件下的所有内容都上传到仓库了，但其实 “偷偷”的把 <code>themes/next/source/lib</code> 目录下的很多必要的文件也忽略掉了，并没有上传。然后在新电脑上拉下来的时候，<code>hexo g</code>、<code>hexo s</code> 一预览，你会奇怪的发现：<strong>所有的 FontAwesome 相关的图标都不见了，其他的功能一切正常。</strong></p><p><strong>正确的做法是</strong>：在新机器上把私有仓库上的博客源文件 clone 下来后，因为还缺点原来的文件，所以应该去原来机器上 <code>themes/next/source/lib</code> 目录下，把整个 lib 目录下的文件全部复制粘贴到新机器对应的 <code>themes/next/source/lib</code> 目录下，这样就能正常生成站点文件了。</p><blockquote><p>注意：同理，如果你的 <code>themes</code> 目录下有多个主题配置文件的话，可以查看是否有 <code>.gitignore</code> 文件，用 git    上传私有仓库时是否也忽略了一些必要资源，如果有再新电脑上对应复制过来就 OK 了。</p></blockquote><p>   关于这个问题的详情，可查看：<a href="https://github.com/theme-next/hexo-theme-next/issues/564#issuecomment-451385682" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next/issues/564#issuecomment-451385682</a> </p></li><li><p>在新电脑上 <code>npm install</code> 下载 hexo 所需的环境的时候，要切到 hexo 的根目录下，再执行 <code>npm install</code>。</p></li><li><p>当你在新电脑用 <code>npm install</code> 下载依赖的第三插件时，由于 node 的版本、众多第三方插件、跨平台等原因，可能有的插件会存在兼容性问题，导致下载不下来，笔者想迁移到 Mac 上就遇到兼容性问题了，<code>fsevent</code> 插件目前不支持 node v11+ 版本，而刚配置新电脑的 node 环境时，默认安装的是最新版的 node，需要降低 node 的版本才能下载成功。 </p><ul><li><a href="https://www.alankeene.com/2019/0102/fsevents-didnot-soppurt-node11.html">node 11 无法安装 fsevents 插件的解决方案</a></li></ul><p>至于如何降低 node 的版本，其实你不用删除，有一个叫 <code>nvm</code> （Node Version Manager）的工具，专门用来管理多个版本的 node 环境的，你可以下载多个版本的 node 存在你的机器中，用 <code>nvm</code> 的命令行就可以实现不同版本 node 环境的随意切换，非常方便。</p><ul><li><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">这是 nvm 的 github 地址</a></li></ul></li><li><p>好，当你在新的电脑上写完博客，本地预览也没问题，准备用 <code>hexo d</code> 部署到 Github 和 Coding 上前，别忘了把新电脑的 SSH 公钥配置到 Github 和 Coding 上。</p><p>然后用 <code>hexo d</code>部署时，由于在新机器上，SSH 密钥和之前的不一样，第一次尝试连接 Github 主机时会提示：<br><code>The authenticity of host github.com can&#39;t be established.</code><br><code>Are you sure you want continue connecting?</code></p><p>输入 <code>yes</code> 就好，同理 coding 仓库也会提示，同样输入<code>yes</code>。至此，新电脑上写完的博客也成功同步更新到 Github 和 Coding 的仓库上了。</p><p>更新完博客后，记得    用 <code>git push</code> 将新电脑上改动的博客源文件也 push 到私有仓库中，实现博客源文件的同步更新。</p></li><li><p>当你在另一台电脑上准备开始写博客前，记得把远程私有仓库的最新博客源文件拉到本地，<strong>但记得不要用 <code>git pull</code> 的方式</strong>，用如下两条命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all    <span class="comment">#将远程git仓库上最新的内容拉取到本地,将本地库所关联的远程库更新至最新</span></span><br><span class="line">git reset --hard origin/<span class="keyword">master</span>   <span class="title">#强制将本地库的内容指向最新远程仓库的master</span>分支</span><br><span class="line">     </span><br></pre></td></tr></table></figure></li></ol><p>最后附上该篇博客的地址：</p><ul><li><a href="https://ricky.moe/2017/01/13/hexo-perfect-synchronize/" target="_blank" rel="noopener">最完美的Hexo多电脑同步方法</a></li></ul><p>从此，你就可以在多台电脑间愉快地写博客啦～</p><p>本迁移解决方案博主亲测有效，请放心迁移，迁移过程中如果还遇到什么问题欢迎和我交流。</p><hr><p><code>2019.1.8 最新更新：</code> <strong>好消息</strong>是：Github 从 2019.1.8 日起可以免费使用私有仓库了，那大家也可以选择把博客源文件传到 Github 私有仓库上，维护起来更加方便了。</p>]]></content>
    
    <summary type="html">
    
      目前网上大部分 hexo 多电脑同步博客方案都是新建一个开源分支去存放博客源文件，但是你会发现，这样做的话很多第三插件配置的appid、app_key等密钥信息也暴露在了公开的仓库里，存在一定的数据安全隐患。本文将介绍一种新建私有仓库来管理博客源文件的方案来解决上述问题。
    
    </summary>
    
      <category term="经验" scheme="https://www.alankeene.com/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="https://www.alankeene.com/tags/hexo/"/>
    
      <category term="多电脑同步博客" scheme="https://www.alankeene.com/tags/%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>dryrun 在 windows 上的使用教程</title>
    <link href="https://www.alankeene.com/2018/0618/use-dryrun-in-windows.html"/>
    <id>https://www.alankeene.com/2018/0618/use-dryrun-in-windows.html</id>
    <published>2018-06-18T05:30:51.000Z</published>
    <updated>2020-12-20T05:20:32.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>有些坑别人踩过了，希望你不用再踩一遍。 </p></blockquote><center><img src="https://github.com/cesarferreira/dryrun/raw/master/extras/gift.gif" alt=""></center> <p>dryrun 的作者使用的是 Mac，本文主要介绍 dryrun 在 windows 上配置使用的方法以及容易导致配置不成功的关键点，为想在 windows 上也能使用 dryrun 的 Android 开发者提供参考。<a id="more"></a></p><h2 id="dryrun-是个什么工具？能帮我们提高什么效率？"><a href="#dryrun-是个什么工具？能帮我们提高什么效率？" class="headerlink" title="dryrun 是个什么工具？能帮我们提高什么效率？"></a>dryrun 是个什么工具？能帮我们提高什么效率？</h2><p>简单来说，dryrun 是帮助 Android 开发者快速预览 Github 上开源 Android 项目在真机上的实际运行效果的工具。</p><p>使用 dryrun 工具，可以避免下载解压、导入项目、编译、运行在手机上一系列的动作，简单一行命令 <code>dryrun + Github 上的项目地址</code> 就可以把 Github 上的 Android 项目安装到真机上预览实际的效果了。</p><p><a href="https://github.com/cesarferreira/dryrun" target="_blank" rel="noopener">dryrun 的 Github 地址</a></p><p>windows 上安装和配置 dryrun 所需环境请参考：</p><p><a href="https://www.jianshu.com/p/9cc10563ab41" target="_blank" rel="noopener">Windows 环境下的 dryrun 使用教程</a></p><p>但笔者按照以上教程并没有配置成功，有几个坑点上文中尚未提及，需要另外注意一下：</p><ol><li><p><strong>关于下载哪个版本的 Ruby 和 DevKit</strong></p><p> 据网上说，Ruby 最新版已经内置了 DevKit，但笔者尝试了最新版的 Ruby 的安装，发现安装过程及配置稍微复杂，不适合完全不懂 Ruby 的小白，而我们作为想使用 <code>dryrun 工具</code> 的Android 开发者，只是需要 ruby 的一个环境，并不需要用到 Ruby 的最新特性，所以笔者建议如果你不太了解最新版的 Ruby 如何去安装和配置的话，像笔者一样下载：</p><p> <a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">2.3.3 版本的 Ruby</a> 和 <a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">DevKit For use with Ruby 2.0 to 2.3 </a></p><p> 然后按照教程以及容易忽略的坑点去安装和配置即可。</p></li><li><p><strong>需要配置 JAVA_HOME 环境变量。</strong></p><p> 由于新版的 Android Studio 已经帮我们内置了 JDK ,我们 Android 开发者不需要再像以前那样需要单独的配置 JAVA 环境，所以<strong>容易忽略了 dryrun 安装时需要的 JAVA 环境</strong>。<br> 如果你的机器尚未配置 JAVA 环境变量，按照教程执行到 <code>gem install dryrun --source http://rubygems.org</code> 安装 <code>dryrun</code> 的步骤时，会安装不成功，仔细看日志会发现是缺少了 JAVA 环境变量。配置好 JAVA_HOME 环境变量再执行安装命令就能安装成功了。<br> 至于如何配置 JAVA 环境变量，想必想使用 dryrun 的人应该都会了，如果你恰巧不会或忘了，网上也有很多配置教程可以找到，不用担心。</p></li><li><p><strong>需要配置 ANDROID_HOME 环境变量。</strong></p><p> 安装好了 dryrun 后，执行 <code>dryrun + Github 项目地址</code> 去在真机上下载并预览项目时，如果没有配置 Android_HOME 环境变量，会发现项目下载不下来。配置一下 ANDROID_HOME 环境变量即可，也就是配置一下 SDK 的路径。</p></li></ol><p>好了，在 windows 上使用 dryrun 的方法以及容易忽略的几个坑点已经讲解完毕了，希望你们都能愉快的一次性就安装成功，不用踩坑，然后就是愉快的逛 Github 去学习啦~ </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;有些坑别人踩过了，希望你不用再踩一遍。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img src=&quot;https://github.com/cesarferreira/dryrun/raw/master/extras/gift.gif&quot; alt=&quot;&quot;&gt;&lt;/center&gt; 

&lt;p&gt;dryrun 的作者使用的是 Mac，本文主要介绍 dryrun 在 windows 上配置使用的方法以及容易导致配置不成功的关键点，为想在 windows 上也能使用 dryrun 的 Android 开发者提供参考。
    
    </summary>
    
      <category term="提高开发效率的工具" scheme="https://www.alankeene.com/categories/%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="dryrun 使用" scheme="https://www.alankeene.com/tags/dryrun-%E4%BD%BF%E7%94%A8/"/>
    
      <category term="dryrun windows 使用" scheme="https://www.alankeene.com/tags/dryrun-windows-%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android Things 官方开发文档(中文版)</title>
    <link href="https://www.alankeene.com/2018/0421/Android-Things.html"/>
    <id>https://www.alankeene.com/2018/0421/Android-Things.html</id>
    <published>2018-04-21T13:44:41.000Z</published>
    <updated>2019-01-02T07:23:26.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>有的人是因为看到才会相信，有的人是因为相信才会看到。</p></blockquote><p> <img src="/images/Android-Things.jpg" alt="" title="Android Things"></p><p>这是笔者最喜欢的一张图片了，作为一个沉稳严谨的工程师，每当笔者看到这个图片时，都不免心潮澎湃一下。</p><p>而今，全世界都在憧憬万物互联，在谈论IOT，未来会是什么样？什么时候来？</p><p>也许在互联网的世界里，未来很快就有可能到来，也许来了也会是和我们想象的形态不一样。但有一点我们可以坚信，物联网是趋势，而且肯定会来。</p><p>如果你对 Android Things 已经有一定了解，可以直接参阅笔者翻译的一本电子书：<a href="https://peter-bug.gitbooks.io/android-things/content/" target="_blank" rel="noopener">Android Things 官方开发文档(中文版)</a>，跳过下面介绍的阅读，或者直接跳到第二部分看麻省理工流体界面实验室研发出来的 Reality Editor.<a id="more"></a></p><h2 id="Android-Things-简介"><a href="#Android-Things-简介" class="headerlink" title="Android Things 简介"></a>Android Things 简介</h2><p>Android Things 正是 Google 布局物联网领域的一个操作系统，蕴含着 Google 在物联网领域的野心。</p><p>正如官方介绍的那样：</p><blockquote><p>If you can build an app, you can build a device.</p></blockquote><p>Android Things 的前身是 Goolge 2015 年发布的物联网平台 Birllo，除了继承 Brillo 的功能外，还加入了 Android Studio、 Android SDK、 Google Play 服务以及 Google 云平台等 Android 开发者熟悉的工具和服务。任何 Android 开发者现在都可以利用 Android API 和 Google 服务轻松构建智能联网设备。</p><p>连接智能手机有 Android 操作系统，连接智能穿戴设备有 Android Wear，连接平板有 Android Tablets，连接智能电视有 Android TV，连接汽车有 Android AUTO，PC端的还有 Chrome OS。很显然，Google 是想基于 Android 连接一切，打通你生活中的所有需求。</p><p>自 2016.12 发布第一个开发者预览版以来，目前 Android Things 依然在孵化中，截至笔者写稿的此时，孵化到了 Developer Preview 8，开发者预览版 8 。</p><p>Android Things 会不会在物联网领域发展起来时大展宏图不能确定，但看目前 Android Things 的演进，Google 还是对其抱有梦想。</p><p>而作为 Android 开发者，这是值得让我们兴奋的事，Android 充满了更多的可能。</p><p>笔者非常看好 Android 和 Android Things 的未来，也是从 Android Things 预览版发布开始就一直关注 Android Things 的动态。笔者认为只要我们的计算平台还是手机，Android 的前景就是光明的，互联网的变革之后，现在我们的人在哪？就在手机里。人在哪服务就会在哪，未来会有更多先进的技术、服务集成到手机里推到“人”这一端，比如现在研究出来的很多 AI 技术在努力的寻找落地应用场景，嗷嗷待哺。而手机中，Android 的全球市场份额占到了 85.9%，并且每年都还在增长，Android 操作系统在体验上也优化的越来越好。</p><p>笔者在 2017.5 翻译了 Android Things 的官方开发文档，并做成了一本 Gitbook 电子书，如果你想要更加详细的了解 Android Things 或者是 Android Things 的开发者，可以获得参考，免费的哦~</p><p>电子书地址：<a href="https://peter-bug.gitbooks.io/android-things/content/" target="_blank" rel="noopener">Android Things 官方开发文档(中文版)</a></p><h2 id="麻省理工的-Reality-Editor"><a href="#麻省理工的-Reality-Editor" class="headerlink" title="麻省理工的 Reality Editor"></a>麻省理工的 Reality Editor</h2><p>下面分享一下麻省理工流体界面实验室花了3年时间研发出来的一款增强现实应用，叫 Reality Editor，实现了设备功能的连接。</p><blockquote><p>Reality Editor的概念是通过手机摄像头取景，以增强现实的方式将用户周围的智能设备连接在一起，通过手指滑动即可将一系列相关的设备联通。</p></blockquote><p><img src="http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz/2g9WOaAoNdoT49dBoibLibEdmia47sVlVSJdPo7nfEQlLaicRs37ic0AwxJrxsR9tKXdK7jz9t8kDq2qqicia0lw0RNDA/0%3Fwx_fmt%3Dgif" alt=""></p><p><img src="http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz/2g9WOaAoNdoT49dBoibLibEdmia47sVlVSJpaCM42zLyyicoJSsAgPPL8icVCZJIze1pwLchVHeTAhXmG03HB3S3h5A/0%3Fwx_fmt%3Dgif" alt=""></p><p><img src="http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz/2g9WOaAoNdoT49dBoibLibEdmia47sVlVSJgOFSpI89e1TJ961ApS482ECdnz0CUKauWkuIpvU5PUGIL4iaFD0NibhQ/0%3Fwx_fmt%3Dgif" alt=""></p><hr><p>下面就是激动人心的视频啦：(前方高能，非战斗人员迅速撤离)</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=h0178alfo09&tiny=0&auto=0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;有的人是因为看到才会相信，有的人是因为相信才会看到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;/images/Android-Things.jpg&quot; alt=&quot;&quot; title=&quot;Android Things&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是笔者最喜欢的一张图片了，作为一个沉稳严谨的工程师，每当笔者看到这个图片时，都不免心潮澎湃一下。&lt;/p&gt;
&lt;p&gt;而今，全世界都在憧憬万物互联，在谈论IOT，未来会是什么样？什么时候来？&lt;/p&gt;
&lt;p&gt;也许在互联网的世界里，未来很快就有可能到来，也许来了也会是和我们想象的形态不一样。但有一点我们可以坚信，物联网是趋势，而且肯定会来。&lt;/p&gt;
&lt;p&gt;如果你对 Android Things 已经有一定了解，可以直接参阅笔者翻译的一本电子书：&lt;a href=&quot;https://peter-bug.gitbooks.io/android-things/content/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Things 官方开发文档(中文版)&lt;/a&gt;，跳过下面介绍的阅读，或者直接跳到第二部分看麻省理工流体界面实验室研发出来的 Reality Editor.
    
    </summary>
    
      <category term="Android Things" scheme="https://www.alankeene.com/categories/Android-Things/"/>
    
    
      <category term="Android Things" scheme="https://www.alankeene.com/tags/Android-Things/"/>
    
      <category term="IOT" scheme="https://www.alankeene.com/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的设计原则--一文带你理解清楚</title>
    <link href="https://www.alankeene.com/2018/0418/principles-of-OOD.html"/>
    <id>https://www.alankeene.com/2018/0418/principles-of-OOD.html</id>
    <published>2018-04-18T05:20:42.000Z</published>
    <updated>2019-01-02T07:23:26.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 </p></blockquote><p>本文主要分享对面向对象程序设计的设计原则的理解，以供想了解 OOD 设计原则的人士作参考。</p><p>主要内容包括：对设计原则和设计模式概念的理解，对 OOD 设计原则的理解，对继承和多态的理解。<a id="more"></a></p><h2 id="什么是设计原则？什么是设计模式"><a href="#什么是设计原则？什么是设计模式" class="headerlink" title="什么是设计原则？什么是设计模式?"></a>什么是设计原则？什么是设计模式?</h2><h3 id="什么是设计原则？怎么理解设计原则？"><a href="#什么是设计原则？怎么理解设计原则？" class="headerlink" title="什么是设计原则？怎么理解设计原则？"></a>什么是设计原则？怎么理解设计原则？</h3><p>如果要做个比喻，设计原则就像我们的宪法，而设计模式就像我们具体的基于宪法的各部法律，如：劳动法、海商法等等。</p><p>也就是说，设计原则是我们设计面向对象程序的纲领性指导，各种设计模式也是基于设计原则而设计的。</p><h3 id="什么是设计模式？怎么理解设计模式？"><a href="#什么是设计模式？怎么理解设计模式？" class="headerlink" title="什么是设计模式？怎么理解设计模式？"></a>什么是设计模式？怎么理解设计模式？</h3><p>设计模式是帮助开发人员在设计应用程序或系统时，解决常见问题的正式最佳实践。</p><p>也就是说，设计模式是无数前辈工程师们在日常编码过程中总结出来的一些经验，它告诉你在某种具体的需求场景下该用什么样的方式编写代码才会最好，写出来的代码扩展性和可维护性才会更强，代码更高级，解决的是具体的需求。 Java 的设计模式共有23种，分为3大类，有部分在实际工作中也不常用。</p><p>但是，理论上设计模式可以有无数种，而并非23种，因为如上所述，设计模式解决的是具体某种需求场景的设计经验，而随着时间的推移和时代的变化，需求可以发生很多变化，而对应的设计模式理论上也可以被创造出来。</p><p>而设计原则就那么几条，相对固定，只要按这几条原则去设计和组织你的代码，解决你的需求，理论上就是在创造一种新的设计模式，如果这种编码方式不属于那23条里面而且也没有人使用过的话。</p><p>所以说，<strong>设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。</strong></p><h2 id="我们应该怎样学习和掌握设计原则？"><a href="#我们应该怎样学习和掌握设计原则？" class="headerlink" title="我们应该怎样学习和掌握设计原则？"></a>我们应该怎样学习和掌握设计原则？</h2><p>在我们的日常工作中，初级工程师，甚至是高级工程师，在实际的编码工作中并不会真真切切的用到设计原则，用的更多的是设计模式去解决工作中具体的需求。</p><p>也就是说，实际工作要求我们掌握的其实更多是<strong>设计模式</strong>，而并非<strong>设计原则</strong>。所以掌握设计模式是我们的重点，是向优秀工程师迈进的必备技能。</p><h3 id="我们为什么还要学习和掌握设计原则呢？"><a href="#我们为什么还要学习和掌握设计原则呢？" class="headerlink" title="我们为什么还要学习和掌握设计原则呢？"></a>我们为什么还要学习和掌握设计原则呢？</h3><p>就像如果你不是立法机构的话，你似乎并不需要了解和掌握宪法，在日常生活中你碰到劳动相关问题了你就去了解劳动法，碰到海上贸易纠纷问题了你就去了解海商法即可。但是，这些具体的法律都是基于宪法的，如果你不了解宪法的话，你就不知道它们为什么是这样来设计的，虽然并不影响你用来解决实际问题，但你却不知道为什么。</p><p>同理，学习和掌握设计原则的目的也是如此。而且更重要的是，其实设计原则很容易理解和掌握，因为基本原则也就 5 条。当你理解了设计原则，再回来理解设计模式时，就会理解他为什么要这样写代码？为什么这样写代码是更加好的，扩展性和可维护性是更强的？</p><p>换句话说，在理解了设计原则的基础上去掌握设计模式，就会理解的更加透彻，而不仅仅是只会使用设计模式而不知道为什么要这样设计。也能以不变应万变，不变的是设计原则，变得是设计模式。</p><p>而且，理解了设计原则再去学习设计模式，会相对容易记住和掌握，并大概率是以后都不会容易忘记。否则很有可能是这种情况：在工作中遇到问题去学习一下设计模式，看懂了用来解决了实际的需求，但过几天就忘了，设计模式相关的知识学了又忘，忘了又学，反反复复，好像总是掌握不了设计模式。笔者就经历过这样的一个过程，因为设计模式虽然只有23种，但涉及的相关知识点其实很多，要想想那可是多少人多少年来才总结出来的那么点经验啊，岂能是初学者一下就能完全掌握和记住的，单纯23种设计模式的写法和对应的使用场景都不容易理解和记忆。</p><p>但如果你理解了设计原则，情况就会变得好些，在学习具体的某种设计模式的时候，你就会知道它用了什么设计原则，代码为什么是这样写的？这么写的好处是什么?</p><h2 id="SOLID-设计原则"><a href="#SOLID-设计原则" class="headerlink" title="SOLID 设计原则"></a>SOLID 设计原则</h2><p>好，了解了为什么要学习设计原则，接下来就要学习和理解设计原则了。</p><p>首先，面向对象的设计原则一共有几条？表述不一，江湖上有三种表述方法：有的说面向对象的七大原则，有的说六大原则，有的说五大原则。不过这只是不同的理解方式，对学习来说并不影响。</p><p>不过笔者参阅了维基百科 <a href="https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">SOLID (面向对象设计)</a>) 的解释，笔者的理解方式是：面向对象程序设计有五条基本原则，其他两条原则也学习了解，但不在基本原则的表述里。</p><p>而这五大基本原则，首字母简写就是 “SOLID” , 英文 “solid” 是固体的意思，固体的形态也意味着相对固定不变，很符合设计原则的思想，所以为了方便记忆，笔者也将面向对象的 SOLID 原则称为 “固体原则”。</p><h3 id="S-Single-reponsibility-principle-单一职责原则"><a href="#S-Single-reponsibility-principle-单一职责原则" class="headerlink" title="S (Single reponsibility principle) - 单一职责原则"></a>S (Single reponsibility principle) - 单一职责原则</h3><p>概念：认为 “对象应该仅有一种单一功能”。</p><p>换句话说，你在设计一个类的时候，应该有职责单一的特性，就是将一组相关性很高的函数、数据封装到一个类中。</p><p>潜台词是：尽量拆分到最小单位，解决复用和组合的问题。</p><h3 id="O-Open-closed-principle-开闭原则"><a href="#O-Open-closed-principle-开闭原则" class="headerlink" title="O (Open/closed principle) - 开闭原则"></a>O (Open/closed principle) - 开闭原则</h3><p>概念： 认为 “软件体应该是对于扩展是开放的，但对于修改是封闭” 的。</p><p>什么意思呢？</p><p>换句话说，一个类对于扩展是开放的，但对于修改是封闭的。如：我们升级、维护 APP 或系统需要增加新的功能时，应该尽量通过扩展去实现新的功能，而不是通过修改已有的代码来实现，以免带来一些难以发现的Bug。</p><p>试想一下，如果你要给一个系统增加新的功能，你通过修改源代码来实现，为了让新增的功能模块能正常运行，改了很多源代码，这时集成到系统中一测试，发现整个系统无法正常运行了，而且这个系统是已经在线上运行为用户提供服务的，你怎么办？你还要百分之百的还原原来的源码吗？</p><p>所以，开闭原则能帮我们避免一些修改风险。</p><p>潜台词: 控制需求变动时的风险，缩小维护成本</p><h3 id="L-Liskov-substitution-principle-里氏替换原则"><a href="#L-Liskov-substitution-principle-里氏替换原则" class="headerlink" title="L (Liskov substitution principle) - 里氏替换原则"></a>L (Liskov substitution principle) - 里氏替换原则</h3><p>概念： 认为 “程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的” 。</p><p>本质上说，就是告诉我们要好好利用 <strong>继承</strong> 和 <strong>多态</strong>。</p><p>从技术上简单的描述，就是以父类的形式声明的变量(或形参)，赋值为任何继承于这个父类的子类后不影响程序的执行。</p><p>潜台词：尽量使用精准的抽象类或接口。</p><p>代码举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">        child.onDraw(); <span class="comment">//调用抽象类View的抽象方法--onDraw方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类View</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测量视图的大小</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承抽象类View的子View,复写抽象方法onDraw()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//绘制一个按钮</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//绘制文本</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实例代码解释:</p><p>Window 类中的 show 函数需要传入 View, 并且调用 View 对象的 <code>onDraw()</code> 方法，而每个继承于 View 的子类对象都要实现 <code>onDraw()</code> 方法，不存在继承于 View 却没实现 <code>onDraw()</code> 方法的子类对象(abstract方法必须实现)。我们在抽象类 View 的设计时就是运用了里氏替换原则。</p><p>而当我们在调用窗口类 Window 的 <code>show()</code> 方法时，可以传入抽象类 View 的任何实现子类 <code>Button类</code> 或 <code>TextView类</code>，均不会影响程序的正常执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show(<span class="keyword">new</span> Button());</span><br><span class="line">或</span><br><span class="line">show(<span class="keyword">new</span> TextView());</span><br></pre></td></tr></table></figure></p><p>这样，你就可以实现在窗口上绘制任意一个的视图的需求了，一旦有增加新的视图的需求时，你只需要继承抽象类view并实现它的抽象方法 <code>onDraw()</code> 即可，作为参数传入 Window 类的 <code>show()</code> 方法中，Window 类就可以帮你把它绘制出来。</p><p>比如，你现在学习学累了，想在窗口上画个饼充饥，就可以实现一个画饼的子类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cake</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//画个饼充饥</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//功能实现完了，然后作为参数传入 Windows 类的 show() 方法</span></span><br><span class="line">show(<span class="keyword">new</span> Cake());</span><br></pre></td></tr></table></figure></p><p>其实，这种设计思想无处不在，你每天都能遇到，Android 中的 View 的绘制就是使用了这种思想。</p><h4 id="如何理解多态和继承？"><a href="#如何理解多态和继承？" class="headerlink" title="如何理解多态和继承？"></a>如何理解多态和继承？</h4><p>多态的概念：同一个行为具有多个不同的表现形式或形态的能力。</p><p>举例：Window类的 <code>show()</code> 方法都是调用 View.onDraw() 的功能，但 TextView 和 Button 各自的 <code>onDraw()</code> 方法的表现形式不一样。</p><p>多态的好处：可以使程序有良好的扩展性，并可以对所有类的对象进行通用处理。用通俗的话说就是：一键修改，到处应用。</p><p><strong>举例</strong>：实现抽象类 View 的抽象方法 <code>onDraw()</code> ,TextView 和 Button 实现了不同的绘制行为，即多态，扩展成不同的需求或功能。而与此同时，如果修改了抽象父类 View 的绘制行为，所有调用 View 的 Window 对象相应的 <code>show()</code> 行为也统一进行了更改。</p><p>笔者想到我们的一句俚语，用来帮助理解继承和多态再合适不过了：<strong>“一母生九子，连母十个样”</strong>。</p><p>“母”即父类，“九子”则继承自“母”这个父类，“连母十个样”：说明子类和父类都可以有不同的行为，也就是多态。</p><p>注意：<strong>Java 中类只能单继承，但可以多实现</strong>。用俚语帮助理解就是：每个人只能有一个爸爸(单继承)，但可以有多个兄弟(多实现)。</p><h3 id="I-Interface-segregation-principle-接口隔离原则"><a href="#I-Interface-segregation-principle-接口隔离原则" class="headerlink" title="I(Interface segregation principle) - 接口隔离原则"></a>I(Interface segregation principle) - 接口隔离原则</h3><p>概念：认为 “多个特定客户端接口要好于一个宽泛用途的接口”。</p><p>也就是说，类之间的依赖关系应该建立在最小的接口上。其原则是将非常庞大的、臃肿的接口拆分成更小的更具体的接口。</p><p>潜台词： 尽量拆分成功能更具体的接口。</p><h3 id="D-Dependency-inversion-principle-依赖反转原则"><a href="#D-Dependency-inversion-principle-依赖反转原则" class="headerlink" title="D(Dependency inversion principle) - 依赖反转原则"></a>D(Dependency inversion principle) - 依赖反转原则</h3><p>概念：认为 “一个方法应该遵从依赖于抽象而不是一个实例” 。我们常用的依赖注入就是该原则的一种实现方式。</p><p>也就是说，要实现解耦，使得高层次的模块不依赖于低层次模块的具体实现细节，二者都应该依赖其抽象(抽象类或接口)。</p><p>其实，在我们用的 Java 语言中，抽象就是指接口或者抽象类，二者都是不能直接实例化的；细节就是实现类，实现接口或者继承抽象类而产生的类，就是细节。</p><p>使用 Java 语言描述就简单了，就是各个模块之间相互传递的参数声明为抽象类型，而不是声明为具体的类。</p><p>潜台词: 要面向抽象编程，解耦调用者和被调用者。</p><p>OK, 至此五大基本原则就解释完了，剩下两条原则我们也了解一下，帮助理解。</p><h3 id="迪米特原则-Law-of-Demeter"><a href="#迪米特原则-Law-of-Demeter" class="headerlink" title="迪米特原则 - Law of Demeter"></a>迪米特原则 - Law of Demeter</h3><p>也称：最少知识原则，认为 “一个对象应当对其他对象有尽可能少的了解”。</p><p>也就是说，一个类应该对自己调用的类的实现细节知道的越少越好。</p><p>举例：假设类 A 实现了某个功能，类 B 需要调用类 A 去执行这个功能，那么类 A 应该只暴露一个方法(函数)给类 B 去调用即可，而不是让类 A 把实现这个功能的细节(所有细分的方法和成员)暴露给 B 。</p><p>其实，这也是面向对象程序设计的最基本思想，是面向对象程序设计语言与面向过程程序设计语言最显著的差异。</p><p>潜台词：不要和陌生人说话，有事去找中介。</p><h3 id="组合复用原则-Composite-Reuse-Principle"><a href="#组合复用原则-Composite-Reuse-Principle" class="headerlink" title="组合复用原则 - Composite Reuse Principle"></a>组合复用原则 - Composite Reuse Principle</h3><p>简称：CRP，也称聚合复用原则 - Aggregate Reuse Principle，简称ARP。或者连起来称：组合/聚合复用原则，简称CARP。</p><p>概念：认为 “如果只是为了达到复用的目的，应尽量使用对象组合与聚合，而不是继承。</p><p>因为继承的耦合性更大，而组合、聚合只是引用类的方法，没有这么维护风险同时也实现了复用的目的。</p><p>潜台词：我只是用了你的方法去实现我要的功能，我们不是同类，没有继承关系。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们把面向对象的设计原则讲解完了。你可能会突然发现：哦，原来这么熟悉，原来面向对象的设计原则就在我们身边。是的，其实它就在我们每天的日常编码工作中，只是可能没发现并试图理解它。</p><p>而且设计原则东西就这么点，也很容易学习和掌握。为了帮助读者学习理解并掌握，以及对后面学习设计模式产生帮助，本文花了不少篇幅介绍为什么要学习设计原则，学了有什么好处？真正讲解设计原则方面的知识其实你也发现了，也就那么点。</p><p>OK，最后总结一下本文重点：设计原则和设计模式的概念以及怎么去理解，为什么要学习设计原则，面向对象的设计原则(SOLID),怎么理解多态和继承。</p><p>下篇预告：学习完了设计原则，我们就要来讲解 <strong>设计模式</strong> 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文主要分享对面向对象程序设计的设计原则的理解，以供想了解 OOD 设计原则的人士作参考。&lt;/p&gt;
&lt;p&gt;主要内容包括：对设计原则和设计模式概念的理解，对 OOD 设计原则的理解，对继承和多态的理解。
    
    </summary>
    
      <category term="OOD设计原则" scheme="https://www.alankeene.com/categories/OOD%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="OOD" scheme="https://www.alankeene.com/tags/OOD/"/>
    
      <category term="设计原则" scheme="https://www.alankeene.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Android 简史</title>
    <link href="https://www.alankeene.com/2018/0417/Android-history.html"/>
    <id>https://www.alankeene.com/2018/0417/Android-history.html</id>
    <published>2018-04-17T05:36:17.000Z</published>
    <updated>2019-01-02T07:23:26.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>有一种了解一个事物的方法，那就是了解它的发展历史。 </p></blockquote><p>本文将持续更新记录 Android 的发展简史，以供喜欢 Android 和想了解 Android 的爱好者作参考。</p><p>Android 自 2008 年正式发布至今(2018)，已经走过了十个年头了。像一个小孩的长大一样，十年，对于一生来说，说长不长，仿佛不知不觉就长大了，说短也不短，至少我们不少人都错过了见证 Android 的成长历程，笔者也是 2015 年才开始对 Android 感兴趣并开始了解 Android 的。<a id="more"></a></p><p>这十年，Android 已经迭代了好多个版本，解决或优化了一些人们常诟病的问题，也有许多优秀的体验和设计方面的创新，至今已经占有约 85.9% 的全球市场份额，而且我们相信，Android 还会发展的越来越好。那么，接下来我们一起看看 Android 的发展简史吧。</p><h2 id="Android-前传"><a href="#Android-前传" class="headerlink" title="Android 前传"></a>Android 前传</h2><p>即 Android 操作系统的孵化阶段。 Android 是由 Google 和开放手持设备联盟共同开发发展而来的。</p><p>Android 在正式发布之前，最开始拥有两个内测版，并且以著名的机器人名称来对其进行命名，它们分别是：铁臂阿童木(Astro boy) 和发条机器人(Bender)。<br>后来，由于涉及版权问题，Google 将其命名规则变更为用 <strong>甜点</strong> 作为它们系统版本的代号的命名方法。</p><p>“甜点命名法”开始于第三版 Android 1.5(实际上是第四版，因为 Android 1.0 其实有两版)。而从 Android 1.6 Donut(<strong>甜甜圈</strong>) 开始，项目组才正式确定将 Android 开发代号首字母从 “C” 一直延续下去。</p><h2 id="Android-命名的由来"><a href="#Android-命名的由来" class="headerlink" title="Android 命名的由来"></a>Android 命名的由来</h2><p>Android 一词最早出现于法国作家利尔亚当（Auguste Villiers de l’Isle-Adam）在1886年发表的科幻小说《未来夏娃》（L’Ève future）中。他将外表像人的机器人取名为 Android。</p><h2 id="Android-的生日"><a href="#Android-的生日" class="headerlink" title="Android 的生日"></a>Android 的生日</h2><p>5.11 <strong>被认为</strong>是 Android 的生日。</p><h2 id="Android-的标志"><a href="#Android-的标志" class="headerlink" title="Android 的标志"></a>Android 的标志</h2><p>Android 是一个全身绿色的机器人，颜色采用了 PMS 376C 和 RGB 中十六进制的 #A4C639 来绘制，这是 Android 操作系统的品牌象征。</p><p>Android 的标志是由 Ascender 公司设计的，其中的文字使用了 Ascender 公司专门制作的称之为 “Google Droid” 的字体。</p><h2 id="Android-发展简史"><a href="#Android-发展简史" class="headerlink" title="Android 发展简史"></a>Android 发展简史</h2><table><thead><tr><th style="text-align:center">时间线</th><th style="text-align:center">发布概述</th><th style="text-align:center">版本号</th><th style="text-align:center">版本代号</th><th style="text-align:center">API 等级</th><th style="text-align:center">基于的Linux Kernel版本</th></tr></thead><tbody><tr><td style="text-align:center">2008.9.23</td><td style="text-align:center">Android 1.0 第一个正式版公布。全球第一台 Android 设备 HTC Dream(G1) 搭配的就是 Android 1.0</td><td style="text-align:center">Android 1.0</td><td style="text-align:center">Astro “铁臂阿童木”</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2009.2.2</td><td style="text-align:center">Android 1.1发布</td><td style="text-align:center">Android 1.1</td><td style="text-align:center">Bender “发条机器人” [内部也叫 Petit Four”花式小蛋糕”]</td><td style="text-align:center">2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2009.4.30</td><td style="text-align:center">Android 1.5 发布</td><td style="text-align:center">Android 1.5</td><td style="text-align:center">Cupcake “纸杯蛋糕” [从此版本开始决定用<strong>“甜点命名法”</strong>]</td><td style="text-align:center">3</td><td style="text-align:center">2.6.27</td></tr><tr><td style="text-align:center">2009.9.15</td><td style="text-align:center">Android 1.6 发布</td><td style="text-align:center">Android 1.6</td><td style="text-align:center">Donut “甜甜圈” [从此版本开始决定将代号首字母从 “C,D…” 一直延续下去]</td><td style="text-align:center">4</td><td style="text-align:center">2.6.29</td></tr><tr><td style="text-align:center">2009.10.26</td><td style="text-align:center">Android 2.0 发布</td><td style="text-align:center">Android 2.0</td><td style="text-align:center">Eclair “松饼”</td><td style="text-align:center">5</td><td style="text-align:center">2.6.29</td></tr><tr><td style="text-align:center">2009.12.3</td><td style="text-align:center">Android 2.0.1 发布</td><td style="text-align:center">Android 2.0.1</td><td style="text-align:center">Eclair “松饼”</td><td style="text-align:center">6</td><td style="text-align:center">2.6.29</td></tr><tr><td style="text-align:center">2010.1.12</td><td style="text-align:center">Android 2.1 发布</td><td style="text-align:center">Android 2.1</td><td style="text-align:center">Eclair “松饼”</td><td style="text-align:center">7</td><td style="text-align:center">2.6.29</td></tr><tr><td style="text-align:center">2010.5.20</td><td style="text-align:center">Android 2.2 发布</td><td style="text-align:center">Android 2.2</td><td style="text-align:center">Froyo “冻酸奶”</td><td style="text-align:center">8</td><td style="text-align:center">2.6.32</td></tr><tr><td style="text-align:center">2010.12.7</td><td style="text-align:center">Android 2.3 发布</td><td style="text-align:center">Android 2.3</td><td style="text-align:center">Gingerbread “姜饼”</td><td style="text-align:center">9</td><td style="text-align:center">2.6.35</td></tr><tr><td style="text-align:center">2010.12</td><td style="text-align:center">Android 2.3.3 更新包于 2011.2.9 正式发布，仅对上一个版本进行了API改进</td><td style="text-align:center">Android 2.3.3</td><td style="text-align:center">Gingerbread “姜饼”</td><td style="text-align:center">10</td><td style="text-align:center">2.6.35</td></tr><tr><td style="text-align:center">2011.2.2</td><td style="text-align:center">Android 3.0 发布，Android 3.0 是第一个 Android 平板操作系统，全球第一个使用该版本操作系统的设备是摩托罗拉公司于 2011.2.24 发布的 Motorlola Xoom 平板电脑</td><td style="text-align:center">Android 3.0</td><td style="text-align:center">Honeycomb “蜂巢”</td><td style="text-align:center">11</td><td style="text-align:center">2.6.36</td></tr><tr><td style="text-align:center">2011.5.10</td><td style="text-align:center">Android 3.1 发布</td><td style="text-align:center">Android 3.1</td><td style="text-align:center">Honeycomb “蜂巢”</td><td style="text-align:center">12</td><td style="text-align:center">2.6.36</td></tr><tr><td style="text-align:center">2011.7.15</td><td style="text-align:center">Android 3.2 发布，全球第一台使用该版本操作系统的设备是华为公司制造生产的 MediaPad 平板电脑</td><td style="text-align:center">Android 3.2</td><td style="text-align:center">Honeycomb “蜂巢”</td><td style="text-align:center">13</td><td style="text-align:center">2.6.36</td></tr><tr><td style="text-align:center">2011.10.19</td><td style="text-align:center">Android 4.0 于2011年4月在 Google I/O 大会上首次被宣布，并于 2011.10.19 正式发布 Android 4.0 和搭载 Android 4.0 的 Galaxy Nexus 智能手机。</td><td style="text-align:center">Android 4.0</td><td style="text-align:center">Ice Cream Sandwich “雪糕三明治”</td><td style="text-align:center">14</td><td style="text-align:center">3.0.1</td></tr><tr><td style="text-align:center">2011.12.16</td><td style="text-align:center">Android 4.0.3 发布</td><td style="text-align:center">Android 4.0.3</td><td style="text-align:center">Ice Cream Sandwich “雪糕三明治”</td><td style="text-align:center">15</td><td style="text-align:center">3.0.1</td></tr><tr><td style="text-align:center">2012.6.28</td><td style="text-align:center">Android 4.1 在 Google I/O 大会上和搭载 Android 4.1 的 Nexus 7 平板电脑一起发布</td><td style="text-align:center">Android 4.1</td><td style="text-align:center">JellyBean “果冻豆”</td><td style="text-align:center">16</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2012.10.30</td><td style="text-align:center">Android 4.2 以新闻稿的形式发布。Google原本预计于2012年10月29日于纽约发布Android 4.2，但因为飓风桑迪吹袭被取消，而改以新闻稿发布，以“一种新口味的果冻豆”（A new flavor of Jelly Bean）作口号。首款搭载Android 4.2的手机LG Nexus 4及平板电脑Nexus 10于2012年11月23日上市。</td><td style="text-align:center">Android 4.2</td><td style="text-align:center">JellyBean “果冻豆”</td><td style="text-align:center">17</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2013.7.25</td><td style="text-align:center">Android 4.3 发布</td><td style="text-align:center">Android 4.3</td><td style="text-align:center">JellyBean “果冻豆”</td><td style="text-align:center">18</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2013.10.31</td><td style="text-align:center">Android 4.4 发布，Android 在此版本封锁了Adobe Flash Player 功能，此版本后不再支持 Falsh。</td><td style="text-align:center">Android 4.4</td><td style="text-align:center">Kitkat “奇巧巧克力”</td><td style="text-align:center">19</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2014.6.20</td><td style="text-align:center">Android 4.4.4 发布</td><td style="text-align:center">Android 4.4.4</td><td style="text-align:center">Kitkat “奇巧巧克力”</td><td style="text-align:center">20</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2014.10.16</td><td style="text-align:center">Android 5.0 发布。2014.6.25 在 Google I/O 大会上展示 Android L 的开发者预览版本，并开放下载。并于 2014.10.16 正式发布 Android 5.0 且命名为 Lollipop。此后，Android 沿袭了这种版本演进和发布的方式。<strong>此版本后，采用全新的 Material Design 界面</strong>，我们喜爱的 MD 设计诞生了。</td><td style="text-align:center">Android 5.0</td><td style="text-align:center">Lollipop “棒棒糖”</td><td style="text-align:center">21</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2015.3.10</td><td style="text-align:center">Android 5.1 发布</td><td style="text-align:center">Android 5.1</td><td style="text-align:center">Lollipop “棒棒糖”</td><td style="text-align:center">22</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2015.10.5</td><td style="text-align:center">Android 6.0 发布。2015.5.29 Google 在 I/O 大会啥昂展示 Android M 的开发者预览版，并于 2015.10.5 正式发布 Android 6.0 并将其命名为 Marshmallow。沿袭了上一版本的演进方式，以至于每年猜测和讨论 Android 版本的最终命名代号成了 Android 爱好者的一大乐趣。</td><td style="text-align:center">Android 6.0</td><td style="text-align:center">Marshmallow “棉花糖”</td><td style="text-align:center">23</td><td style="text-align:center">3.14.52</td></tr><tr><td style="text-align:center">2016.8.22</td><td style="text-align:center">Android 7.0 正式发布。2016.3.9 Google 发布 Android N 的开发者预览版并开放下载。于2016.8.22 正式发布 Android 7.0 并将其命名为 Nougat。</td><td style="text-align:center">Android 7.0</td><td style="text-align:center">Nougat “牛扎糖”</td><td style="text-align:center">24</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2016.10.4</td><td style="text-align:center">Android 7.1 发布</td><td style="text-align:center">Android 7.1</td><td style="text-align:center">Nougat “牛扎糖”</td><td style="text-align:center">25</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2017.8.21</td><td style="text-align:center">Android 8.0 正式发布。2017.3.21 Google 发布 Android O 的开发者预览版，并于 2017.8.21 正式发布 Android 8.0 并将其命名为 Oreo。</td><td style="text-align:center">Android 8.0</td><td style="text-align:center">Oreo “奥利奥”</td><td style="text-align:center">26</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2017.12.5</td><td style="text-align:center">Android 8.1 发布</td><td style="text-align:center">Android 8.1</td><td style="text-align:center">Oreo “奥利奥”</td><td style="text-align:center">27</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2018.3.7</td><td style="text-align:center">Google 发布 Android P 的开发者预览版并开放下载。</td><td style="text-align:center">历史待续而来..</td><td style="text-align:center">笔者猜测叫 Pizza “披萨”</td><td style="text-align:center">待续…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>如果还想了解各版本技术特性上的演进史和更多演进细节，请参阅：</p><p><a href="https://en.wikipedia.org/wiki/Android_version_history" target="_blank" rel="noopener">Android version history</a></p><p><a href="https://zh.wikipedia.org/wiki/Android%E6%AD%B7%E5%8F%B2%E7%89%88%E6%9C%AC" target="_blank" rel="noopener">Android历史版本</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;有一种了解一个事物的方法，那就是了解它的发展历史。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将持续更新记录 Android 的发展简史，以供喜欢 Android 和想了解 Android 的爱好者作参考。&lt;/p&gt;
&lt;p&gt;Android 自 2008 年正式发布至今(2018)，已经走过了十个年头了。像一个小孩的长大一样，十年，对于一生来说，说长不长，仿佛不知不觉就长大了，说短也不短，至少我们不少人都错过了见证 Android 的成长历程，笔者也是 2015 年才开始对 Android 感兴趣并开始了解 Android 的。
    
    </summary>
    
      <category term="Android" scheme="https://www.alankeene.com/categories/Android/"/>
    
    
      <category term="Android简史" scheme="https://www.alankeene.com/tags/Android%E7%AE%80%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>用 hexo 搭建博客踩过的坑</title>
    <link href="https://www.alankeene.com/2018/0412/next-problems.html"/>
    <id>https://www.alankeene.com/2018/0412/next-problems.html</id>
    <published>2018-04-12T13:43:47.000Z</published>
    <updated>2019-01-02T07:23:26.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>路是人走出来的，但有些路，希望你不用再摸索着走一遍。 </p></blockquote><p>本文将持续更新记录使用 hexo 框架 NexT 主题搭建博客过程中遇到并解决的坑。以供使用此方式搭建博客的人作参考之用，避免再重复踩坑。<a id="more"></a></p><h2 id="hexo-leancloud-counter-security插件"><a href="#hexo-leancloud-counter-security插件" class="headerlink" title="hexo-leancloud-counter-security插件"></a>hexo-leancloud-counter-security插件</h2><p>当你需要按照 <a href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener">这篇教程</a> 去集成 <code>hexo-leancloud-counter-security</code> 插件时，一定要注意要先让 <code>Counter</code> 初始化成功后，再集成 <code>hexo-leancloud-counter-security</code> 插件，否则文章阅读次数的地方会显示未初始化。</p><p><strong>也就是说：</strong>你需要先别配置部署 <code>hexo-leancloud-counter-security</code> 插件，而只需按照 <a href="https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.html" target="_blank" rel="noopener">这篇教程</a> 去为 NexT 主题添加文章阅读量统计功能，登陆LeanCloud后台看到 <code>Counter</code> 初始化成功并有数据后，再回来按照 <a href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener">这篇教程</a> 的步骤去集成 <code>hexo-leancloud-counter-security</code> 插件。</p><p><strong>原因:</strong> 当初是先有 <a href="https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.html" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a> 这个功能，然后考虑到阅读次数统计数据的安全性，防止被恶意篡改，才产生了 <code>hexo-leancloud-counter-security</code> 这个插件去解决这个问题的。所以老用户直接按照教程直接升级是不可能遇到这个坑的，因为他们原本就已经初始化了 <code>Counter</code> 。而如果你是初次添加 <code>为NexT主题添加文章阅读统计功能</code> ，而且也是初次集成 <code>hexo-leancloud-counter-security</code> 插件，则必须先初始化 <code>Counter</code>。</p><p>关于 <code>必须先初始化 Counter, 再集成 hexo-leancloud-counter-security 插件</code> 这点说明，官方的使用教程 (<a href="https://github.com/theme-next/hexo-theme-next/blob/3dabc1651bbfa9376815e2e561ffb9c42049a3ad/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md" target="_blank" rel="noopener">[中文版]</a> <a href="https://github.com/theme-next/hexo-theme-next/blob/3dabc1651bbfa9376815e2e561ffb9c42049a3ad/docs/LEANCLOUD-COUNTER-SECURITY.md" target="_blank" rel="noopener">[English]</a>) 目前好像还没有很明确的说明。如果你是按照官方使用教程的说明来操作，则需要注意这点，避免踩到坑。</p><p><strong>注：</strong> 由于时间有限，并没有制作针对小白的详细操作步骤，如果你按照本避坑说明集成 <code>hexo-leancloud-counter-security</code> 插件还是遇到问题，可通过邮件联系我获得具体每一步的操作指导。</p><h2 id="让-MarkdownPad-编辑器支持表格"><a href="#让-MarkdownPad-编辑器支持表格" class="headerlink" title="让 MarkdownPad 编辑器支持表格"></a>让 MarkdownPad 编辑器支持表格</h2><p>如果在 Windows 系统下用 MarkdownPad 来写 hexo 博客，MarkdownPad编辑器的默认设置是不支持显示表格的。即常用的Markdown语法书写表格的方式(|:—-:|:—:|)在MarkdownPad编辑器中是无法正确识别并预览的。</p><p>所以，你需要修改 MarkdownPad 编辑器默认的处理器。修改方式如下：</p><p>点击: Tools –&gt; Options –&gt; Markdown –&gt; Markdown Processor,改成<strong>Markdown (Extra)</strong> 即可。</p><p>如果你是中文环境，点击: 工具 –&gt; 选项 –&gt; Markdown –&gt; Markdown 处理器，改成 <strong>Markdown (扩展)</strong> 即可。</p><h2 id="hexo-g-出错怎么办"><a href="#hexo-g-出错怎么办" class="headerlink" title="hexo g 出错怎么办"></a>hexo g 出错怎么办</h2><p>当你写完博客，<code>hexo g</code> 出错，若报错如下:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FATAL Something<span class="symbol">'s</span> wrong. Maybe you can find the solution here: </span><br><span class="line">http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render <span class="literal">error</span>: unexpected <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">file</span> at Object._prettifyError</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明 hexo 框架无法正常渲染你的文章，很有可能是你在书写文章时一不小心哪里的格式没写对造成的。</p><p>举个例子，使用 NexT 的 <code>centerquote</code> 标签时，如果不小心在关闭标签 <code>endcenterquote</code>的 <code>{</code> 和 <code>%</code> 之间多加了一个空格，写成了：<code>{ % centerquote %}</code>。</p><p>则会出现上述的 <code>hexo 无法帮你渲染文章的错误</code>，而这种格式的错误当你写完长篇的文章后，是很难再发现的。</p><p>所以，在你写文章之前，一定要熟悉 hexo 和 NexT 的文档和写作指南，避免因书写格式不对而造成无法渲染。</p><p><a href="https://hexo.io/docs/tag-plugins.html" target="_blank" rel="noopener">hexo的标签使用说明</a></p><p><a href="https://theme-next.iissnan.com/tag-plugins.html" target="_blank" rel="noopener">NexT的内建标签使用说明</a></p><p>当然，当你遇到 <code>Template render error</code> 文章无法渲染的问题时，可按提示参阅 <a href="https://hexo.io/zh-cn/docs/troubleshooting.html" target="_blank" rel="noopener">hexo的问题解答</a> 查看其他常见的问题，看是否可以找到对应的解决方案。</p><h2 id="关于-Gitment-评论系统无法登陆的问题"><a href="#关于-Gitment-评论系统无法登陆的问题" class="headerlink" title="关于 Gitment 评论系统无法登陆的问题"></a>关于 Gitment 评论系统无法登陆的问题</h2><p>如果你是按照 NexT 默认的方式去配置 Gitment 评论插件的话，你会发现 Gitment 现在登陆不了了。 授权登陆 Github 时会发生 <code>Object ProgressEvent</code> 异常。 </p><p>因为 <a href="https://gh-oauth.imsun.net" target="_blank" rel="noopener">https://gh-oauth.imsun.net</a> 域名的 HTTPS 证书今年九月份就过期了，导致无法再正常访问，作者也一直没有更新维护。</p><p>详情请参见：</p><p><a href="https://github.com/imsun/gitment/issues/170" target="_blank" rel="noopener">https://github.com/imsun/gitment/issues/170</a></p><p><a href="https://blog.julysong.com/2018/09/26/gitment/" target="_blank" rel="noopener">gitment 登录失败</a></p><p><a href="https://blog.wolfogre.com/posts/security-problem-of-gitment/" target="_blank" rel="noopener">Gitment 的安全性争议</a></p><p>目前网上也有一些对这个问题的解决方案，总结来说就是需要自己搭建个服务器，或者用别人搭好的服务器替换，但万一哪天别人换了你就又不能用了，不是长久之计，所以如果还想用 Gitment 最好还是能自己搭服务器，不然就用别的评论系统吧，比如来必力。而且，网上也存在 Gitment 安全性争议的讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;路是人走出来的，但有些路，希望你不用再摸索着走一遍。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将持续更新记录使用 hexo 框架 NexT 主题搭建博客过程中遇到并解决的坑。以供使用此方式搭建博客的人作参考之用，避免再重复踩坑。
    
    </summary>
    
      <category term="那些踩过的坑" scheme="https://www.alankeene.com/categories/%E9%82%A3%E4%BA%9B%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="踩的NexT坑" scheme="https://www.alankeene.com/tags/%E8%B8%A9%E7%9A%84NexT%E5%9D%91/"/>
    
  </entry>
  
</feed>
