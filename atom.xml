<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alan&#39;s Blog - Android</title>
  <icon>https://www.gravatar.com/avatar/25c1649ce608b07bd04ed65e3936d880</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.alankeene.com/"/>
  <updated>2019-02-23T14:16:20.443Z</updated>
  <id>https://www.alankeene.com/</id>
  
  <author>
    <name>Alan Keene</name>
    <email>alankeene0522@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个有趣的问题，如何用HashSet来存储重复的字符串？</title>
    <link href="https://www.alankeene.com/2019/0223/how-to-store-same-string-in-hashset.html"/>
    <id>https://www.alankeene.com/2019/0223/how-to-store-same-string-in-hashset.html</id>
    <published>2019-02-23T13:46:05.000Z</published>
    <updated>2019-02-23T14:16:20.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一种学得快的方法，就是不要一次学太多。</p></blockquote><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>今天，我们来探讨一个实际中不常用但却比较有意思的问题。它能帮助你理解 “HashSet中的键值是唯一的，不可重复的” 这句话的真正含义，也考验你对问题的思考深度。</p><blockquote><p>注：实际应用中，我们一般是用 ArrayList 集合来存储相同的字符串的，不会用 HashSet 来存。</p></blockquote><p>我们平时都看到或听说 HashSet 是不能用来存放重复的字符串的，是真的存放不了吗？如果面试问你这个问题，你能给出解决方案吗？</p><h3 id="2-参考解答"><a href="#2-参考解答" class="headerlink" title="2. 参考解答"></a>2. 参考解答</h3><p>先给出参考解答，然后我们再来分析为什么。 </p><p><strong>解答：</strong><br>虽然我们不能用 HashSet 来存放 String 类型重复的字符串，但我们可以用 HashSet 来存储 StringBuilder 类型重复的字符串呀。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 HashSet 来存放 String 类型的重复的字符串会发生什么？</span></span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hs1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">        hs1.add(s1);</span><br><span class="line">        hs1.add(s2);</span><br><span class="line">        hs1.add(s3);</span><br><span class="line">        System.out.println(<span class="string">"hs1:"</span>+hs1); <span class="comment">// 重复的字符串是存不进去的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 HashSet 来存放 StringBuilder 类型的重复的字符串又会发生什么？</span></span><br><span class="line"></span><br><span class="line">        HashSet&lt;StringBuilder&gt; hs2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder(<span class="string">"aaa"</span>);</span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"aaa"</span>);</span><br><span class="line">        StringBuilder sb3 = <span class="keyword">new</span> StringBuilder(<span class="string">"aaa"</span>);</span><br><span class="line">        hs2.add(sb1);</span><br><span class="line">        hs2.add(sb2);</span><br><span class="line">        hs2.add(sb3);</span><br><span class="line">        System.out.println(<span class="string">"hs2:"</span>+hs2); <span class="comment">// 咦，结果发现重复的字符串也能存进去了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 那为什么呢？我们来打印一个各个对象的hashCode看一下</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s1的hashCode:"</span>+s1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"s2的hashCode:"</span>+s2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"s3的hashCode:"</span>+s3.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sb1的hashCode:"</span>+sb1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sb2的hashCode:"</span>+sb2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"sb3的hashCode:"</span>+sb3.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hs1:[aaa]</span><br><span class="line">hs2:[aaa, aaa, aaa]</span><br><span class="line">s1的hashCode:<span class="number">96321</span></span><br><span class="line">s2的hashCode:<span class="number">96321</span></span><br><span class="line">s3的hashCode:<span class="number">96321</span></span><br><span class="line">sb1的hashCode:<span class="number">356573597</span></span><br><span class="line">sb2的hashCode:<span class="number">1735600054</span></span><br><span class="line">sb3的hashCode:<span class="number">21685669</span></span><br></pre></td></tr></table></figure></p><p>从打印结果来看，我们是不能用 HashSet 来存放 String 类型的重复字符串的(如hs1)，但我们是可以用HashSet来存放 StringBuilder 类型的重复字符串。</p><h3 id="3-为什么？"><a href="#3-为什么？" class="headerlink" title="3. 为什么？"></a>3. 为什么？</h3><p>从打印的 hashCode 来看，String 类型，相同字符串的不同 String 对象哈希值是一样的。而对于 StringBuilder 类型，相同字符串的不同对象哈希值是不同的。</p><p>要知道这个问题的答案，我们首先得了解 Java 虚拟机是如何判断两个对象是否相同的。</p><h4 id="那-Java-虚拟机是如何判断两个对象是否相同的呢？"><a href="#那-Java-虚拟机是如何判断两个对象是否相同的呢？" class="headerlink" title="那 Java 虚拟机是如何判断两个对象是否相同的呢？"></a>那 Java 虚拟机是如何判断两个对象是否相同的呢？</h4><p><strong>参考解答：</strong><br>Java 虚拟机会先判断两个对象的 hashCode 是否相同，如果 hashCode 不同，则说明肯定是两个不同的对象了；如果 hashCode 相同再通过 equals() 方法进行进一步比较，如果 equals 方法返回 true，则说明两个对象是相同的，如果equals方法返回 false 说明两个对象不同。</p><p>具体验证思路如果你感兴趣，请查看: <a href="https://www.alankeene.com/2019/0222/how-jvm-distinguish-object.html">你有没有想过: Java 虚拟机是如何判断两个对象是否相同的？判断的流程是什么？</a></p><h4 id="那为什么相同字符串的不同-String-对象哈希值是一样的，而且还被虚拟机判断为相同的对象了呢？"><a href="#那为什么相同字符串的不同-String-对象哈希值是一样的，而且还被虚拟机判断为相同的对象了呢？" class="headerlink" title="那为什么相同字符串的不同 String 对象哈希值是一样的，而且还被虚拟机判断为相同的对象了呢？"></a><strong>那为什么相同字符串的不同 String 对象哈希值是一样的，而且还被虚拟机判断为相同的对象了呢？</strong></h4><p>因为 String 类复写了 Object 类的 hashCode() 和 equals() 方法，并实现了自己的 hashCode 值生成算法和 equals 的比较规则，具有相同字符串内容的不同 String 对象在初始化时生成的 hashCode 值是一样的，并且 String 类 equals() 方法比较的是两个字符串的内容，而不是内存地址值，这两个条件同时成立， 这就使 Java 虚拟机把具有相同内容的不同 String 对象判断为相同的对象了，就不会存入 HashSet 集合中。</p><h4 id="而-StringBuilder-为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？"><a href="#而-StringBuilder-为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？" class="headerlink" title="而 StringBuilder 为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？"></a><strong>而 StringBuilder 为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？</strong></h4><p>查看 StringBuilder 类的源码你会发现，因为 StringBuilder 并没有复写 Object 类的 hashCode() 方法和 equals() 方法，StringBuilder 用的是父类 Object 类的 hashCode 生成算法，也就是用 native 层的 hashCode 生成算法，很大概率产生的哈希值是不一样的，即使产生了一样的哈希值，Object 类的 equals() 方法比较的是两个对象的内存地址，而不是两个对象的内容，这就使 Java 虚拟机把具有相同内容的 StringBuilder 对象判断为不同的对象，就可以存入 HashSet 集合中了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有一种学得快的方法，就是不要一次学太多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;今天，我们
      
    
    </summary>
    
      <category term="Java 内功强化系列" scheme="https://www.alankeene.com/categories/Java-%E5%86%85%E5%8A%9F%E5%BC%BA%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Java" scheme="https://www.alankeene.com/tags/Java/"/>
    
      <category term="String" scheme="https://www.alankeene.com/tags/String/"/>
    
      <category term="HashSet" scheme="https://www.alankeene.com/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>你有没有想过，Java虚拟机是如何判断两个对象是否相同的？判断的流程是什么？</title>
    <link href="https://www.alankeene.com/2019/0222/how-jvm-distinguish-object.html"/>
    <id>https://www.alankeene.com/2019/0222/how-jvm-distinguish-object.html</id>
    <published>2019-02-21T16:17:40.000Z</published>
    <updated>2019-02-23T14:15:34.823Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一种学得快的方法，就是不要一次学太多。</p></blockquote><p>在Java程序运行时，会产生那么多的对象，那 Java 虚拟机是如何判断两个对象是否相同的呢？判断的流程是什么？</p><p><strong>参考解答：</strong><br>Java 虚拟机会先判断两个对象的hashCode是否相同，如果hashCode不同，则说明肯定是两个不同的对象了；如果hashCode相同再通过equals()方法进行进一步比较，如果equals方法返回true，则说明两个对象是相同的，如果equals方法返回false说明两个对象不同。</p><h4 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h4><p>怎么来验证这个问题呢？我们知道HashSet是不允许存储相同的键值的。所以我们可以用HashSet存储两个相同的键值来模拟，看Java虚拟机是如何做判断和识别的，从而验证我们的猜想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先自定义一个类并复写 hashCode 和 equals 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"判断 hashCode"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回1，说明所有新建的对象的哈希值都为1，也就是相同</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"判断 equals"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们用HashSet来存储两个自定义的CustomClass的对象，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        HashSet&lt;CustomClass&gt; hs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        CustomClass cs1 = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        CustomClass cs2 = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        hs.add(cs1);</span><br><span class="line">        hs.add(cs2);</span><br><span class="line">        System.out.println(<span class="string">"----hs添加完毕"</span>);</span><br><span class="line">        System.out.println(<span class="string">"hs:"</span>+hs); <span class="comment">// 打印一下hashSet集合看里面存放了什么</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">判断 hashCode </span><br><span class="line">判断 hashCode</span><br><span class="line">判断 equals</span><br><span class="line">----hs添加完毕</span><br><span class="line">判断 hashCode <span class="comment">// 此处的判断是打印输出语句执行时调用的，与分析本问题无关</span></span><br><span class="line">hs:[com.alankeene.javalib.collections.CustomClass@<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>结果分析：<br>执行 <code>hs.add(cs1)</code> 语句的时候，Java 虚拟机会先判断 cs1 所指向对象的hashCode，因为是第一次往HashSet集合里面存放元素，该元素 hashCode 在集合中肯定是还没存在的，这是个新的元素，所以直接存放进集合中，不用调用 cs1 所指向对象的 equals 方法。<br>当执行 <code>hs.add(cs2)</code> 语句时，这是第二次往集合里存放元素，有新的元素 cs2 要添加进来，那先要调用 cs2 所指向对象的 hashCode 方法看看它的哈希值是不是与集合中已有元素的哈希值重复了，发现重复了，哈希值都是1，那有可能是同一个对象，那就要调用 cs2 所指向对象的 equals 方法做进一步判断，发现 equals 方法返回 true，则判断为是重复的元素，就不往集合里添加了。</p><p>所以最终打印 HashSet 集合的时候可以看到，集合中只存放了一个元素。</p><p>我们再反证一下，把 equals 方法改为返回 false，模拟两个hashCode相同，但是是两个不同的对象的情景。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"判断 hashCode"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回1，说明所有新建的对象的哈希值都为1，也就是相同</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"判断 equals"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果会如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">判断 hashCode </span><br><span class="line">判断 hashCode</span><br><span class="line">判断 equals</span><br><span class="line">----hs添加完毕</span><br><span class="line">判断 hashCode <span class="comment">// 此处的判断是打印输出语句执行时调用的，与分析本问题无关</span></span><br><span class="line">判断 hashCode <span class="comment">// 此处的判断是打印输出语句执行时调用的，与分析本问题无关</span></span><br><span class="line">hs:[com.alankeene.javalib.collections.CustomClass@<span class="number">1</span>, com.alankeene.javalib.collections.CustomClass@<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>会发现，HashSet集合中存放了两个元素了，说明虽然 cs1 和 cs2 的哈希值相同，但是虚拟机判断为不同的元素并存入集合中了。</p><p>由此，验证了我们的猜想。Java 虚拟机是先判断 hashCode，如果 hashCode 相同再通过 equals 去判断两个对象是否相同的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有一种学得快的方法，就是不要一次学太多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java程序运行时，会产生那么多的对象，那 Java 虚拟机是如何判断两个对象是否相同的呢？判断的流程是什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考解答：&lt;/str
      
    
    </summary>
    
      <category term="Java 内功强化系列" scheme="https://www.alankeene.com/categories/Java-%E5%86%85%E5%8A%9F%E5%BC%BA%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Java" scheme="https://www.alankeene.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>你有没有想过，为什么Java中String是不可变的？</title>
    <link href="https://www.alankeene.com/2019/0219/why-string-imutable.html"/>
    <id>https://www.alankeene.com/2019/0219/why-string-imutable.html</id>
    <published>2019-02-19T08:49:34.000Z</published>
    <updated>2019-02-23T14:22:15.480Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一种学得快的方法，就是不要一次学太多。</p></blockquote><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><p>有三点：<br>1）String 在底层是用一个 private final 修饰的字符数组 value 来存储字符串的。final 修饰符保证了 value 这个引用变量是不可变的，private 修饰符则保证了 value 是类私有的，不能通过对象实例去访问和更改 value 数组里存放的字符。</p><blockquote><p>注：有很多地方说 String 不可变是 final 起的作用，其实不严谨。因为即使我不用 final 修改 value ，但初始化完成后我能保证以后都不更改 value 这个引用变量和 value[] 数组里存放的值，它也是从没变化过的。final 只是保证了 value 这个引用变量是不能更改的，但不能保证 value[] 数组里存放的字符是不能更改的。如果把 private 改为 public 修饰，String类的对象是可以通过访问 value 去更改 value[] 数组里存放的字符的，这时 String 就不再是不可变的了。所以不如说 private 起的作用更大一些。后面我们会通过 <code>代码1处</code> 去验证。 </p></blockquote><p>2）String 类并没有对外暴露可以修改 value[] 数组内容的方法，并且 String 类内部对字符串的操作和改变都是通过新建一个 String 对象去完成的，操作完返回的是新的 String 对象，并没有改变原来对象的 value[] 数组。</p><blockquote><p>注：String 类如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，也是不能保证 String 是不可变的。后面我们会通过 <code>代码2处</code> 去验证。</p></blockquote><p>3）String 类是用 final 修饰的，保证了 String 类是不能通过子类继承去破坏或更改它的不可变性的。</p><blockquote><p>注：如果 String 类不是用 final 修饰的，也就是 String 类是可以被子类继承的，那子类就可以改变父类原有的方法或属性。后面我们会通过 <code>代码3处</code> 去验证。 </p></blockquote><p>以上三个条件同时满足，才让 String 类成了不可变类，才让 String 类具有了一旦实例化就不能改变它的内容的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value; <span class="comment">// 用 private final 修饰的字符数组存储字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line">4</span><br><span class="line">4<span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = var1.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = var1.hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(var1, var1.length);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试问题</strong>：String 类是用什么数据结构来存储字符串的？<br>由上面 String 的源码可见，<strong>String 类是用数组的数据结构来存储字符串的</strong>。</p><h4 id="代码1处："><a href="#代码1处：" class="headerlink" title="代码1处："></a>代码1处：</h4><p>我们来看看如果把 private 修饰符换成 public，看看会发生什么？<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 先来模拟一个String类，初始化的时候将 String 转成 value 数组存储</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;  <span class="comment">// 修饰符改成了 public </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = str.toCharArray(); <span class="comment">// 初始化时转为字符数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getValue()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WhyStringImutable str = <span class="keyword">new</span> WhyStringImutable(<span class="string">"abcd"</span>);</span><br><span class="line">        System.out.println(<span class="string">"原str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue()); <span class="comment">// 打印str对象中存放的字符数组</span></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        str.value[<span class="number">1</span>] = <span class="string">'e'</span>; <span class="comment">// 通过对象实例访问value数组并修改其内容</span></span><br><span class="line">        System.out.println(<span class="string">"修改后str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue()); <span class="comment">// 打印str对象中存放的字符数组</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原str中value数组的内容为：</span><br><span class="line">abcd</span><br><span class="line">----------</span><br><span class="line">修改后str中value数组的内容为：</span><br><span class="line">aecd</span><br></pre></td></tr></table></figure></p><p>由此可见，private 修改为 public 后，String 是可以通过对象实例访问并修改所保存的value 数组的，并不能保证 String 的不可变性。</p><h4 id="代码2处："><a href="#代码2处：" class="headerlink" title="代码2处："></a>代码2处：</h4><p>我们如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，看看又会发生什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = str.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">4</span><br><span class="line">4<span class="comment">// 对外暴露可以修改 value 数组的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value[i] = ch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getValue()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WhyStringImutable str = <span class="keyword">new</span> WhyStringImutable(<span class="string">"abcd"</span>);</span><br><span class="line">        System.out.println(<span class="string">"原str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue()); <span class="comment">// 打印str对象中存放的字符数组</span></span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        str.setValue(<span class="number">1</span>,<span class="string">'e'</span>); <span class="comment">// 通过set方法改变指定位置的value数组元素</span></span><br><span class="line">        System.out.println(<span class="string">"修改后str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue()); <span class="comment">// 打印str对象中存放的字符数组</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原str中value数组的内容为：</span><br><span class="line">abcd</span><br><span class="line">----------</span><br><span class="line">修改后str中value数组的内容为：</span><br><span class="line">aecd</span><br></pre></td></tr></table></figure></p><p>由此可见，如果对外暴露了可以更改 value[] 数组内容的方法，也是不能保证 String 的不可变性的。</p><h4 id="代码3处："><a href="#代码3处：" class="headerlink" title="代码3处："></a>代码3处：</h4><p>如果 WhyStringImutable 类去掉 final 修饰，其他的保持不变，又会怎样呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutable</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = str.toCharArray(); <span class="comment">// 初始化时转为字符数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getValue()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 写一个子类继承自WhyStringImutable 并修改原来父类的属性，实现子类自己的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableChild</span> <span class="keyword">extends</span> <span class="title">WhyStringImutable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] value; <span class="comment">// 修改字符数组为 public 修饰，不要 final </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutableChild</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = str.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhyStringImutableChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] getValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WhyStringImutableChild str = <span class="keyword">new</span> WhyStringImutableChild(<span class="string">"abcd"</span>);</span><br><span class="line">        System.out.println(<span class="string">"原str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue());</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        str.value[<span class="number">1</span>] = <span class="string">'s'</span>;</span><br><span class="line">        System.out.println(<span class="string">"修改后str中value数组的内容为："</span>);</span><br><span class="line">        System.out.println(str.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原str中value数组的内容为：</span><br><span class="line">abcd</span><br><span class="line">----------</span><br><span class="line">修改后str中value数组的内容为：</span><br><span class="line">ascd</span><br></pre></td></tr></table></figure></p><p>由此可见，如果 String 类不是用 final 修饰的，是可以通过子类继承来修改它原来的属性的，所以也是不能保证它的不可变性的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上所分析，String 不可变的原因是 JDK 设计者巧妙的设计了如上三点，保证了String 类是个不可变类，让 String 具有了不可变的属性。考验的是工程师构造数据类型，封装数据的功力，而不是简单的用 final 来修饰，背后的设计思想值得我们理解和学习。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>从上面的分析，我们知道，String 确实是个不可变的类，但我们就真的没办法改变 String 对象的值了吗？不是的，<strong>通过反射可以改变 String 对象的值</strong>。</p><p>但是请谨慎那么做，<strong>因为一旦通过反射改变对应的 String 对象的值，后面再创建相同内容的 String 对象时都会是反射改变后的值</strong>，这时候在后面的代码逻辑执行时就会出现让你 “摸不着头脑” 的现象，具有迷惑性，出了奇葩的问题你也很难排除到原因。后面在 <code>代码4处</code> 我们会验证这个问题。</p><p>先来看看如何通过反射改变 String 对象的内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">44String str = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(<span class="string">"反射前 str:"</span>+str);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">char</span>[] aa = (<span class="keyword">char</span>[]) field.get(str);</span><br><span class="line">            aa[<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"反射后 str："</span>+str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反射前 str:<span class="number">123</span></span><br><span class="line">反射后 str：<span class="number">113</span> <span class="comment">// 可见，反射后，str 的值确实改变了</span></span><br></pre></td></tr></table></figure></p><h4 id="代码4处"><a href="#代码4处" class="headerlink" title="代码4处:"></a>代码4处:</h4><p>下面我们来验证<strong>因为一旦通过反射改变对应的 String 对象的值，后面再创建相同内容的 String 对象时都会是反射改变后的值</strong>的问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhyStringImutableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">44String str = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(<span class="string">"反射前 str:"</span>+str);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">char</span>[] aa = (<span class="keyword">char</span>[]) field.get(str);</span><br><span class="line">            aa[<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"反射后 str："</span>+str);</span><br><span class="line">        </span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">      System.out.println(<span class="string">"str2:"</span>+str2); <span class="comment">// 我们来看 str2 会输出什么，会输出 113？</span></span><br><span class="line">        System.out.println(<span class="string">"判断是否是同一对象："</span>+str == str2); <span class="comment">// 判断 str 和 str2 的内存地址值是否相等</span></span><br><span class="line">        System.out.println(<span class="string">"判断内容是否相同："</span>+str.equals(str2)); <span class="comment">// 判断 str 和 str2 的内容是否相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">反射前 str:<span class="number">123</span></span><br><span class="line">反射后 str：<span class="number">113</span></span><br><span class="line">str2:<span class="number">113</span> <span class="comment">// 竟然不是123？？而是输出113，说明 str2 也是反射修改后的值。</span></span><br><span class="line">判断是否是同一对象：<span class="keyword">false</span> <span class="comment">// 输出 false，说明在内存中确实创建了两个不同的对象</span></span><br><span class="line">判断内容是否相同：<span class="keyword">true</span>   <span class="comment">// 输出true，说明依然判断为两个对象内容是相等的</span></span><br></pre></td></tr></table></figure></p><p>由上面的输出结果，我们可知，反射后再新建相同内容的字符串对象时会是反射修改后的值，这就造成了很大迷惑性，在实际开发中要谨慎这么做。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有一种学得快的方法，就是不要一次学太多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;解答：&quot;&gt;&lt;a href=&quot;#解答：&quot; class=&quot;headerlink&quot; title=&quot;解答：&quot;&gt;&lt;/a&gt;解答：&lt;/h4&gt;&lt;p&gt;有三点：&lt;br&gt;1）S
      
    
    </summary>
    
      <category term="Java 内功强化系列" scheme="https://www.alankeene.com/categories/Java-%E5%86%85%E5%8A%9F%E5%BC%BA%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="String" scheme="https://www.alankeene.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio mac 快捷键</title>
    <link href="https://www.alankeene.com/2019/0106/AndroidStudio-mac-shortcuts.html"/>
    <id>https://www.alankeene.com/2019/0106/AndroidStudio-mac-shortcuts.html</id>
    <published>2019-01-06T04:38:27.000Z</published>
    <updated>2019-01-07T05:45:48.522Z</updated>
    
    <content type="html"><![CDATA[<p><center>Android Studio 常用 mac 快捷键</center></p><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td style="text-align:center">⌃+⇧+Space</td><td style="text-align:center">初始化对象时，输入 new 后，按此快捷键快速输入类名</td></tr><tr><td style="text-align:center">⌥⌘B</td><td style="text-align:center">快速导航到抽象方法的实现类</td></tr><tr><td style="text-align:center">⌥⌘V</td><td style="text-align:center">mEditorPane.setBorder(BorderFatory.createEmptyBorder(5,5,5,5));<br>选中<code>BorderFatory.createEmptyBorder(5,5,5,5)</code>, 然后按此快捷键，自动提取出如下代码：<br>Border emptyBorder = BorderFactory.createEmptyBorder(5,5,5,5);<br>myEditorPane.setBorder(emptyBorder);</td></tr><tr><td style="text-align:center">⌃Space</td><td style="text-align:center">新建一个变量时，按此快捷键，编辑器会推荐一个变量名</td></tr><tr><td style="text-align:center">⌘P</td><td style="text-align:center">如果光标位于方法调用的括号之间，则按⌘P将显示有效参数列表。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      持续收集在 Android Studio 上开发常用的 mac 快捷键，提高代码编写效率，记录在这，以免忘了的时候经常需要去搜索，同时方便需要的人。
    
    </summary>
    
      <category term="记录" scheme="https://www.alankeene.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="mac快捷键" scheme="https://www.alankeene.com/tags/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Pre-built binaries not found for fsevents@1.1.3 and node@11.6.0</title>
    <link href="https://www.alankeene.com/2019/0102/fsevents-didnot-soppurt-node11.html"/>
    <id>https://www.alankeene.com/2019/0102/fsevents-didnot-soppurt-node11.html</id>
    <published>2019-01-02T14:40:08.000Z</published>
    <updated>2019-02-19T17:29:54.148Z</updated>
    
    <content type="html"><![CDATA[<p>用 <code>npm install</code> 安装 fsevent 插件， 发现如下图提示：</p><p>   <img src="/images/fsevets-download-fail.png" alt="" title="fsevets-download-fail"></p><p>搜索了一圈发现原来是 fsevents 目前还没支持 node v11+，笔者用的是 <code>brew install node</code> 下载的 node，默认下载的是最新的版本，用 <code>node -v</code> 命令查看 node 的版本呢，笔者的 node 是 v11.6.0。<a id="more"></a></p><p>详情请参阅：</p><ul><li><p><a href="https://github.com/strongloop/fsevents/issues/244" target="_blank" rel="noopener">Build binary for Node 11</a></p></li><li><p><a href="https://github.com/strongloop/fsevents/issues/170" target="_blank" rel="noopener">No binary found on s3 for Node v8.0</a></p></li></ul><p>知道了原因那在 mac 下如何快速降低 node 的版本呢？</p><p>看这：</p><ul><li><a href="https://apple.stackexchange.com/a/207883" target="_blank" rel="noopener">https://apple.stackexchange.com/a/207883</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 &lt;code&gt;npm install&lt;/code&gt; 安装 fsevent 插件， 发现如下图提示：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;/images/fsevets-download-fail.png&quot; alt=&quot;&quot; title=&quot;fsevets-download-fail&quot;&gt;&lt;/p&gt;
&lt;p&gt;搜索了一圈发现原来是 fsevents 目前还没支持 node v11+，笔者用的是 &lt;code&gt;brew install node&lt;/code&gt; 下载的 node，默认下载的是最新的版本，用 &lt;code&gt;node -v&lt;/code&gt; 命令查看 node 的版本呢，笔者的 node 是 v11.6.0。
    
    </summary>
    
      <category term="日常解决问题集锦" scheme="https://www.alankeene.com/categories/%E6%97%A5%E5%B8%B8%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    
    
      <category term="fsevents" scheme="https://www.alankeene.com/tags/fsevents/"/>
    
      <category term="node" scheme="https://www.alankeene.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>最安全的hexo多台电脑同步博客解决方案--非新建分支</title>
    <link href="https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html"/>
    <id>https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html</id>
    <published>2019-01-02T07:42:05.000Z</published>
    <updated>2019-02-19T17:27:21.665Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常有这样一个需求场景：需要在多台电脑间完成 Hexo 博客的撰写和发布，这就涉及到如何多台电脑同步博客的问题。</p><p>我最近也遇到了这个问题，网上看了很多方案，都是通过新建一个分支来存放博客源文件。但这样一来，我很多第三方插件配置的密钥信息不就暴露了吗？会不会存在数据安全隐患？有没有什么办法不暴露这些信息？对了，用一个私有仓库来存放博客源文件不就结了嘛。虽然 Github 的私有仓库是收费的，但是我的博客是同时部署在 Github 和 Coding 的，而 Coding 是可以新建私有仓库的。Nice，完美解决。</p><p>当我准备写遍博客来分享（xuan yao）这个解决方案时，最后还是荣幸的发现一遍文章已经分享了这个方案，只是在搜索引擎中不太好搜出来。本着“不重复造轮子的原则”，笔者就不重写了，而且他已经写的很好了。但是有几个问题需要特别注意一下：</p><ol><li><p>该文中删除主题的 .git 配置，如果你有多个主题文件夹的话，需要都删除(如 NexT 主题)。然后删除的命令那位笔者不小心写错了，应该是：<br> <code>rm -rf ./themes/next/.git/</code></p><p> 用这条命令来删除你对应主题文件夹里的.git 文件夹，注意 .git 是一个隐藏文件夹。</p></li><li><p><code>.gitignore</code> 文件夹在 Hexo 的根目录下可能已经存在了，可以打开和该文中的忽略事项比对一下，如果一样，接着 <code>git init</code> 初始化 git 仓库就好；如果没有该 <code>.gitignore</code> 文件夹就新建一个添加相应忽略事项再 <code>git init</code> 初始化。</p></li><li><p><strong>这点需要特别注意，否则可能导致迁移失败：</strong><br> 虽然我们第 1 步中删除了主题的 .git 配置，第 2 步中Hexo项目根目录的 <code>.gitignore</code> 文件也并没有忽略掉 <code>theme</code> 这个文件夹。<strong>但是！！</strong> NexT 主题的文件夹原来是用 git 来管理的，里面还有一个 <code>.gitignore</code> 文件，把 <code>themes/next/source/lib</code> 目录下的很多文件给忽略掉了。<br> 这就导致了你上传到私有仓库时，你以为你把 <code>themes</code>  文件下的所有内容都上传到仓库了，但其实 “偷偷”的把 <code>themes/next/source/lib</code> 目录下的很多必要的文件也忽略掉了，并没有上传。然后在新电脑上拉下来的时候，<code>hexo g</code>、<code>hexo s</code> 一预览，你会奇怪的发现：<strong>所有的 FontAwesome 相关的图标都不见了，其他的功能一切正常。</strong></p><p><strong>正确的做法是</strong>：在新机器上把私有仓库上的博客源文件 clone 下来后，因为还缺点原来的文件，所以应该去原来机器上 <code>themes/next/source/lib</code> 目录下，把整个 lib 目录下的文件全部复制粘贴到新机器对应的 <code>themes/next/source/lib</code> 目录下，这样就能正常生成站点文件了。</p><blockquote><p>注意：同理，如果你的 <code>themes</code> 目录下有多个主题配置文件的话，可以查看是否有 <code>.gitignore</code> 文件，用 git    上传私有仓库时是否也忽略了一些必要资源，如果有再新电脑上对应复制过来就 OK 了。</p></blockquote><p>   关于这个问题的详情，可查看：<a href="https://github.com/theme-next/hexo-theme-next/issues/564#issuecomment-451385682" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next/issues/564#issuecomment-451385682</a> </p></li><li><p>在新电脑上 <code>npm install</code> 下载 hexo 所需的环境的时候，要切到 hexo 的根目录下，再执行 <code>npm install</code>。</p></li><li><p>当你在新电脑用 <code>npm install</code> 下载依赖的第三插件时，由于 node 的版本、众多第三方插件、跨平台等原因，可能有的插件会存在兼容性问题，导致下载不下来，笔者想迁移到 Mac 上就遇到兼容性问题了，<code>fsevent</code> 插件目前不支持 node v11+ 版本，而刚配置新电脑的 node 环境时，默认安装的是最新版的 node，需要降低 node 的版本才能下载成功。 </p><ul><li><a href="https://www.alankeene.com/2019/0102/fsevents-didnot-soppurt-node11.html">node 11 无法安装 fsevents 插件的解决方案</a></li></ul><p>至于如何降低 node 的版本，其实你不用删除，有一个叫 <code>nvm</code> （Node Version Manager）的工具，专门用来管理多个版本的 node 环境的，你可以下载多个版本的 node 存在你的机器中，用 <code>nvm</code> 的命令行就可以实现不同版本 node 环境的随意切换，非常方便。</p><ul><li><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">这是 nvm 的 github 地址</a></li></ul></li><li><p>好，当你在新的电脑上写完博客，本地预览也没问题，准备用 <code>hexo d</code> 部署到 Github 和 Coding 上前，别忘了把新电脑的 SSH 公钥配置到 Github 和 Coding 上。</p><p>然后用 <code>hexo d</code>部署时，由于在新机器上，SSH 密钥和之前的不一样，第一次尝试连接 Github 主机时会提示：<br><code>The authenticity of host github.com can&#39;t be established.</code><br><code>Are you sure you want continue connecting?</code></p><p>输入 <code>yes</code> 就好，同理 coding 仓库也会提示，同样输入<code>yes</code>。至此，新电脑上写完的博客也成功同步更新到 Github 和 Coding 的仓库上了。</p><p>更新完博客后，记得    用 <code>git push</code> 将新电脑上改动的博客源文件也 push 到私有仓库中，实现博客源文件的同步更新。</p></li><li><p>当你在另一台电脑上准备开始写博客前，记得把远程私有仓库的最新博客源文件拉到本地，<strong>但记得不要用 <code>git pull</code> 的方式</strong>，用如下两条命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all    <span class="comment">#将远程git仓库上最新的内容拉取到本地,将本地库所关联的远程库更新至最新</span></span><br><span class="line">git reset --hard origin/<span class="keyword">master</span>   <span class="title">#强制将本地库的内容指向最新远程仓库的master</span>分支</span><br><span class="line">     </span><br></pre></td></tr></table></figure></li></ol><p>最后附上该篇博客的地址：</p><ul><li><a href="https://ricky.moe/2017/01/13/hexo-perfect-synchronize/" target="_blank" rel="noopener">最完美的Hexo多电脑同步方法</a></li></ul><p>从此，你就可以在多台电脑间愉快地写博客啦～</p><p>本迁移解决方案博主亲测有效，请放心迁移，迁移过程中如果还遇到什么问题欢迎和我交流。</p><hr><p><code>2019.1.8 最新更新：</code> <strong>好消息</strong>是：Github 从 2019.1.8 日起可以免费使用私有仓库了，那大家也可以选择把博客源文件传到 Github 私有仓库上，维护起来更加方便了。</p>]]></content>
    
    <summary type="html">
    
      目前网上大部分 hexo 多电脑同步博客方案都是新建一个开源分支去存放博客源文件，但是你会发现，这样做的话很多第三插件配置的appid、app_key等密钥信息也暴露在了公开的仓库里，存在一定的数据安全隐患。本文将介绍一种新建私有仓库来管理博客源文件的方案来解决上述问题。
    
    </summary>
    
      <category term="经验" scheme="https://www.alankeene.com/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="https://www.alankeene.com/tags/hexo/"/>
    
      <category term="多电脑同步博客" scheme="https://www.alankeene.com/tags/%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>dryrun 在 windows 上的使用教程</title>
    <link href="https://www.alankeene.com/2018/0618/use-dryrun-in-windows.html"/>
    <id>https://www.alankeene.com/2018/0618/use-dryrun-in-windows.html</id>
    <published>2018-06-18T05:30:51.000Z</published>
    <updated>2019-01-02T07:23:26.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>有些坑别人踩过了，希望你不用再踩一遍。 </p></blockquote><center><img src="https://github.com/cesarferreira/dryrun/raw/master/extras/gift.gif" alt=""></center> <p>dryrun 的作者使用的是 Mac，本文主要介绍 dryrun 在 windows 上配置使用的方法以及容易导致配置不成功的关键点，为想在 windows 上也能使用 dryrun 的 Android 开发者提供参考。<a id="more"></a></p><h2 id="dryrun-是个什么工具？能帮我们提高什么效率？"><a href="#dryrun-是个什么工具？能帮我们提高什么效率？" class="headerlink" title="dryrun 是个什么工具？能帮我们提高什么效率？"></a>dryrun 是个什么工具？能帮我们提高什么效率？</h2><p>简单来说，dryrun 是帮助 Android 开发者快速预览 Github 上开源 Android 项目在真机上的实际运行效果的工具。</p><p>使用 dryrun 工具，可以避免下载解压、导入项目、编译、运行在手机上一系列的动作，简单一行命令 <code>dryrun + Github 上的项目地址</code> 就可以把 Github 上的 Android 项目安装到真机上预览实际的效果了。</p><p><a href="https://github.com/cesarferreira/dryrun" target="_blank" rel="noopener">dryrun 的 Github 地址</a></p><p>windows 上安装和配置 dryrun 所需环境请参考：</p><p><a href="https://www.jianshu.com/p/9cc10563ab41" target="_blank" rel="noopener">Windows 环境下的 dryrun 使用教程</a></p><p>但笔者按照以上教程并没有配置成功，有几个坑点上文中尚未提及，需要另外注意一下：</p><ol><li><p><strong>关于下载哪个版本的 Ruby 和 DevKit</strong></p><p> 据网上说，Ruby 最新版已经内置了 DevKit，但笔者尝试了最新版的 Ruby 的安装，发现安装过程及配置稍微复杂，不适合完全不懂 Ruby 的小白，而我们作为想使用 <code>dryrun 工具</code> 的Android 开发者，只是需要 ruby 的一个环境，并不需要用到 Ruby 的最新特性，所以笔者建议如果你不太了解最新版的 Ruby 如何去安装和配置的话，像笔者一样下载：</p><p> <a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">2.3.3 版本的 Ruby</a> 和 <a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">DevKit For use with Ruby 2.0 to 2.3 </a></p><p> 然后按照教程以及容易忽略的坑点去安装和配置即可。</p></li><li><p><strong>需要配置 JAVA_HOME 环境变量。</strong></p><p> 由于新版的 Android Studio 已经帮我们内置了 JDK ,我们 Android 开发者不需要再像以前那样需要单独的配置 JAVA 环境，所以<strong>容易忽略了 dryrun 安装时需要的 JAVA 环境</strong>。<br> 如果你的机器尚未配置 JAVA 环境变量，按照教程执行到 <code>gem install dryrun --source http://rubygems.org</code> 安装 <code>dryrun</code> 的步骤时，会安装不成功，仔细看日志会发现是缺少了 JAVA 环境变量。配置好 JAVA_HOME 环境变量再执行安装命令就能安装成功了。<br> 至于如何配置 JAVA 环境变量，想必想使用 dryrun 的人应该都会了，如果你恰巧不会或忘了，网上也有很多配置教程可以找到，不用担心。</p></li><li><p><strong>需要配置 ANDROID_HOME 环境变量。</strong></p><p> 安装好了 dryrun 后，执行 <code>dryrun + Github 项目地址</code> 去在真机上下载并预览项目时，如果没有配置 Android_HOME 环境变量，会发现项目下载不下来。配置一下 ANDROID_HOME 环境变量即可，也就是配置一下 SDK 的路径。</p></li></ol><p>好了，在 windows 上使用 dryrun 的方法以及容易忽略的几个坑点已经讲解完毕了，希望你们都能愉快的一次性就安装成功，不用踩坑，然后就是愉快的逛 Github 去学习啦~ </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;有些坑别人踩过了，希望你不用再踩一遍。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img src=&quot;https://github.com/cesarferreira/dryrun/raw/master/extras/gift.gif&quot; alt=&quot;&quot;&gt;&lt;/center&gt; 

&lt;p&gt;dryrun 的作者使用的是 Mac，本文主要介绍 dryrun 在 windows 上配置使用的方法以及容易导致配置不成功的关键点，为想在 windows 上也能使用 dryrun 的 Android 开发者提供参考。
    
    </summary>
    
      <category term="提高开发效率的工具" scheme="https://www.alankeene.com/categories/%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="dryrun 使用" scheme="https://www.alankeene.com/tags/dryrun-%E4%BD%BF%E7%94%A8/"/>
    
      <category term="dryrun windows 使用" scheme="https://www.alankeene.com/tags/dryrun-windows-%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android Things 官方开发文档(中文版)</title>
    <link href="https://www.alankeene.com/2018/0421/Android-Things.html"/>
    <id>https://www.alankeene.com/2018/0421/Android-Things.html</id>
    <published>2018-04-21T13:44:41.000Z</published>
    <updated>2019-01-02T07:23:26.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>有的人是因为看到才会相信，有的人是因为相信才会看到。</p></blockquote><p> <img src="/images/Android-Things.jpg" alt="" title="Android Things"></p><p>这是笔者最喜欢的一张图片了，作为一个沉稳严谨的工程师，每当笔者看到这个图片时，都不免心潮澎湃一下。</p><p>而今，全世界都在憧憬万物互联，在谈论IOT，未来会是什么样？什么时候来？</p><p>也许在互联网的世界里，未来很快就有可能到来，也许来了也会是和我们想象的形态不一样。但有一点我们可以坚信，物联网是趋势，而且肯定会来。</p><p>如果你对 Android Things 已经有一定了解，可以直接参阅笔者翻译的一本电子书：<a href="https://peter-bug.gitbooks.io/android-things/content/" target="_blank" rel="noopener">Android Things 官方开发文档(中文版)</a>，跳过下面介绍的阅读，或者直接跳到第二部分看麻省理工流体界面实验室研发出来的 Reality Editor.<a id="more"></a></p><h2 id="Android-Things-简介"><a href="#Android-Things-简介" class="headerlink" title="Android Things 简介"></a>Android Things 简介</h2><p>Android Things 正是 Google 布局物联网领域的一个操作系统，蕴含着 Google 在物联网领域的野心。</p><p>正如官方介绍的那样：</p><blockquote><p>If you can build an app, you can build a device.</p></blockquote><p>Android Things 的前身是 Goolge 2015 年发布的物联网平台 Birllo，除了继承 Brillo 的功能外，还加入了 Android Studio、 Android SDK、 Google Play 服务以及 Google 云平台等 Android 开发者熟悉的工具和服务。任何 Android 开发者现在都可以利用 Android API 和 Google 服务轻松构建智能联网设备。</p><p>连接智能手机有 Android 操作系统，连接智能穿戴设备有 Android Wear，连接平板有 Android Tablets，连接智能电视有 Android TV，连接汽车有 Android AUTO，PC端的还有 Chrome OS。很显然，Google 是想基于 Android 连接一切，打通你生活中的所有需求。</p><p>自 2016.12 发布第一个开发者预览版以来，目前 Android Things 依然在孵化中，截至笔者写稿的此时，孵化到了 Developer Preview 8，开发者预览版 8 。</p><p>Android Things 会不会在物联网领域发展起来时大展宏图不能确定，但看目前 Android Things 的演进，Google 还是对其抱有梦想。</p><p>而作为 Android 开发者，这是值得让我们兴奋的事，Android 充满了更多的可能。</p><p>笔者非常看好 Android 和 Android Things 的未来，也是从 Android Things 预览版发布开始就一直关注 Android Things 的动态。笔者认为只要我们的计算平台还是手机，Android 的前景就是光明的，互联网的变革之后，现在我们的人在哪？就在手机里。人在哪服务就会在哪，未来会有更多先进的技术、服务集成到手机里推到“人”这一端，比如现在研究出来的很多 AI 技术在努力的寻找落地应用场景，嗷嗷待哺。而手机中，Android 的全球市场份额占到了 85.9%，并且每年都还在增长，Android 操作系统在体验上也优化的越来越好。</p><p>笔者在 2017.5 翻译了 Android Things 的官方开发文档，并做成了一本 Gitbook 电子书，如果你想要更加详细的了解 Android Things 或者是 Android Things 的开发者，可以获得参考，免费的哦~</p><p>电子书地址：<a href="https://peter-bug.gitbooks.io/android-things/content/" target="_blank" rel="noopener">Android Things 官方开发文档(中文版)</a></p><h2 id="麻省理工的-Reality-Editor"><a href="#麻省理工的-Reality-Editor" class="headerlink" title="麻省理工的 Reality Editor"></a>麻省理工的 Reality Editor</h2><p>下面分享一下麻省理工流体界面实验室花了3年时间研发出来的一款增强现实应用，叫 Reality Editor，实现了设备功能的连接。</p><blockquote><p>Reality Editor的概念是通过手机摄像头取景，以增强现实的方式将用户周围的智能设备连接在一起，通过手指滑动即可将一系列相关的设备联通。</p></blockquote><p><img src="http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz/2g9WOaAoNdoT49dBoibLibEdmia47sVlVSJdPo7nfEQlLaicRs37ic0AwxJrxsR9tKXdK7jz9t8kDq2qqicia0lw0RNDA/0%3Fwx_fmt%3Dgif" alt=""></p><p><img src="http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz/2g9WOaAoNdoT49dBoibLibEdmia47sVlVSJpaCM42zLyyicoJSsAgPPL8icVCZJIze1pwLchVHeTAhXmG03HB3S3h5A/0%3Fwx_fmt%3Dgif" alt=""></p><p><img src="http://www.10tiao.com/img.do?url=http%3A//mmbiz.qpic.cn/mmbiz/2g9WOaAoNdoT49dBoibLibEdmia47sVlVSJgOFSpI89e1TJ961ApS482ECdnz0CUKauWkuIpvU5PUGIL4iaFD0NibhQ/0%3Fwx_fmt%3Dgif" alt=""></p><hr><p>下面就是激动人心的视频啦：(前方高能，非战斗人员迅速撤离)</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=h0178alfo09&tiny=0&auto=0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;有的人是因为看到才会相信，有的人是因为相信才会看到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;/images/Android-Things.jpg&quot; alt=&quot;&quot; title=&quot;Android Things&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是笔者最喜欢的一张图片了，作为一个沉稳严谨的工程师，每当笔者看到这个图片时，都不免心潮澎湃一下。&lt;/p&gt;
&lt;p&gt;而今，全世界都在憧憬万物互联，在谈论IOT，未来会是什么样？什么时候来？&lt;/p&gt;
&lt;p&gt;也许在互联网的世界里，未来很快就有可能到来，也许来了也会是和我们想象的形态不一样。但有一点我们可以坚信，物联网是趋势，而且肯定会来。&lt;/p&gt;
&lt;p&gt;如果你对 Android Things 已经有一定了解，可以直接参阅笔者翻译的一本电子书：&lt;a href=&quot;https://peter-bug.gitbooks.io/android-things/content/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Things 官方开发文档(中文版)&lt;/a&gt;，跳过下面介绍的阅读，或者直接跳到第二部分看麻省理工流体界面实验室研发出来的 Reality Editor.
    
    </summary>
    
      <category term="Android Things" scheme="https://www.alankeene.com/categories/Android-Things/"/>
    
    
      <category term="Android Things" scheme="https://www.alankeene.com/tags/Android-Things/"/>
    
      <category term="IOT" scheme="https://www.alankeene.com/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的设计原则--一文带你理解清楚</title>
    <link href="https://www.alankeene.com/2018/0418/principles-of-OOD.html"/>
    <id>https://www.alankeene.com/2018/0418/principles-of-OOD.html</id>
    <published>2018-04-18T05:20:42.000Z</published>
    <updated>2019-01-02T07:23:26.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 </p></blockquote><p>本文主要分享对面向对象程序设计的设计原则的理解，以供想了解 OOD 设计原则的人士作参考。</p><p>主要内容包括：对设计原则和设计模式概念的理解，对 OOD 设计原则的理解，对继承和多态的理解。<a id="more"></a></p><h2 id="什么是设计原则？什么是设计模式"><a href="#什么是设计原则？什么是设计模式" class="headerlink" title="什么是设计原则？什么是设计模式?"></a>什么是设计原则？什么是设计模式?</h2><h3 id="什么是设计原则？怎么理解设计原则？"><a href="#什么是设计原则？怎么理解设计原则？" class="headerlink" title="什么是设计原则？怎么理解设计原则？"></a>什么是设计原则？怎么理解设计原则？</h3><p>如果要做个比喻，设计原则就像我们的宪法，而设计模式就像我们具体的基于宪法的各部法律，如：劳动法、海商法等等。</p><p>也就是说，设计原则是我们设计面向对象程序的纲领性指导，各种设计模式也是基于设计原则而设计的。</p><h3 id="什么是设计模式？怎么理解设计模式？"><a href="#什么是设计模式？怎么理解设计模式？" class="headerlink" title="什么是设计模式？怎么理解设计模式？"></a>什么是设计模式？怎么理解设计模式？</h3><p>设计模式是帮助开发人员在设计应用程序或系统时，解决常见问题的正式最佳实践。</p><p>也就是说，设计模式是无数前辈工程师们在日常编码过程中总结出来的一些经验，它告诉你在某种具体的需求场景下该用什么样的方式编写代码才会最好，写出来的代码扩展性和可维护性才会更强，代码更高级，解决的是具体的需求。 Java 的设计模式共有23种，分为3大类，有部分在实际工作中也不常用。</p><p>但是，理论上设计模式可以有无数种，而并非23种，因为如上所述，设计模式解决的是具体某种需求场景的设计经验，而随着时间的推移和时代的变化，需求可以发生很多变化，而对应的设计模式理论上也可以被创造出来。</p><p>而设计原则就那么几条，相对固定，只要按这几条原则去设计和组织你的代码，解决你的需求，理论上就是在创造一种新的设计模式，如果这种编码方式不属于那23条里面而且也没有人使用过的话。</p><p>所以说，<strong>设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。</strong></p><h2 id="我们应该怎样学习和掌握设计原则？"><a href="#我们应该怎样学习和掌握设计原则？" class="headerlink" title="我们应该怎样学习和掌握设计原则？"></a>我们应该怎样学习和掌握设计原则？</h2><p>在我们的日常工作中，初级工程师，甚至是高级工程师，在实际的编码工作中并不会真真切切的用到设计原则，用的更多的是设计模式去解决工作中具体的需求。</p><p>也就是说，实际工作要求我们掌握的其实更多是<strong>设计模式</strong>，而并非<strong>设计原则</strong>。所以掌握设计模式是我们的重点，是向优秀工程师迈进的必备技能。</p><h3 id="我们为什么还要学习和掌握设计原则呢？"><a href="#我们为什么还要学习和掌握设计原则呢？" class="headerlink" title="我们为什么还要学习和掌握设计原则呢？"></a>我们为什么还要学习和掌握设计原则呢？</h3><p>就像如果你不是立法机构的话，你似乎并不需要了解和掌握宪法，在日常生活中你碰到劳动相关问题了你就去了解劳动法，碰到海上贸易纠纷问题了你就去了解海商法即可。但是，这些具体的法律都是基于宪法的，如果你不了解宪法的话，你就不知道它们为什么是这样来设计的，虽然并不影响你用来解决实际问题，但你却不知道为什么。</p><p>同理，学习和掌握设计原则的目的也是如此。而且更重要的是，其实设计原则很容易理解和掌握，因为基本原则也就 5 条。当你理解了设计原则，再回来理解设计模式时，就会理解他为什么要这样写代码？为什么这样写代码是更加好的，扩展性和可维护性是更强的？</p><p>换句话说，在理解了设计原则的基础上去掌握设计模式，就会理解的更加透彻，而不仅仅是只会使用设计模式而不知道为什么要这样设计。也能以不变应万变，不变的是设计原则，变得是设计模式。</p><p>而且，理解了设计原则再去学习设计模式，会相对容易记住和掌握，并大概率是以后都不会容易忘记。否则很有可能是这种情况：在工作中遇到问题去学习一下设计模式，看懂了用来解决了实际的需求，但过几天就忘了，设计模式相关的知识学了又忘，忘了又学，反反复复，好像总是掌握不了设计模式。笔者就经历过这样的一个过程，因为设计模式虽然只有23种，但涉及的相关知识点其实很多，要想想那可是多少人多少年来才总结出来的那么点经验啊，岂能是初学者一下就能完全掌握和记住的，单纯23种设计模式的写法和对应的使用场景都不容易理解和记忆。</p><p>但如果你理解了设计原则，情况就会变得好些，在学习具体的某种设计模式的时候，你就会知道它用了什么设计原则，代码为什么是这样写的？这么写的好处是什么?</p><h2 id="SOLID-设计原则"><a href="#SOLID-设计原则" class="headerlink" title="SOLID 设计原则"></a>SOLID 设计原则</h2><p>好，了解了为什么要学习设计原则，接下来就要学习和理解设计原则了。</p><p>首先，面向对象的设计原则一共有几条？表述不一，江湖上有三种表述方法：有的说面向对象的七大原则，有的说六大原则，有的说五大原则。不过这只是不同的理解方式，对学习来说并不影响。</p><p>不过笔者参阅了维基百科 <a href="https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">SOLID (面向对象设计)</a>) 的解释，笔者的理解方式是：面向对象程序设计有五条基本原则，其他两条原则也学习了解，但不在基本原则的表述里。</p><p>而这五大基本原则，首字母简写就是 “SOLID” , 英文 “solid” 是固体的意思，固体的形态也意味着相对固定不变，很符合设计原则的思想，所以为了方便记忆，笔者也将面向对象的 SOLID 原则称为 “固体原则”。</p><h3 id="S-Single-reponsibility-principle-单一职责原则"><a href="#S-Single-reponsibility-principle-单一职责原则" class="headerlink" title="S (Single reponsibility principle) - 单一职责原则"></a>S (Single reponsibility principle) - 单一职责原则</h3><p>概念：认为 “对象应该仅有一种单一功能”。</p><p>换句话说，你在设计一个类的时候，应该有职责单一的特性，就是将一组相关性很高的函数、数据封装到一个类中。</p><p>潜台词是：尽量拆分到最小单位，解决复用和组合的问题。</p><h3 id="O-Open-closed-principle-开闭原则"><a href="#O-Open-closed-principle-开闭原则" class="headerlink" title="O (Open/closed principle) - 开闭原则"></a>O (Open/closed principle) - 开闭原则</h3><p>概念： 认为 “软件体应该是对于扩展是开放的，但对于修改是封闭” 的。</p><p>什么意思呢？</p><p>换句话说，一个类对于扩展是开放的，但对于修改是封闭的。如：我们升级、维护 APP 或系统需要增加新的功能时，应该尽量通过扩展去实现新的功能，而不是通过修改已有的代码来实现，以免带来一些难以发现的Bug。</p><p>试想一下，如果你要给一个系统增加新的功能，你通过修改源代码来实现，为了让新增的功能模块能正常运行，改了很多源代码，这时集成到系统中一测试，发现整个系统无法正常运行了，而且这个系统是已经在线上运行为用户提供服务的，你怎么办？你还要百分之百的还原原来的源码吗？</p><p>所以，开闭原则能帮我们避免一些修改风险。</p><p>潜台词: 控制需求变动时的风险，缩小维护成本</p><h3 id="L-Liskov-substitution-principle-里氏替换原则"><a href="#L-Liskov-substitution-principle-里氏替换原则" class="headerlink" title="L (Liskov substitution principle) - 里氏替换原则"></a>L (Liskov substitution principle) - 里氏替换原则</h3><p>概念： 认为 “程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的” 。</p><p>本质上说，就是告诉我们要好好利用 <strong>继承</strong> 和 <strong>多态</strong>。</p><p>从技术上简单的描述，就是以父类的形式声明的变量(或形参)，赋值为任何继承于这个父类的子类后不影响程序的执行。</p><p>潜台词：尽量使用精准的抽象类或接口。</p><p>代码举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">        child.onDraw(); <span class="comment">//调用抽象类View的抽象方法--onDraw方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类View</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测量视图的大小</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承抽象类View的子View,复写抽象方法onDraw()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//绘制一个按钮</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//绘制文本</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实例代码解释:</p><p>Window 类中的 show 函数需要传入 View, 并且调用 View 对象的 <code>onDraw()</code> 方法，而每个继承于 View 的子类对象都要实现 <code>onDraw()</code> 方法，不存在继承于 View 却没实现 <code>onDraw()</code> 方法的子类对象(abstract方法必须实现)。我们在抽象类 View 的设计时就是运用了里氏替换原则。</p><p>而当我们在调用窗口类 Window 的 <code>show()</code> 方法时，可以传入抽象类 View 的任何实现子类 <code>Button类</code> 或 <code>TextView类</code>，均不会影响程序的正常执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show(<span class="keyword">new</span> Button());</span><br><span class="line">或</span><br><span class="line">show(<span class="keyword">new</span> TextView());</span><br></pre></td></tr></table></figure></p><p>这样，你就可以实现在窗口上绘制任意一个的视图的需求了，一旦有增加新的视图的需求时，你只需要继承抽象类view并实现它的抽象方法 <code>onDraw()</code> 即可，作为参数传入 Window 类的 <code>show()</code> 方法中，Window 类就可以帮你把它绘制出来。</p><p>比如，你现在学习学累了，想在窗口上画个饼充饥，就可以实现一个画饼的子类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cake</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//画个饼充饥</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//功能实现完了，然后作为参数传入 Windows 类的 show() 方法</span></span><br><span class="line">show(<span class="keyword">new</span> Cake());</span><br></pre></td></tr></table></figure></p><p>其实，这种设计思想无处不在，你每天都能遇到，Android 中的 View 的绘制就是使用了这种思想。</p><h4 id="如何理解多态和继承？"><a href="#如何理解多态和继承？" class="headerlink" title="如何理解多态和继承？"></a>如何理解多态和继承？</h4><p>多态的概念：同一个行为具有多个不同的表现形式或形态的能力。</p><p>举例：Window类的 <code>show()</code> 方法都是调用 View.onDraw() 的功能，但 TextView 和 Button 各自的 <code>onDraw()</code> 方法的表现形式不一样。</p><p>多态的好处：可以使程序有良好的扩展性，并可以对所有类的对象进行通用处理。用通俗的话说就是：一键修改，到处应用。</p><p><strong>举例</strong>：实现抽象类 View 的抽象方法 <code>onDraw()</code> ,TextView 和 Button 实现了不同的绘制行为，即多态，扩展成不同的需求或功能。而与此同时，如果修改了抽象父类 View 的绘制行为，所有调用 View 的 Window 对象相应的 <code>show()</code> 行为也统一进行了更改。</p><p>笔者想到我们的一句俚语，用来帮助理解继承和多态再合适不过了：<strong>“一母生九子，连母十个样”</strong>。</p><p>“母”即父类，“九子”则继承自“母”这个父类，“连母十个样”：说明子类和父类都可以有不同的行为，也就是多态。</p><p>注意：<strong>Java 中类只能单继承，但可以多实现</strong>。用俚语帮助理解就是：每个人只能有一个爸爸(单继承)，但可以有多个兄弟(多实现)。</p><h3 id="I-Interface-segregation-principle-接口隔离原则"><a href="#I-Interface-segregation-principle-接口隔离原则" class="headerlink" title="I(Interface segregation principle) - 接口隔离原则"></a>I(Interface segregation principle) - 接口隔离原则</h3><p>概念：认为 “多个特定客户端接口要好于一个宽泛用途的接口”。</p><p>也就是说，类之间的依赖关系应该建立在最小的接口上。其原则是将非常庞大的、臃肿的接口拆分成更小的更具体的接口。</p><p>潜台词： 尽量拆分成功能更具体的接口。</p><h3 id="D-Dependency-inversion-principle-依赖反转原则"><a href="#D-Dependency-inversion-principle-依赖反转原则" class="headerlink" title="D(Dependency inversion principle) - 依赖反转原则"></a>D(Dependency inversion principle) - 依赖反转原则</h3><p>概念：认为 “一个方法应该遵从依赖于抽象而不是一个实例” 。我们常用的依赖注入就是该原则的一种实现方式。</p><p>也就是说，要实现解耦，使得高层次的模块不依赖于低层次模块的具体实现细节，二者都应该依赖其抽象(抽象类或接口)。</p><p>其实，在我们用的 Java 语言中，抽象就是指接口或者抽象类，二者都是不能直接实例化的；细节就是实现类，实现接口或者继承抽象类而产生的类，就是细节。</p><p>使用 Java 语言描述就简单了，就是各个模块之间相互传递的参数声明为抽象类型，而不是声明为具体的类。</p><p>潜台词: 要面向抽象编程，解耦调用者和被调用者。</p><p>OK, 至此五大基本原则就解释完了，剩下两条原则我们也了解一下，帮助理解。</p><h3 id="迪米特原则-Law-of-Demeter"><a href="#迪米特原则-Law-of-Demeter" class="headerlink" title="迪米特原则 - Law of Demeter"></a>迪米特原则 - Law of Demeter</h3><p>也称：最少知识原则，认为 “一个对象应当对其他对象有尽可能少的了解”。</p><p>也就是说，一个类应该对自己调用的类的实现细节知道的越少越好。</p><p>举例：假设类 A 实现了某个功能，类 B 需要调用类 A 去执行这个功能，那么类 A 应该只暴露一个方法(函数)给类 B 去调用即可，而不是让类 A 把实现这个功能的细节(所有细分的方法和成员)暴露给 B 。</p><p>其实，这也是面向对象程序设计的最基本思想，是面向对象程序设计语言与面向过程程序设计语言最显著的差异。</p><p>潜台词：不要和陌生人说话，有事去找中介。</p><h3 id="组合复用原则-Composite-Reuse-Principle"><a href="#组合复用原则-Composite-Reuse-Principle" class="headerlink" title="组合复用原则 - Composite Reuse Principle"></a>组合复用原则 - Composite Reuse Principle</h3><p>简称：CRP，也称聚合复用原则 - Aggregate Reuse Principle，简称ARP。或者连起来称：组合/聚合复用原则，简称CARP。</p><p>概念：认为 “如果只是为了达到复用的目的，应尽量使用对象组合与聚合，而不是继承。</p><p>因为继承的耦合性更大，而组合、聚合只是引用类的方法，没有这么维护风险同时也实现了复用的目的。</p><p>潜台词：我只是用了你的方法去实现我要的功能，我们不是同类，没有继承关系。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们把面向对象的设计原则讲解完了。你可能会突然发现：哦，原来这么熟悉，原来面向对象的设计原则就在我们身边。是的，其实它就在我们每天的日常编码工作中，只是可能没发现并试图理解它。</p><p>而且设计原则东西就这么点，也很容易学习和掌握。为了帮助读者学习理解并掌握，以及对后面学习设计模式产生帮助，本文花了不少篇幅介绍为什么要学习设计原则，学了有什么好处？真正讲解设计原则方面的知识其实你也发现了，也就那么点。</p><p>OK，最后总结一下本文重点：设计原则和设计模式的概念以及怎么去理解，为什么要学习设计原则，面向对象的设计原则(SOLID),怎么理解多态和继承。</p><p>下篇预告：学习完了设计原则，我们就要来讲解 <strong>设计模式</strong> 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文主要分享对面向对象程序设计的设计原则的理解，以供想了解 OOD 设计原则的人士作参考。&lt;/p&gt;
&lt;p&gt;主要内容包括：对设计原则和设计模式概念的理解，对 OOD 设计原则的理解，对继承和多态的理解。
    
    </summary>
    
      <category term="OOD设计原则" scheme="https://www.alankeene.com/categories/OOD%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="OOD" scheme="https://www.alankeene.com/tags/OOD/"/>
    
      <category term="设计原则" scheme="https://www.alankeene.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Android 简史</title>
    <link href="https://www.alankeene.com/2018/0417/Android-history.html"/>
    <id>https://www.alankeene.com/2018/0417/Android-history.html</id>
    <published>2018-04-17T05:36:17.000Z</published>
    <updated>2019-01-02T07:23:26.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>有一种了解一个事物的方法，那就是了解它的发展历史。 </p></blockquote><p>本文将持续更新记录 Android 的发展简史，以供喜欢 Android 和想了解 Android 的爱好者作参考。</p><p>Android 自 2008 年正式发布至今(2018)，已经走过了十个年头了。像一个小孩的长大一样，十年，对于一生来说，说长不长，仿佛不知不觉就长大了，说短也不短，至少我们不少人都错过了见证 Android 的成长历程，笔者也是 2015 年才开始对 Android 感兴趣并开始了解 Android 的。<a id="more"></a></p><p>这十年，Android 已经迭代了好多个版本，解决或优化了一些人们常诟病的问题，也有许多优秀的体验和设计方面的创新，至今已经占有约 85.9% 的全球市场份额，而且我们相信，Android 还会发展的越来越好。那么，接下来我们一起看看 Android 的发展简史吧。</p><h2 id="Android-前传"><a href="#Android-前传" class="headerlink" title="Android 前传"></a>Android 前传</h2><p>即 Android 操作系统的孵化阶段。 Android 是由 Google 和开放手持设备联盟共同开发发展而来的。</p><p>Android 在正式发布之前，最开始拥有两个内测版，并且以著名的机器人名称来对其进行命名，它们分别是：铁臂阿童木(Astro boy) 和发条机器人(Bender)。<br>后来，由于涉及版权问题，Google 将其命名规则变更为用 <strong>甜点</strong> 作为它们系统版本的代号的命名方法。</p><p>“甜点命名法”开始于第三版 Android 1.5(实际上是第四版，因为 Android 1.0 其实有两版)。而从 Android 1.6 Donut(<strong>甜甜圈</strong>) 开始，项目组才正式确定将 Android 开发代号首字母从 “C” 一直延续下去。</p><h2 id="Android-命名的由来"><a href="#Android-命名的由来" class="headerlink" title="Android 命名的由来"></a>Android 命名的由来</h2><p>Android 一词最早出现于法国作家利尔亚当（Auguste Villiers de l’Isle-Adam）在1886年发表的科幻小说《未来夏娃》（L’Ève future）中。他将外表像人的机器人取名为 Android。</p><h2 id="Android-的生日"><a href="#Android-的生日" class="headerlink" title="Android 的生日"></a>Android 的生日</h2><p>5.11 <strong>被认为</strong>是 Android 的生日。</p><h2 id="Android-的标志"><a href="#Android-的标志" class="headerlink" title="Android 的标志"></a>Android 的标志</h2><p>Android 是一个全身绿色的机器人，颜色采用了 PMS 376C 和 RGB 中十六进制的 #A4C639 来绘制，这是 Android 操作系统的品牌象征。</p><p>Android 的标志是由 Ascender 公司设计的，其中的文字使用了 Ascender 公司专门制作的称之为 “Google Droid” 的字体。</p><h2 id="Android-发展简史"><a href="#Android-发展简史" class="headerlink" title="Android 发展简史"></a>Android 发展简史</h2><table><thead><tr><th style="text-align:center">时间线</th><th style="text-align:center">发布概述</th><th style="text-align:center">版本号</th><th style="text-align:center">版本代号</th><th style="text-align:center">API 等级</th><th style="text-align:center">基于的Linux Kernel版本</th></tr></thead><tbody><tr><td style="text-align:center">2008.9.23</td><td style="text-align:center">Android 1.0 第一个正式版公布。全球第一台 Android 设备 HTC Dream(G1) 搭配的就是 Android 1.0</td><td style="text-align:center">Android 1.0</td><td style="text-align:center">Astro “铁臂阿童木”</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2009.2.2</td><td style="text-align:center">Android 1.1发布</td><td style="text-align:center">Android 1.1</td><td style="text-align:center">Bender “发条机器人” [内部也叫 Petit Four”花式小蛋糕”]</td><td style="text-align:center">2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2009.4.30</td><td style="text-align:center">Android 1.5 发布</td><td style="text-align:center">Android 1.5</td><td style="text-align:center">Cupcake “纸杯蛋糕” [从此版本开始决定用<strong>“甜点命名法”</strong>]</td><td style="text-align:center">3</td><td style="text-align:center">2.6.27</td></tr><tr><td style="text-align:center">2009.9.15</td><td style="text-align:center">Android 1.6 发布</td><td style="text-align:center">Android 1.6</td><td style="text-align:center">Donut “甜甜圈” [从此版本开始决定将代号首字母从 “C,D…” 一直延续下去]</td><td style="text-align:center">4</td><td style="text-align:center">2.6.29</td></tr><tr><td style="text-align:center">2009.10.26</td><td style="text-align:center">Android 2.0 发布</td><td style="text-align:center">Android 2.0</td><td style="text-align:center">Eclair “松饼”</td><td style="text-align:center">5</td><td style="text-align:center">2.6.29</td></tr><tr><td style="text-align:center">2009.12.3</td><td style="text-align:center">Android 2.0.1 发布</td><td style="text-align:center">Android 2.0.1</td><td style="text-align:center">Eclair “松饼”</td><td style="text-align:center">6</td><td style="text-align:center">2.6.29</td></tr><tr><td style="text-align:center">2010.1.12</td><td style="text-align:center">Android 2.1 发布</td><td style="text-align:center">Android 2.1</td><td style="text-align:center">Eclair “松饼”</td><td style="text-align:center">7</td><td style="text-align:center">2.6.29</td></tr><tr><td style="text-align:center">2010.5.20</td><td style="text-align:center">Android 2.2 发布</td><td style="text-align:center">Android 2.2</td><td style="text-align:center">Froyo “冻酸奶”</td><td style="text-align:center">8</td><td style="text-align:center">2.6.32</td></tr><tr><td style="text-align:center">2010.12.7</td><td style="text-align:center">Android 2.3 发布</td><td style="text-align:center">Android 2.3</td><td style="text-align:center">Gingerbread “姜饼”</td><td style="text-align:center">9</td><td style="text-align:center">2.6.35</td></tr><tr><td style="text-align:center">2010.12</td><td style="text-align:center">Android 2.3.3 更新包于 2011.2.9 正式发布，仅对上一个版本进行了API改进</td><td style="text-align:center">Android 2.3.3</td><td style="text-align:center">Gingerbread “姜饼”</td><td style="text-align:center">10</td><td style="text-align:center">2.6.35</td></tr><tr><td style="text-align:center">2011.2.2</td><td style="text-align:center">Android 3.0 发布，Android 3.0 是第一个 Android 平板操作系统，全球第一个使用该版本操作系统的设备是摩托罗拉公司于 2011.2.24 发布的 Motorlola Xoom 平板电脑</td><td style="text-align:center">Android 3.0</td><td style="text-align:center">Honeycomb “蜂巢”</td><td style="text-align:center">11</td><td style="text-align:center">2.6.36</td></tr><tr><td style="text-align:center">2011.5.10</td><td style="text-align:center">Android 3.1 发布</td><td style="text-align:center">Android 3.1</td><td style="text-align:center">Honeycomb “蜂巢”</td><td style="text-align:center">12</td><td style="text-align:center">2.6.36</td></tr><tr><td style="text-align:center">2011.7.15</td><td style="text-align:center">Android 3.2 发布，全球第一台使用该版本操作系统的设备是华为公司制造生产的 MediaPad 平板电脑</td><td style="text-align:center">Android 3.2</td><td style="text-align:center">Honeycomb “蜂巢”</td><td style="text-align:center">13</td><td style="text-align:center">2.6.36</td></tr><tr><td style="text-align:center">2011.10.19</td><td style="text-align:center">Android 4.0 于2011年4月在 Google I/O 大会上首次被宣布，并于 2011.10.19 正式发布 Android 4.0 和搭载 Android 4.0 的 Galaxy Nexus 智能手机。</td><td style="text-align:center">Android 4.0</td><td style="text-align:center">Ice Cream Sandwich “雪糕三明治”</td><td style="text-align:center">14</td><td style="text-align:center">3.0.1</td></tr><tr><td style="text-align:center">2011.12.16</td><td style="text-align:center">Android 4.0.3 发布</td><td style="text-align:center">Android 4.0.3</td><td style="text-align:center">Ice Cream Sandwich “雪糕三明治”</td><td style="text-align:center">15</td><td style="text-align:center">3.0.1</td></tr><tr><td style="text-align:center">2012.6.28</td><td style="text-align:center">Android 4.1 在 Google I/O 大会上和搭载 Android 4.1 的 Nexus 7 平板电脑一起发布</td><td style="text-align:center">Android 4.1</td><td style="text-align:center">JellyBean “果冻豆”</td><td style="text-align:center">16</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2012.10.30</td><td style="text-align:center">Android 4.2 以新闻稿的形式发布。Google原本预计于2012年10月29日于纽约发布Android 4.2，但因为飓风桑迪吹袭被取消，而改以新闻稿发布，以“一种新口味的果冻豆”（A new flavor of Jelly Bean）作口号。首款搭载Android 4.2的手机LG Nexus 4及平板电脑Nexus 10于2012年11月23日上市。</td><td style="text-align:center">Android 4.2</td><td style="text-align:center">JellyBean “果冻豆”</td><td style="text-align:center">17</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2013.7.25</td><td style="text-align:center">Android 4.3 发布</td><td style="text-align:center">Android 4.3</td><td style="text-align:center">JellyBean “果冻豆”</td><td style="text-align:center">18</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2013.10.31</td><td style="text-align:center">Android 4.4 发布，Android 在此版本封锁了Adobe Flash Player 功能，此版本后不再支持 Falsh。</td><td style="text-align:center">Android 4.4</td><td style="text-align:center">Kitkat “奇巧巧克力”</td><td style="text-align:center">19</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2014.6.20</td><td style="text-align:center">Android 4.4.4 发布</td><td style="text-align:center">Android 4.4.4</td><td style="text-align:center">Kitkat “奇巧巧克力”</td><td style="text-align:center">20</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2014.10.16</td><td style="text-align:center">Android 5.0 发布。2014.6.25 在 Google I/O 大会上展示 Android L 的开发者预览版本，并开放下载。并于 2014.10.16 正式发布 Android 5.0 且命名为 Lollipop。此后，Android 沿袭了这种版本演进和发布的方式。<strong>此版本后，采用全新的 Material Design 界面</strong>，我们喜爱的 MD 设计诞生了。</td><td style="text-align:center">Android 5.0</td><td style="text-align:center">Lollipop “棒棒糖”</td><td style="text-align:center">21</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2015.3.10</td><td style="text-align:center">Android 5.1 发布</td><td style="text-align:center">Android 5.1</td><td style="text-align:center">Lollipop “棒棒糖”</td><td style="text-align:center">22</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2015.10.5</td><td style="text-align:center">Android 6.0 发布。2015.5.29 Google 在 I/O 大会啥昂展示 Android M 的开发者预览版，并于 2015.10.5 正式发布 Android 6.0 并将其命名为 Marshmallow。沿袭了上一版本的演进方式，以至于每年猜测和讨论 Android 版本的最终命名代号成了 Android 爱好者的一大乐趣。</td><td style="text-align:center">Android 6.0</td><td style="text-align:center">Marshmallow “棉花糖”</td><td style="text-align:center">23</td><td style="text-align:center">3.14.52</td></tr><tr><td style="text-align:center">2016.8.22</td><td style="text-align:center">Android 7.0 正式发布。2016.3.9 Google 发布 Android N 的开发者预览版并开放下载。于2016.8.22 正式发布 Android 7.0 并将其命名为 Nougat。</td><td style="text-align:center">Android 7.0</td><td style="text-align:center">Nougat “牛扎糖”</td><td style="text-align:center">24</td><td style="text-align:center">3.4.0</td></tr><tr><td style="text-align:center">2016.10.4</td><td style="text-align:center">Android 7.1 发布</td><td style="text-align:center">Android 7.1</td><td style="text-align:center">Nougat “牛扎糖”</td><td style="text-align:center">25</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2017.8.21</td><td style="text-align:center">Android 8.0 正式发布。2017.3.21 Google 发布 Android O 的开发者预览版，并于 2017.8.21 正式发布 Android 8.0 并将其命名为 Oreo。</td><td style="text-align:center">Android 8.0</td><td style="text-align:center">Oreo “奥利奥”</td><td style="text-align:center">26</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2017.12.5</td><td style="text-align:center">Android 8.1 发布</td><td style="text-align:center">Android 8.1</td><td style="text-align:center">Oreo “奥利奥”</td><td style="text-align:center">27</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2018.3.7</td><td style="text-align:center">Google 发布 Android P 的开发者预览版并开放下载。</td><td style="text-align:center">历史待续而来..</td><td style="text-align:center">笔者猜测叫 Pizza “披萨”</td><td style="text-align:center">待续…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>如果还想了解各版本技术特性上的演进史和更多演进细节，请参阅：</p><p><a href="https://en.wikipedia.org/wiki/Android_version_history" target="_blank" rel="noopener">Android version history</a></p><p><a href="https://zh.wikipedia.org/wiki/Android%E6%AD%B7%E5%8F%B2%E7%89%88%E6%9C%AC" target="_blank" rel="noopener">Android历史版本</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;有一种了解一个事物的方法，那就是了解它的发展历史。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将持续更新记录 Android 的发展简史，以供喜欢 Android 和想了解 Android 的爱好者作参考。&lt;/p&gt;
&lt;p&gt;Android 自 2008 年正式发布至今(2018)，已经走过了十个年头了。像一个小孩的长大一样，十年，对于一生来说，说长不长，仿佛不知不觉就长大了，说短也不短，至少我们不少人都错过了见证 Android 的成长历程，笔者也是 2015 年才开始对 Android 感兴趣并开始了解 Android 的。
    
    </summary>
    
      <category term="Android" scheme="https://www.alankeene.com/categories/Android/"/>
    
    
      <category term="Android简史" scheme="https://www.alankeene.com/tags/Android%E7%AE%80%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>用 hexo 搭建博客踩过的坑</title>
    <link href="https://www.alankeene.com/2018/0412/next-problems.html"/>
    <id>https://www.alankeene.com/2018/0412/next-problems.html</id>
    <published>2018-04-12T13:43:47.000Z</published>
    <updated>2019-01-02T07:23:26.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>路是人走出来的，但有些路，希望你不用再摸索着走一遍。 </p></blockquote><p>本文将持续更新记录使用 hexo 框架 NexT 主题搭建博客过程中遇到并解决的坑。以供使用此方式搭建博客的人作参考之用，避免再重复踩坑。<a id="more"></a></p><h2 id="hexo-leancloud-counter-security插件"><a href="#hexo-leancloud-counter-security插件" class="headerlink" title="hexo-leancloud-counter-security插件"></a>hexo-leancloud-counter-security插件</h2><p>当你需要按照 <a href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener">这篇教程</a> 去集成 <code>hexo-leancloud-counter-security</code> 插件时，一定要注意要先让 <code>Counter</code> 初始化成功后，再集成 <code>hexo-leancloud-counter-security</code> 插件，否则文章阅读次数的地方会显示未初始化。</p><p><strong>也就是说：</strong>你需要先别配置部署 <code>hexo-leancloud-counter-security</code> 插件，而只需按照 <a href="https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.html" target="_blank" rel="noopener">这篇教程</a> 去为 NexT 主题添加文章阅读量统计功能，登陆LeanCloud后台看到 <code>Counter</code> 初始化成功并有数据后，再回来按照 <a href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener">这篇教程</a> 的步骤去集成 <code>hexo-leancloud-counter-security</code> 插件。</p><p><strong>原因:</strong> 当初是先有 <a href="https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.html" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a> 这个功能，然后考虑到阅读次数统计数据的安全性，防止被恶意篡改，才产生了 <code>hexo-leancloud-counter-security</code> 这个插件去解决这个问题的。所以老用户直接按照教程直接升级是不可能遇到这个坑的，因为他们原本就已经初始化了 <code>Counter</code> 。而如果你是初次添加 <code>为NexT主题添加文章阅读统计功能</code> ，而且也是初次集成 <code>hexo-leancloud-counter-security</code> 插件，则必须先初始化 <code>Counter</code>。</p><p>关于 <code>必须先初始化 Counter, 再集成 hexo-leancloud-counter-security 插件</code> 这点说明，官方的使用教程 (<a href="https://github.com/theme-next/hexo-theme-next/blob/3dabc1651bbfa9376815e2e561ffb9c42049a3ad/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md" target="_blank" rel="noopener">[中文版]</a> <a href="https://github.com/theme-next/hexo-theme-next/blob/3dabc1651bbfa9376815e2e561ffb9c42049a3ad/docs/LEANCLOUD-COUNTER-SECURITY.md" target="_blank" rel="noopener">[English]</a>) 目前好像还没有很明确的说明。如果你是按照官方使用教程的说明来操作，则需要注意这点，避免踩到坑。</p><p><strong>注：</strong> 由于时间有限，并没有制作针对小白的详细操作步骤，如果你按照本避坑说明集成 <code>hexo-leancloud-counter-security</code> 插件还是遇到问题，可通过邮件联系我获得具体每一步的操作指导。</p><h2 id="让-MarkdownPad-编辑器支持表格"><a href="#让-MarkdownPad-编辑器支持表格" class="headerlink" title="让 MarkdownPad 编辑器支持表格"></a>让 MarkdownPad 编辑器支持表格</h2><p>如果在 Windows 系统下用 MarkdownPad 来写 hexo 博客，MarkdownPad编辑器的默认设置是不支持显示表格的。即常用的Markdown语法书写表格的方式(|:—-:|:—:|)在MarkdownPad编辑器中是无法正确识别并预览的。</p><p>所以，你需要修改 MarkdownPad 编辑器默认的处理器。修改方式如下：</p><p>点击: Tools –&gt; Options –&gt; Markdown –&gt; Markdown Processor,改成<strong>Markdown (Extra)</strong> 即可。</p><p>如果你是中文环境，点击: 工具 –&gt; 选项 –&gt; Markdown –&gt; Markdown 处理器，改成 <strong>Markdown (扩展)</strong> 即可。</p><h2 id="hexo-g-出错怎么办"><a href="#hexo-g-出错怎么办" class="headerlink" title="hexo g 出错怎么办"></a>hexo g 出错怎么办</h2><p>当你写完博客，<code>hexo g</code> 出错，若报错如下:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FATAL Something<span class="symbol">'s</span> wrong. Maybe you can find the solution here: </span><br><span class="line">http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render <span class="literal">error</span>: unexpected <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">file</span> at Object._prettifyError</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明 hexo 框架无法正常渲染你的文章，很有可能是你在书写文章时一不小心哪里的格式没写对造成的。</p><p>举个例子，使用 NexT 的 <code>centerquote</code> 标签时，如果不小心在关闭标签 <code>endcenterquote</code>的 <code>{</code> 和 <code>%</code> 之间多加了一个空格，写成了：<code>{ % centerquote %}</code>。</p><p>则会出现上述的 <code>hexo 无法帮你渲染文章的错误</code>，而这种格式的错误当你写完长篇的文章后，是很难再发现的。</p><p>所以，在你写文章之前，一定要熟悉 hexo 和 NexT 的文档和写作指南，避免因书写格式不对而造成无法渲染。</p><p><a href="https://hexo.io/docs/tag-plugins.html" target="_blank" rel="noopener">hexo的标签使用说明</a></p><p><a href="https://theme-next.iissnan.com/tag-plugins.html" target="_blank" rel="noopener">NexT的内建标签使用说明</a></p><p>当然，当你遇到 <code>Template render error</code> 文章无法渲染的问题时，可按提示参阅 <a href="https://hexo.io/zh-cn/docs/troubleshooting.html" target="_blank" rel="noopener">hexo的问题解答</a> 查看其他常见的问题，看是否可以找到对应的解决方案。</p><h2 id="关于-Gitment-评论系统无法登陆的问题"><a href="#关于-Gitment-评论系统无法登陆的问题" class="headerlink" title="关于 Gitment 评论系统无法登陆的问题"></a>关于 Gitment 评论系统无法登陆的问题</h2><p>如果你是按照 NexT 默认的方式去配置 Gitment 评论插件的话，你会发现 Gitment 现在登陆不了了。 授权登陆 Github 时会发生 <code>Object ProgressEvent</code> 异常。 </p><p>因为 <a href="https://gh-oauth.imsun.net" target="_blank" rel="noopener">https://gh-oauth.imsun.net</a> 域名的 HTTPS 证书今年九月份就过期了，导致无法再正常访问，作者也一直没有更新维护。</p><p>详情请参见：</p><p><a href="https://github.com/imsun/gitment/issues/170" target="_blank" rel="noopener">https://github.com/imsun/gitment/issues/170</a></p><p><a href="https://blog.julysong.com/2018/09/26/gitment/" target="_blank" rel="noopener">gitment 登录失败</a></p><p><a href="https://blog.wolfogre.com/posts/security-problem-of-gitment/" target="_blank" rel="noopener">Gitment 的安全性争议</a></p><p>目前网上也有一些对这个问题的解决方案，总结来说就是需要自己搭建个服务器，或者用别人搭好的服务器替换，但万一哪天别人换了你就又不能用了，不是长久之计，所以如果还想用 Gitment 最好还是能自己搭服务器，不然就用别的评论系统吧，比如来必力。而且，网上也存在 Gitment 安全性争议的讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;路是人走出来的，但有些路，希望你不用再摸索着走一遍。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将持续更新记录使用 hexo 框架 NexT 主题搭建博客过程中遇到并解决的坑。以供使用此方式搭建博客的人作参考之用，避免再重复踩坑。
    
    </summary>
    
      <category term="那些踩过的坑" scheme="https://www.alankeene.com/categories/%E9%82%A3%E4%BA%9B%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="踩的NexT坑" scheme="https://www.alankeene.com/tags/%E8%B8%A9%E7%9A%84NexT%E5%9D%91/"/>
    
  </entry>
  
</feed>
