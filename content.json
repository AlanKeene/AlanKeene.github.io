{"meta":{"title":"Alan's Blog - Android","subtitle":null,"description":"Android Developer.<br>玩 Android, 玩技术~<br>追求通俗易懂的技术描述.<br>喜欢追根溯源，探索技术的深度和原由.","author":"Alan Keene","url":"https://www.alankeene.com"},"pages":[{"title":"关于","date":"2018-04-15T10:24:56.000Z","updated":"2019-03-04T03:32:28.674Z","comments":false,"path":"about/index.html","permalink":"https://www.alankeene.com/about/index.html","excerpt":"","text":"我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系。 关于我: 您好，欢迎你来访我的博客，我是 Alan Keene，自称Alan同学，一名 Android 开发者，同时也是 Android 爱好者。 有过上市公司和大型互联网公司的工作经验，大学期间也做过产品运营相关的工作，有一定的产品和运营能力，对移动互联网行业有着较深的理解和思考。 现在专注于 Android 的开发，做过智慧交通和机器人相关 Android 软件的研发，致力于通过移动互联网的方式，将更多更优秀的产品和服务推到 “人” 这一端，从而实现商业价值和社会价值。 目前在做机器人相关的研发，主要研究人工智能技术在 Android 上的应用落地，做 AIOT 相关的业务。 写博客的初衷是：总结经验，记录自己的成长。 同时也记录一些平时遇到的问题及解决方案，为后来的技术人提供一种参考，避免重复踩坑。 如果你还对 Android Things 感兴趣，欢迎查看 Android Things 官方开发文档-中文版，这是笔者 2017.5 临毕业前花了两个月的时间独自翻译的官方开发文档，当时国内关于 Android Things 还是鲜有完整的文档，故分享一下。 CSDN &emsp;掘金&emsp;SegmentFault 2019 ，一起加油吧 ~ 博客小事记: 2018.04.12 Alan’s Blog 正式上线运维"},{"title":"分类","date":"2018-04-03T09:07:33.000Z","updated":"2019-01-02T07:23:26.257Z","comments":false,"path":"categories/index.html","permalink":"https://www.alankeene.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-03T09:02:35.000Z","updated":"2019-01-02T07:23:26.290Z","comments":false,"path":"tags/index.html","permalink":"https://www.alankeene.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android事件分发机制的一些基本知识","slug":"view-dispatch-basic-knowledge","date":"2019-03-08T08:02:47.000Z","updated":"2019-03-08T09:13:15.316Z","comments":true,"path":"2019/0308/view-dispatch-basic-knowledge.html","link":"","permalink":"https://www.alankeene.com/2019/0308/view-dispatch-basic-knowledge.html","excerpt":"","text":"有一种学得快的方法，就是不要一次学太多。 什么是View的事件分发在 Android 中，用户的在屏幕上的点击事件被抽象成 MotionEvent 这个类，点击事件的类型中比较重要的有 ACTION_DOWN、ACTION_MOVE、ACTION_UP 三种类型。当一个 MotionEvent 事件产生后，系统 需要把这个事件传递给一个具体的 View 来处理，而 MotionEvent 的这个分发过程，就叫 View 的事件分发过程。 点击事件分发过程中有几个重要方法？他们之间的关系是怎么的？有三个重要的方法： dispatchTouchEvent 、onInterceptTouchEvent、onTouchEvent 。 他们之间的关系即代表了 View 的分发规则，用下面一段伪代码来表示会比较清晰： 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 开始分发该事件 boolean consume = false; // 事件是否消费 if (onInterceptTouchEvent(ev)) &#123; // 父View是否拦截该事件 consume = onTouchEvent(ev); // 父View处理该事件，判断是否要消费 &#125; else &#123; consume = child.dispatchTouchEvent(ev); // 交给子View，继续往下分发。 &#125; return consume; // 返回值表示是否消费当前事件&#125; 下面对这三个方法的作用进一步描述： dispatchTouchEvent：用来进行事件的分发，返回结果受当前 View 的 onTouchEvent 方法和下级 View 的 dispatchTouchEvent 方法决定，表示是否消费当前事件。此方法在事件传递给当前 View 时调用。 onInterceptTouchEvent：用来判断是否拦截某个事件。如果当前 View 拦截了某个事件，那么同一事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。此方法在 dispatchTouchEvent 方法中被调用。 onTouchEvent：用来处理点击事件，返回结果表示是否消费当前的事件，如果不消费，则在同一事件序列中，当前 View 无法再次接收到事件。此方法在 dispatchTouchEvent 方法中被调用。 事件分发机制这里说的事件分发机制是指从 ViewGroup 开始的事件分发机制，我们平时说的 View 的事件分发机制也是指从 ViewGroup 开始的事件分发机制。 点击事件的传递过程点击事件的传递过程： Activity —&gt; Window —&gt; View 即事件总是先传递给 Activity，Activity 再传递给 Window，Window 再传递给顶级 View，顶级 View (如 DecorView) 接收到事件后，就会按照事件分发机制去分发事件，找到需要消费当前事件的消费者。 事件分发机制对于一个根 ViewGroup 来说，当点击事件产生后，首先会传递给它，这时它的 dispatchTouchEvent 方法会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true，就表示它要拦截当前事件，接着事件就会交给 ViewGroup 来处理，这时它的 onTouchEvent 方法会被调用。 如果 ViewGroup 的 onInterceptTouchEvent 方法返回 false，就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 dispatchTouchEvent 方法就会被调用，如此反复直到事件被最终处理。 一个 View 是如何处理点击事件的？它会首先判断是否设置了 onTouchListener，如果设置了则会回调 onTouchListener 的 onTouch 方法，这时事件如何处理要看 onTouch 方法的返回值。如果 onTouch 方法返回 true，表示 onTouch 方法要处理这个事件，则 onTouchEvent 将不会再被调用；如果 onTouch 方法返回 false，表示 onTouch 方法不处理这个事件，则 onTouchEvent 方法会被调用。 在 onTouchEvent 方法中，如果当前设置的监听器中有 onClickListener，那么 onClickListener 的 onClick 方法会被回调。 调用优先级：onTouchListener &gt; onTouchEvent &gt; onClickListener","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/tags/Android/"},{"name":"事件分发","slug":"事件分发","permalink":"https://www.alankeene.com/tags/事件分发/"}]},{"title":"Java8 和 Java9 的主要新特性","slug":"java-new-features","date":"2019-03-04T02:42:13.000Z","updated":"2019-03-04T03:32:32.563Z","comments":true,"path":"2019/0304/java-new-features.html","link":"","permalink":"https://www.alankeene.com/2019/0304/java-new-features.html","excerpt":"","text":"Java 8 的主要新特性1.Lambda 表达式Lambda 允许把函数作为一个方法的参数传递进方法中。 作用：解决 Java 被诟病的匿名内部类的问题。 2.接口中可增加了默认方法作用：在接口中也可以有实现方法了。 3.HashMap 底层数据结构的变化java 8 之前，HashMap 底层的数据结构是数组+链表实现的， Java 8 之后是数组+链表+红黑树实现的，当链表的长度超过 8 之后，会转换成红黑树。 作用：解决因哈希冲突导致的链表过长，查询效率低的问题。 4.Stream API新添加 Stream API (java.util.stream)，把真正函数式编程的风格引入 Java。 5.提供一个新的 JavaScript 引擎Java 8 提供了一个新的 Nashorn JavaScript 引擎，它允许在 JVM 上运行特定的 JavaScript 应用。 作用：解决日益增长的 Java 跟 JS 交互混合的需求。 Java 9 新特性1.模块系统模块是一个包的容器，Java 9 最大的变化之一是引入模块系统。（Jigsaw 项目） 作用：解决大型项目模块化开发的需求。 2.支持 HTTP/2 标准HTTP/2 标准是 HTTP 协议的最新版本，新的 HTTPClient API 支持 Websocket 和 HTTP2 流以及服务器推送特性。 3.提供创建不可变集合的静态工厂方法List、Set、Map 接口中，提供新的静态工厂方法直接创建不可变的集合实例。 作用：创建不可变集合更方便，一行代码就搞定，节省了开销。 4.私有接口方法在接口中也允许编写 private 修饰的私有方法了。 作用：增强了接口的功能，提高了可扩展性。 5.轻量级的 JSON API内置了一个轻量级的 JSON API。 6.引入响应式流 APIJava 9 引入了新的响应式流 API。 作用：支持响应式编程的需求。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.alankeene.com/categories/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://www.alankeene.com/tags/Java8/"},{"name":"Java9","slug":"Java9","permalink":"https://www.alankeene.com/tags/Java9/"}]},{"title":"Window 的添加过程","slug":"add-window-process","date":"2019-03-03T10:02:53.000Z","updated":"2019-03-06T04:59:09.855Z","comments":true,"path":"2019/0303/add-window-process.html","link":"","permalink":"https://www.alankeene.com/2019/0303/add-window-process.html","excerpt":"","text":"Window 的添加过程Window(或者说View) 是怎么添加到 Android 系统中然后展示给用户的？让我们来探索一下 Window 的添加过程。 Window 添加过程的入口方法要探索添加的过程，必须先在源代码中找到添加 Window 的入口方法。 Window 的添加需要通过 WindowManager 的 addView 方法实现，但 WindowManager 是个接口，它的真正实现类是 WindowManagerImpl 类，但 WindowManagerImpl 也并没有直接实现对 Window 的添加、删除、更新操作，而是通过桥接模式将所有操作委托给 WindowManagerGlobal 去实现。最终会调用 WindowManagerGlobal 类的 addView 方法真正开启 View 的添加过程。 所有，Window 添加过程的真正入口方法实际上是 WindowManagerGlobal 类的 addView 方法。 Window 添加过程的主要流程WindowManagerGlobal 的 addView 方法主要分为三大步： 1.检查参数 params 是否是 WindowManager.LayoutParams，如果不是说明参数不合法，则会抛出异常。 12345678910111213public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; // 检查 params 参数是否合法 throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; ...&#125; 2.创建 ViewRootImpl，并将 View 添加到列表中。 12345678910public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ...44root = new ViewRootImpl(view.getContext(), display); // 创建 ViewRootImpl view.setLayoutParams(wparams); mViews.add(view); // 将View添加到mView列表中，mView 存储的是所有Window对应的View mRoots.add(root); mParams.add(wparams); ...&#125; 3.通过 ViewRootImpl 的 setView 方法来添加更新界面并通过 IPC 的方式调用 WindowManagerService 的 addWindow 方法完成 Window 的添加过程。 1234567891011121314151617public void addView(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow) &#123;44... // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); // ViewRootImpl的setView 方法 &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125;&#125; 那 ViewRootImpl 的setView 方法是如何实现界面的更新的呢？ setView 方法中会调用 requestLayout() 方法去完成异步刷新请求： 12345678910@SuppressWarnings(&#123;\"EmptyCatchBlock\", \"PointlessBooleanExpression\"&#125;)public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, HardwareRenderer.HardwareDrawCallbacks &#123; private static final String TAG = \"ViewRootImpl\";4... // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. requestLayout(); &#125; 我们再查看 requestLayout 方法的源码，看它干了什么： 12345678@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); // scheduleTraversals 方法是View绘制的入口 &#125;&#125; 可以看到，是调用了 scheduleTraversals 方法进行绘制，我们知道 scheduleTraversals 是 View 执行绘制过程的入口方法，该方法会经过测量、布局、绘制这三个过程把 View 绘制出来。 那 View 绘制出来以后是怎么通过IPC调用的方式添加到 Window 中的呢？ 我们知道，WindowManager 是外界访问 Window 的入口，所以最终 WindowManager 会通过 IPC 的方式调用 WindowManagerService 的 addWindow 方法，这样一来， Window 的添加请求就交给了 WindowManagerService 来处理了，然后 WindowManagerService 会经过一系列的操作将 View 添加到 Window 中并展示出来。 作为应用层开发者来说，了解到这个程度个人觉得就可以了，没必要去深究 WindowManagerService 的实现细节，至于 WindowManagerService 是如何处理 Window 的添加请求的，感兴趣的读者可以去查看源码。 ​ 参考书籍：《Android 开发艺术探索》","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"Window","slug":"Window","permalink":"https://www.alankeene.com/tags/Window/"}]},{"title":"Window、WindowManager、View 之间的关系","slug":"window-and-windowmanager","date":"2019-03-03T09:08:50.000Z","updated":"2019-03-06T04:53:52.832Z","comments":true,"path":"2019/0303/window-and-windowmanager.html","link":"","permalink":"https://www.alankeene.com/2019/0303/window-and-windowmanager.html","excerpt":"","text":"如果问你这三个问题，你的理解是什么呢。 Window 和 WindowManager 是什么关系？ Window 和 View 是什么关系？ WindowManager 和 View 是什么关系？ Window 和 WindowManager 是什么关系？Widow 是个抽象类，在 Android 中所有的视图都是通过 Window 来呈现的，包括 Activity、Dialog、Toast，它们的视图实际上都是附加在 Window 上的。Window 的具体实现类是 PhoneWindow。而 WindowManager 是外界访问 Window 的入口，WindowManager 和 WindowManagerService 之间通过 IPC 进行通信，从而实现对 Window 的访问和操作。 Window 和 View 是什么关系？Window 是 View 的承载者，而 View 是 Window 的体现者。两者之间通过 ViewRootImpl 建立联系。 怎么理解这句话呢？ Window 是 View 的承载者：Android 中的所有视图都是附加在 Window 上呈现出来的 。 View 是 Window 的体现者：因为 Window 是个抽象的概念，并不实际存在，View 才是 Window 存在的实体。 而 ViewRootImpl 是用来建立 Window 和 View 之间的联系的，是两者之间的纽带。 WindowManager 和 View 是什么关系？WindowManager 是 View 的直接管理者，对 View 的添加、删除、更新操作都是通过 WindowManager 来完成的，对应于 WindowManager 的 addView、removeView、updateViewLayout 三个方法。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"Window","slug":"Window","permalink":"https://www.alankeene.com/tags/Window/"},{"name":"WindowManager","slug":"WindowManager","permalink":"https://www.alankeene.com/tags/WindowManager/"}]},{"title":"赛格还会重生吗？","slug":"sz-saige","date":"2019-03-02T06:17:29.000Z","updated":"2019-03-02T06:30:15.337Z","comments":true,"path":"2019/0302/sz-saige.html","link":"","permalink":"https://www.alankeene.com/2019/0302/sz-saige.html","excerpt":"","text":"","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"https://www.alankeene.com/categories/个人随笔/"}],"tags":[{"name":"赛格","slug":"赛格","permalink":"https://www.alankeene.com/tags/赛格/"}]},{"title":"一个有趣的问题，如何用HashSet来存储重复的字符串？","slug":"how-to-store-same-string-in-hashset","date":"2019-02-23T13:46:05.000Z","updated":"2019-03-06T05:34:01.188Z","comments":true,"path":"2019/0223/how-to-store-same-string-in-hashset.html","link":"","permalink":"https://www.alankeene.com/2019/0223/how-to-store-same-string-in-hashset.html","excerpt":"","text":"有一种学得快的方法，就是不要一次学太多。 1. 前言今天，我们来探讨一个实际中不常用但却比较有意思的问题。它能帮助你理解 “HashSet中的键值是唯一的，不可重复的” 这句话的真正含义，也考验你对问题的思考深度。 注：实际应用中，我们一般是用 ArrayList 集合来存储相同的字符串的，不会用 HashSet 来存。 我们平时都看到或听说 HashSet 是不能用来存放重复的字符串的，是真的存放不了吗？如果面试问你这个问题，你能给出解决方案吗？ 2. 参考解答先给出参考解答，然后我们再来分析为什么。 解答：虽然我们不能用 HashSet 来存放 String 类型重复的字符串，但我们可以用 HashSet 来存储 StringBuilder 类型重复的字符串呀。12345678910111213141516171819202122232425262728293031323334353637public class HashSetTest &#123; public static void main(String[] args)&#123; // 用 HashSet 来存放 String 类型的重复的字符串会发生什么？ HashSet&lt;String&gt; hs1 = new HashSet&lt;&gt;(); String s1 = new String(\"aaa\"); String s2 = new String(\"aaa\"); String s3 = new String(\"aaa\"); hs1.add(s1); hs1.add(s2); hs1.add(s3); System.out.println(\"hs1:\"+hs1); // 重复的字符串是存不进去的 // 用 HashSet 来存放 StringBuilder 类型的重复的字符串又会发生什么？ HashSet&lt;StringBuilder&gt; hs2 = new HashSet&lt;&gt;(); StringBuilder sb1 = new StringBuilder(\"aaa\"); StringBuilder sb2 = new StringBuilder(\"aaa\"); StringBuilder sb3 = new StringBuilder(\"aaa\"); hs2.add(sb1); hs2.add(sb2); hs2.add(sb3); System.out.println(\"hs2:\"+hs2); // 咦，结果发现重复的字符串也能存进去了 // 那为什么呢？我们来打印一个各个对象的hashCode看一下 System.out.println(\"s1的hashCode:\"+s1.hashCode()); System.out.println(\"s2的hashCode:\"+s2.hashCode()); System.out.println(\"s3的hashCode:\"+s3.hashCode()); System.out.println(\"sb1的hashCode:\"+sb1.hashCode()); System.out.println(\"sb2的hashCode:\"+sb2.hashCode()); System.out.println(\"sb3的hashCode:\"+sb3.hashCode()); &#125;&#125; 输出结果：12345678hs1:[aaa]hs2:[aaa, aaa, aaa]s1的hashCode:96321s2的hashCode:96321s3的hashCode:96321sb1的hashCode:356573597sb2的hashCode:1735600054sb3的hashCode:21685669 从打印结果来看，我们是不能用 HashSet 来存放 String 类型的重复字符串的(如hs1)，但我们是可以用HashSet来存放 StringBuilder 类型的重复字符串。 3. 为什么？从打印的 hashCode 来看，String 类型，相同字符串的不同 String 对象哈希值是一样的。而对于 StringBuilder 类型，相同字符串的不同对象哈希值是不同的。 要知道这个问题的答案，我们首先得了解 JDK 是如何判断两个对象是否相同的。 那 JDK 是如何判断两个对象是否相同的呢？参考解答： JDK 会先判断两个对象的 hashCode 是否相同，如果 hashCode 不同，则说明肯定是两个不同的对象了；如果 hashCode 相同再通过 equals() 方法进行进一步比较，如果 equals 方法返回 true，则说明两个对象是相同的，如果equals方法返回 false 说明两个对象不同。 具体验证思路如果你感兴趣，请查看: JDK 是如何判断两个对象是否相同的？判断的流程是什么？ 那为什么相同字符串的不同 String 对象哈希值是一样的，而且还被 JDK 判断为相同的对象了呢？因为 String 类复写了 Object 类的 hashCode() 和 equals() 方法，并实现了自己的 hashCode 值生成算法和 equals 的比较规则，具有相同字符串内容的不同 String 对象在初始化时生成的 hashCode 值是一样的，并且 String 类 equals() 方法比较的是两个字符串的内容，而不是内存地址值，这两个条件同时成立， 这使得 JDK 把具有相同内容的不同 String 对象判断为相同的对象了，就不会存入 HashSet 集合中。 而 StringBuilder 为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？查看 StringBuilder 类的源码你会发现，因为 StringBuilder 并没有复写 Object 类的 hashCode() 方法和 equals() 方法，StringBuilder 用的是父类 Object 类的 hashCode 生成算法，也就是用 native 层的 hashCode 生成算法，很大概率产生的哈希值是不一样的，即使产生了一样的哈希值，Object 类的 equals() 方法比较的是两个对象的内存地址，而不是两个对象的内容，这就使得 JDK 把具有相同内容的 StringBuilder 对象判断为不同的对象，就可以存入 HashSet 集合中了。","categories":[{"name":"Java 内功强化系列","slug":"Java-内功强化系列","permalink":"https://www.alankeene.com/categories/Java-内功强化系列/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.alankeene.com/tags/Java/"},{"name":"HashSet","slug":"HashSet","permalink":"https://www.alankeene.com/tags/HashSet/"},{"name":"String","slug":"String","permalink":"https://www.alankeene.com/tags/String/"}]},{"title":"JDK是如何判断两个对象是否相同的？判断的流程是什么？","slug":"how-jdk-distinguish-object","date":"2019-02-21T16:17:40.000Z","updated":"2019-03-06T04:34:44.587Z","comments":true,"path":"2019/0222/how-jdk-distinguish-object.html","link":"","permalink":"https://www.alankeene.com/2019/0222/how-jdk-distinguish-object.html","excerpt":"","text":"有一种学得快的方法，就是不要一次学太多。 JDK 是如何判断两个对象是否相同的呢？判断的流程是什么？ 参考解答：JDK 会先判断两个对象的hashCode是否相同，如果hashCode不同，则说明肯定是两个不同的对象了；如果hashCode相同再通过equals()方法进行进一步比较，如果equals方法返回true，则说明两个对象是相同的，如果equals方法返回false说明两个对象不同。 如何验证怎么来验证这个问题呢？我们知道HashSet是不允许存储相同的键值的。所以我们可以用HashSet存储两个相同的键值来模拟，看 JDK 是如何做判断和识别的，从而验证我们的猜想。 12345678910111213141516// 先自定义一个类并复写 hashCode 和 equals 方法public class CustomClass &#123; @Override public int hashCode() &#123; System.out.println(\"判断 hashCode\"); return 1; // 返回1，说明所有新建的对象的哈希值都为1，也就是相同 &#125; @Override public boolean equals(Object o) &#123; System.out.println(\"判断 equals\"); return true; // 返回true &#125;&#125; 接下来我们用HashSet来存储两个自定义的CustomClass的对象，代码如下：12345678910111213public class HashSetTest &#123; public static void main(String[] args) &#123; HashSet&lt;CustomClass&gt; hs = new HashSet&lt;&gt;(); CustomClass cs1 = new CustomClass(); CustomClass cs2 = new CustomClass(); hs.add(cs1); hs.add(cs2); System.out.println(\"----hs添加完毕\"); System.out.println(\"hs:\"+hs); // 打印一下hashSet集合看里面存放了什么 &#125;&#125; 打印结果如下：123456判断 hashCode 判断 hashCode判断 equals----hs添加完毕判断 hashCode // 此处的判断是打印输出语句执行时调用的，与分析本问题无关hs:[com.alankeene.javalib.collections.CustomClass@1] 结果分析：执行 hs.add(cs1) 语句的时候，JDK 会先判断 cs1 所指向对象的hashCode，因为是第一次往HashSet集合里面存放元素，该元素 hashCode 在集合中肯定是还没存在的，这是个新的元素，所以直接存放进集合中，不用调用 cs1 所指向对象的 equals 方法。当执行 hs.add(cs2) 语句时，这是第二次往集合里存放元素，有新的元素 cs2 要添加进来，那先要调用 cs2 所指向对象的 hashCode 方法看看它的哈希值是不是与集合中已有元素的哈希值重复了，发现重复了，哈希值都是1，那有可能是同一个对象，那就要调用 cs2 所指向对象的 equals 方法做进一步判断，发现 equals 方法返回 true，则判断为是重复的元素，就不往集合里添加了。 所以最终打印 HashSet 集合的时候可以看到，集合中只存放了一个元素。 我们再反证一下，把 equals 方法改为返回 false，模拟两个hashCode相同，但是是两个不同的对象的情景。1234567891011121314public class CustomClass &#123; @Override public int hashCode() &#123; System.out.println(\"判断 hashCode\"); return 1; // 返回1，说明所有新建的对象的哈希值都为1，也就是相同 &#125; @Override public boolean equals(Object o) &#123; System.out.println(\"判断 equals\"); return false; // 返回false &#125;&#125; 打印结果会如下：1234567判断 hashCode 判断 hashCode判断 equals----hs添加完毕判断 hashCode // 此处的判断是打印输出语句执行时调用的，与分析本问题无关判断 hashCode // 此处的判断是打印输出语句执行时调用的，与分析本问题无关hs:[com.alankeene.javalib.collections.CustomClass@1, com.alankeene.javalib.collections.CustomClass@1] 会发现，HashSet集合中存放了两个元素了，说明虽然 cs1 和 cs2 的哈希值相同，但是 JDK 判断为不同的元素并存入集合中了。 由此，验证了我们的猜想。JDK 是先判断 hashCode，如果 hashCode 相同再通过 equals 去判断两个对象是否相同的。","categories":[{"name":"Java 内功强化系列","slug":"Java-内功强化系列","permalink":"https://www.alankeene.com/categories/Java-内功强化系列/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.alankeene.com/tags/Java/"}]},{"title":"你有没有想过，为什么Java中String是不可变的？","slug":"why-string-imutable","date":"2019-02-19T08:49:34.000Z","updated":"2019-03-06T09:43:29.252Z","comments":true,"path":"2019/0219/why-string-imutable.html","link":"","permalink":"https://www.alankeene.com/2019/0219/why-string-imutable.html","excerpt":"","text":"有一种学得快的方法，就是不要一次学太多。 解答：有三点：1）String 在底层是用一个 private final 修饰的字符数组 value 来存储字符串的。final 修饰符保证了 value 这个引用变量是不可变的，private 修饰符则保证了 value 是类私有的，不能通过对象实例去访问和更改 value 数组里存放的字符。 注：有很多地方说 String 不可变是 final 起的作用，其实不严谨。因为即使我不用 final 修改 value ，但初始化完成后我能保证以后都不更改 value 这个引用变量和 value[] 数组里存放的值，它也是从没变化过的。final 只是保证了 value 这个引用变量是不能更改的，但不能保证 value[] 数组里存放的字符是不能更改的。如果把 private 改为 public 修饰，String类的对象是可以通过访问 value 去更改 value[] 数组里存放的字符的，这时 String 就不再是不可变的了。所以不如说 private 起的作用更大一些。后面我们会通过 代码1处 去验证。 2）String 类并没有对外暴露可以修改 value[] 数组内容的方法，并且 String 类内部对字符串的操作和改变都是通过新建一个 String 对象去完成的，操作完返回的是新的 String 对象，并没有改变原来对象的 value[] 数组。 注：String 类如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，也是不能保证 String 是不可变的。后面我们会通过 代码2处 去验证。 3）String 类是用 final 修饰的，保证了 String 类是不能通过子类继承去破坏或更改它的不可变性的。 注：如果 String 类不是用 final 修饰的，也就是 String 类是可以被子类继承的，那子类就可以改变父类原有的方法或属性。后面我们会通过 代码3处 去验证。 以上三个条件同时满足，才让 String 类成了不可变类，才让 String 类具有了一旦实例化就不能改变它的内容的属性。 12345678910111213141516171819public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final char[] value; // 用 private final 修饰的字符数组存储字符串 private int hash; private static final long serialVersionUID = -6849794470754667710L;\\ public String() &#123; this.value = \"\".value; &#125; public String(String var1) &#123; this.value = var1.value; this.hash = var1.hash; &#125; public String(char[] var1) &#123; this.value = Arrays.copyOf(var1, var1.length); &#125; ......&#125; 面试问题：String 类是用什么数据结构来存储字符串的？由上面 String 的源码可见，String 类是用数组的数据结构来存储字符串的。 代码1处：我们来看看如果把 private 修饰符换成 public，看看会发生什么？ 12345678910111213141516 // 先来模拟一个String类，初始化的时候将 String 转成 value 数组存储public final class WhyStringImutable &#123; public final char[] value; // 修饰符改成了 public public WhyStringImutable() &#123; this.value = \"\".toCharArray(); &#125; public WhyStringImutable(String str)&#123; this.value = str.toCharArray(); // 初始化时转为字符数组 &#125; public char[] getValue()&#123; return this.value; &#125;&#125; 1234567891011public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; WhyStringImutable str = new WhyStringImutable(\"abcd\"); System.out.println(\"原str中value数组的内容为：\"); System.out.println(str.getValue()); // 打印str对象中存放的字符数组 System.out.println(\"----------\"); str.value[1] = 'e'; // 通过对象实例访问value数组并修改其内容 System.out.println(\"修改后str中value数组的内容为：\"); System.out.println(str.getValue()); // 打印str对象中存放的字符数组 &#125;&#125; 输出结果：12345原str中value数组的内容为：abcd----------修改后str中value数组的内容为：aecd 由此可见，private 修改为 public 后，String 是可以通过对象实例访问并修改所保存的value 数组的，并不能保证 String 的不可变性。 代码2处：我们如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，看看又会发生什么？123456789101112131415161718192021public final class WhyStringImutable &#123; private final char[] value; public WhyStringImutable() &#123; this.value = \"\".toCharArray(); &#125; public WhyStringImutable(String str)&#123; this.value = str.toCharArray(); &#125; // 对外暴露可以修改 value 数组的方法 public void setValue(int i, char ch)&#123; this.value[i] = ch; &#125; public char[] getValue()&#123; return this.value; &#125;&#125; 1234567891011public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; WhyStringImutable str = new WhyStringImutable(\"abcd\"); System.out.println(\"原str中value数组的内容为：\"); System.out.println(str.getValue()); // 打印str对象中存放的字符数组 System.out.println(\"----------\"); str.setValue(1,'e'); // 通过set方法改变指定位置的value数组元素 System.out.println(\"修改后str中value数组的内容为：\"); System.out.println(str.getValue()); // 打印str对象中存放的字符数组 &#125;&#125; 输出结果：12345原str中value数组的内容为：abcd----------修改后str中value数组的内容为：aecd 由此可见，如果对外暴露了可以更改 value[] 数组内容的方法，也是不能保证 String 的不可变性的。 代码3处：如果 WhyStringImutable 类去掉 final 修饰，其他的保持不变，又会怎样呢？123456789101112131415public class WhyStringImutable &#123; private final char[] value; public WhyStringImutable() &#123; this.value = \"\".toCharArray(); &#125; public WhyStringImutable(String str)&#123; this.value = str.toCharArray(); // 初始化时转为字符数组 &#125; public char[] getValue()&#123; return this.value; &#125;&#125; 写一个子类继承自WhyStringImutable 并修改原来父类的属性，实现子类自己的逻辑：1234567891011121314151617public class WhyStringImutableChild extends WhyStringImutable &#123; public char[] value; // 修改字符数组为 public 修饰，不要 final public WhyStringImutableChild(String str)&#123; this.value = str.toCharArray(); &#125; public WhyStringImutableChild() &#123; this.value = \"\".toCharArray(); &#125; @Override public char[] getValue() &#123; return this.value; &#125;&#125; 1234567891011public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; WhyStringImutableChild str = new WhyStringImutableChild(\"abcd\"); System.out.println(\"原str中value数组的内容为：\"); System.out.println(str.getValue()); System.out.println(\"----------\"); str.value[1] = 's'; System.out.println(\"修改后str中value数组的内容为：\"); System.out.println(str.getValue()); &#125;&#125; 运行结果：12345原str中value数组的内容为：abcd----------修改后str中value数组的内容为：ascd 由此可见，如果 String 类不是用 final 修饰的，是可以通过子类继承来修改它原来的属性的，所以也是不能保证它的不可变性的。 总结综上所分析，String 不可变的原因是 JDK 设计者巧妙的设计了如上三点，保证了String 类是个不可变类，让 String 具有了不可变的属性。考验的是工程师构造数据类型，封装数据的功力，而不是简单的用 final 来修饰，背后的设计思想值得我们理解和学习。 拓展从上面的分析，我们知道，String 确实是个不可变的类，但我们就真的没办法改变 String 对象的值了吗？不是的，通过反射可以改变 String 对象的值。 但是请谨慎那么做，因为一旦通过反射改变对应的 String 对象的值，后面再创建相同内容的 String 对象时都会是反射改变后的值，这时候在后面的代码逻辑执行时就会出现让你 “摸不着头脑” 的现象，具有迷惑性，出了奇葩的问题你也很难排除到原因。后面在 代码4处 我们会验证这个问题。 先来看看如何通过反射改变 String 对象的内容：1234567891011121314public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; String str = new String(\"123\"); System.out.println(\"反射前 str:\"+str); try &#123; Field field = String.class.getDeclaredField(\"value\"); field.setAccessible(true); char[] aa = (char[]) field.get(str); aa[1] = '1'; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; System.out.println(\"反射后 str：\"+str);&#125; 打印结果：12反射前 str:123反射后 str：113 // 可见，反射后，str 的值确实改变了 代码4处:下面我们来验证因为一旦通过反射改变对应的 String 对象的值，后面再创建相同内容的 String 对象时都会是反射改变后的值的问题：12345678910111213141516171819public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; String str = new String(\"123\"); System.out.println(\"反射前 str:\"+str); try &#123; Field field = String.class.getDeclaredField(\"value\"); field.setAccessible(true); char[] aa = (char[]) field.get(str); aa[1] = '1'; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; System.out.println(\"反射后 str：\"+str); String str2 = new String(\"123\"); System.out.println(\"str2:\"+str2); // 我们来看 str2 会输出什么，会输出 113？ System.out.println(\"判断是否是同一对象：\"+str == str2); // 判断 str 和 str2 的内存地址值是否相等 System.out.println(\"判断内容是否相同：\"+str.equals(str2)); // 判断 str 和 str2 的内容是否相等&#125; 执行结果如下：12345反射前 str:123反射后 str：113str2:113 // 竟然不是123？？而是输出113，说明 str2 也是反射修改后的值。判断是否是同一对象：false // 输出 false，说明在内存中确实创建了两个不同的对象判断内容是否相同：true // 输出true，说明依然判断为两个对象内容是相等的 由上面的输出结果，我们可知，反射后再新建相同内容的字符串对象时会是反射修改后的值，这就造成了很大迷惑性，在实际开发中要谨慎这么做。","categories":[{"name":"Java 内功强化系列","slug":"Java-内功强化系列","permalink":"https://www.alankeene.com/categories/Java-内功强化系列/"}],"tags":[{"name":"String","slug":"String","permalink":"https://www.alankeene.com/tags/String/"}]},{"title":"Android Studio mac 快捷键","slug":"AndroidStudio-mac-shortcuts","date":"2019-01-06T04:38:27.000Z","updated":"2019-01-07T05:45:48.522Z","comments":true,"path":"2019/0106/AndroidStudio-mac-shortcuts.html","link":"","permalink":"https://www.alankeene.com/2019/0106/AndroidStudio-mac-shortcuts.html","excerpt":"","text":"Android Studio 常用 mac 快捷键 快捷键 用法 ⌃+⇧+Space 初始化对象时，输入 new 后，按此快捷键快速输入类名 ⌥⌘B 快速导航到抽象方法的实现类 ⌥⌘V mEditorPane.setBorder(BorderFatory.createEmptyBorder(5,5,5,5));选中BorderFatory.createEmptyBorder(5,5,5,5), 然后按此快捷键，自动提取出如下代码：Border emptyBorder = BorderFactory.createEmptyBorder(5,5,5,5);myEditorPane.setBorder(emptyBorder); ⌃Space 新建一个变量时，按此快捷键，编辑器会推荐一个变量名 ⌘P 如果光标位于方法调用的括号之间，则按⌘P将显示有效参数列表。","categories":[{"name":"记录","slug":"记录","permalink":"https://www.alankeene.com/categories/记录/"}],"tags":[{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://www.alankeene.com/tags/mac快捷键/"}]},{"title":"Pre-built binaries not found for fsevents@1.1.3 and node@11.6.0","slug":"fsevents-didnot-soppurt-node11","date":"2019-01-02T14:40:08.000Z","updated":"2019-02-19T17:29:54.148Z","comments":true,"path":"2019/0102/fsevents-didnot-soppurt-node11.html","link":"","permalink":"https://www.alankeene.com/2019/0102/fsevents-didnot-soppurt-node11.html","excerpt":"用 npm install 安装 fsevent 插件， 发现如下图提示： 搜索了一圈发现原来是 fsevents 目前还没支持 node v11+，笔者用的是 brew install node 下载的 node，默认下载的是最新的版本，用 node -v 命令查看 node 的版本呢，笔者的 node 是 v11.6.0。","text":"用 npm install 安装 fsevent 插件， 发现如下图提示： 搜索了一圈发现原来是 fsevents 目前还没支持 node v11+，笔者用的是 brew install node 下载的 node，默认下载的是最新的版本，用 node -v 命令查看 node 的版本呢，笔者的 node 是 v11.6.0。 详情请参阅： Build binary for Node 11 No binary found on s3 for Node v8.0 知道了原因那在 mac 下如何快速降低 node 的版本呢？ 看这： https://apple.stackexchange.com/a/207883","categories":[{"name":"日常解决问题集锦","slug":"日常解决问题集锦","permalink":"https://www.alankeene.com/categories/日常解决问题集锦/"}],"tags":[{"name":"fsevents","slug":"fsevents","permalink":"https://www.alankeene.com/tags/fsevents/"},{"name":"node","slug":"node","permalink":"https://www.alankeene.com/tags/node/"}]},{"title":"最安全的hexo多台电脑同步博客解决方案--非新建分支","slug":"hexo-perfect-synchronize","date":"2019-01-02T07:42:05.000Z","updated":"2019-02-19T17:27:21.665Z","comments":true,"path":"2019/0102/hexo-perfect-synchronize.html","link":"","permalink":"https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html","excerpt":"","text":"我们经常有这样一个需求场景：需要在多台电脑间完成 Hexo 博客的撰写和发布，这就涉及到如何多台电脑同步博客的问题。 我最近也遇到了这个问题，网上看了很多方案，都是通过新建一个分支来存放博客源文件。但这样一来，我很多第三方插件配置的密钥信息不就暴露了吗？会不会存在数据安全隐患？有没有什么办法不暴露这些信息？对了，用一个私有仓库来存放博客源文件不就结了嘛。虽然 Github 的私有仓库是收费的，但是我的博客是同时部署在 Github 和 Coding 的，而 Coding 是可以新建私有仓库的。Nice，完美解决。 当我准备写遍博客来分享（xuan yao）这个解决方案时，最后还是荣幸的发现一遍文章已经分享了这个方案，只是在搜索引擎中不太好搜出来。本着“不重复造轮子的原则”，笔者就不重写了，而且他已经写的很好了。但是有几个问题需要特别注意一下： 该文中删除主题的 .git 配置，如果你有多个主题文件夹的话，需要都删除(如 NexT 主题)。然后删除的命令那位笔者不小心写错了，应该是： rm -rf ./themes/next/.git/ 用这条命令来删除你对应主题文件夹里的.git 文件夹，注意 .git 是一个隐藏文件夹。 .gitignore 文件夹在 Hexo 的根目录下可能已经存在了，可以打开和该文中的忽略事项比对一下，如果一样，接着 git init 初始化 git 仓库就好；如果没有该 .gitignore 文件夹就新建一个添加相应忽略事项再 git init 初始化。 这点需要特别注意，否则可能导致迁移失败： 虽然我们第 1 步中删除了主题的 .git 配置，第 2 步中Hexo项目根目录的 .gitignore 文件也并没有忽略掉 theme 这个文件夹。但是！！ NexT 主题的文件夹原来是用 git 来管理的，里面还有一个 .gitignore 文件，把 themes/next/source/lib 目录下的很多文件给忽略掉了。 这就导致了你上传到私有仓库时，你以为你把 themes 文件下的所有内容都上传到仓库了，但其实 “偷偷”的把 themes/next/source/lib 目录下的很多必要的文件也忽略掉了，并没有上传。然后在新电脑上拉下来的时候，hexo g、hexo s 一预览，你会奇怪的发现：所有的 FontAwesome 相关的图标都不见了，其他的功能一切正常。 正确的做法是：在新机器上把私有仓库上的博客源文件 clone 下来后，因为还缺点原来的文件，所以应该去原来机器上 themes/next/source/lib 目录下，把整个 lib 目录下的文件全部复制粘贴到新机器对应的 themes/next/source/lib 目录下，这样就能正常生成站点文件了。 注意：同理，如果你的 themes 目录下有多个主题配置文件的话，可以查看是否有 .gitignore 文件，用 git 上传私有仓库时是否也忽略了一些必要资源，如果有再新电脑上对应复制过来就 OK 了。 关于这个问题的详情，可查看：https://github.com/theme-next/hexo-theme-next/issues/564#issuecomment-451385682 在新电脑上 npm install 下载 hexo 所需的环境的时候，要切到 hexo 的根目录下，再执行 npm install。 当你在新电脑用 npm install 下载依赖的第三插件时，由于 node 的版本、众多第三方插件、跨平台等原因，可能有的插件会存在兼容性问题，导致下载不下来，笔者想迁移到 Mac 上就遇到兼容性问题了，fsevent 插件目前不支持 node v11+ 版本，而刚配置新电脑的 node 环境时，默认安装的是最新版的 node，需要降低 node 的版本才能下载成功。 node 11 无法安装 fsevents 插件的解决方案 至于如何降低 node 的版本，其实你不用删除，有一个叫 nvm （Node Version Manager）的工具，专门用来管理多个版本的 node 环境的，你可以下载多个版本的 node 存在你的机器中，用 nvm 的命令行就可以实现不同版本 node 环境的随意切换，非常方便。 这是 nvm 的 github 地址 好，当你在新的电脑上写完博客，本地预览也没问题，准备用 hexo d 部署到 Github 和 Coding 上前，别忘了把新电脑的 SSH 公钥配置到 Github 和 Coding 上。 然后用 hexo d部署时，由于在新机器上，SSH 密钥和之前的不一样，第一次尝试连接 Github 主机时会提示：The authenticity of host github.com can&#39;t be established.Are you sure you want continue connecting? 输入 yes 就好，同理 coding 仓库也会提示，同样输入yes。至此，新电脑上写完的博客也成功同步更新到 Github 和 Coding 的仓库上了。 更新完博客后，记得 用 git push 将新电脑上改动的博客源文件也 push 到私有仓库中，实现博客源文件的同步更新。 当你在另一台电脑上准备开始写博客前，记得把远程私有仓库的最新博客源文件拉到本地，但记得不要用 git pull 的方式，用如下两条命令： 123git fetch --all #将远程git仓库上最新的内容拉取到本地,将本地库所关联的远程库更新至最新git reset --hard origin/master #强制将本地库的内容指向最新远程仓库的master分支 最后附上该篇博客的地址： 最完美的Hexo多电脑同步方法 从此，你就可以在多台电脑间愉快地写博客啦～ 本迁移解决方案博主亲测有效，请放心迁移，迁移过程中如果还遇到什么问题欢迎和我交流。 2019.1.8 最新更新： 好消息是：Github 从 2019.1.8 日起可以免费使用私有仓库了，那大家也可以选择把博客源文件传到 Github 私有仓库上，维护起来更加方便了。","categories":[{"name":"经验","slug":"经验","permalink":"https://www.alankeene.com/categories/经验/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.alankeene.com/tags/hexo/"},{"name":"多电脑同步博客","slug":"多电脑同步博客","permalink":"https://www.alankeene.com/tags/多电脑同步博客/"}]},{"title":"dryrun 在 windows 上的使用教程","slug":"use-dryrun-in-windows","date":"2018-06-18T05:30:51.000Z","updated":"2019-01-02T07:23:26.257Z","comments":true,"path":"2018/0618/use-dryrun-in-windows.html","link":"","permalink":"https://www.alankeene.com/2018/0618/use-dryrun-in-windows.html","excerpt":"有些坑别人踩过了，希望你不用再踩一遍。 dryrun 的作者使用的是 Mac，本文主要介绍 dryrun 在 windows 上配置使用的方法以及容易导致配置不成功的关键点，为想在 windows 上也能使用 dryrun 的 Android 开发者提供参考。","text":"有些坑别人踩过了，希望你不用再踩一遍。 dryrun 的作者使用的是 Mac，本文主要介绍 dryrun 在 windows 上配置使用的方法以及容易导致配置不成功的关键点，为想在 windows 上也能使用 dryrun 的 Android 开发者提供参考。 dryrun 是个什么工具？能帮我们提高什么效率？简单来说，dryrun 是帮助 Android 开发者快速预览 Github 上开源 Android 项目在真机上的实际运行效果的工具。 使用 dryrun 工具，可以避免下载解压、导入项目、编译、运行在手机上一系列的动作，简单一行命令 dryrun + Github 上的项目地址 就可以把 Github 上的 Android 项目安装到真机上预览实际的效果了。 dryrun 的 Github 地址 windows 上安装和配置 dryrun 所需环境请参考： Windows 环境下的 dryrun 使用教程 但笔者按照以上教程并没有配置成功，有几个坑点上文中尚未提及，需要另外注意一下： 关于下载哪个版本的 Ruby 和 DevKit 据网上说，Ruby 最新版已经内置了 DevKit，但笔者尝试了最新版的 Ruby 的安装，发现安装过程及配置稍微复杂，不适合完全不懂 Ruby 的小白，而我们作为想使用 dryrun 工具 的Android 开发者，只是需要 ruby 的一个环境，并不需要用到 Ruby 的最新特性，所以笔者建议如果你不太了解最新版的 Ruby 如何去安装和配置的话，像笔者一样下载： 2.3.3 版本的 Ruby 和 DevKit For use with Ruby 2.0 to 2.3 然后按照教程以及容易忽略的坑点去安装和配置即可。 需要配置 JAVA_HOME 环境变量。 由于新版的 Android Studio 已经帮我们内置了 JDK ,我们 Android 开发者不需要再像以前那样需要单独的配置 JAVA 环境，所以容易忽略了 dryrun 安装时需要的 JAVA 环境。 如果你的机器尚未配置 JAVA 环境变量，按照教程执行到 gem install dryrun --source http://rubygems.org 安装 dryrun 的步骤时，会安装不成功，仔细看日志会发现是缺少了 JAVA 环境变量。配置好 JAVA_HOME 环境变量再执行安装命令就能安装成功了。 至于如何配置 JAVA 环境变量，想必想使用 dryrun 的人应该都会了，如果你恰巧不会或忘了，网上也有很多配置教程可以找到，不用担心。 需要配置 ANDROID_HOME 环境变量。 安装好了 dryrun 后，执行 dryrun + Github 项目地址 去在真机上下载并预览项目时，如果没有配置 Android_HOME 环境变量，会发现项目下载不下来。配置一下 ANDROID_HOME 环境变量即可，也就是配置一下 SDK 的路径。 好了，在 windows 上使用 dryrun 的方法以及容易忽略的几个坑点已经讲解完毕了，希望你们都能愉快的一次性就安装成功，不用踩坑，然后就是愉快的逛 Github 去学习啦~","categories":[{"name":"提高开发效率的工具","slug":"提高开发效率的工具","permalink":"https://www.alankeene.com/categories/提高开发效率的工具/"}],"tags":[{"name":"dryrun 使用","slug":"dryrun-使用","permalink":"https://www.alankeene.com/tags/dryrun-使用/"},{"name":"dryrun windows 使用","slug":"dryrun-windows-使用","permalink":"https://www.alankeene.com/tags/dryrun-windows-使用/"}]},{"title":"Android Things 官方开发文档(中文版)","slug":"Android-Things","date":"2018-04-21T13:44:41.000Z","updated":"2019-01-02T07:23:26.256Z","comments":true,"path":"2018/0421/Android-Things.html","link":"","permalink":"https://www.alankeene.com/2018/0421/Android-Things.html","excerpt":"有的人是因为看到才会相信，有的人是因为相信才会看到。 这是笔者最喜欢的一张图片了，作为一个沉稳严谨的工程师，每当笔者看到这个图片时，都不免心潮澎湃一下。 而今，全世界都在憧憬万物互联，在谈论IOT，未来会是什么样？什么时候来？ 也许在互联网的世界里，未来很快就有可能到来，也许来了也会是和我们想象的形态不一样。但有一点我们可以坚信，物联网是趋势，而且肯定会来。 如果你对 Android Things 已经有一定了解，可以直接参阅笔者翻译的一本电子书：Android Things 官方开发文档(中文版)，跳过下面介绍的阅读，或者直接跳到第二部分看麻省理工流体界面实验室研发出来的 Reality Editor.","text":"有的人是因为看到才会相信，有的人是因为相信才会看到。 这是笔者最喜欢的一张图片了，作为一个沉稳严谨的工程师，每当笔者看到这个图片时，都不免心潮澎湃一下。 而今，全世界都在憧憬万物互联，在谈论IOT，未来会是什么样？什么时候来？ 也许在互联网的世界里，未来很快就有可能到来，也许来了也会是和我们想象的形态不一样。但有一点我们可以坚信，物联网是趋势，而且肯定会来。 如果你对 Android Things 已经有一定了解，可以直接参阅笔者翻译的一本电子书：Android Things 官方开发文档(中文版)，跳过下面介绍的阅读，或者直接跳到第二部分看麻省理工流体界面实验室研发出来的 Reality Editor. Android Things 简介Android Things 正是 Google 布局物联网领域的一个操作系统，蕴含着 Google 在物联网领域的野心。 正如官方介绍的那样： If you can build an app, you can build a device. Android Things 的前身是 Goolge 2015 年发布的物联网平台 Birllo，除了继承 Brillo 的功能外，还加入了 Android Studio、 Android SDK、 Google Play 服务以及 Google 云平台等 Android 开发者熟悉的工具和服务。任何 Android 开发者现在都可以利用 Android API 和 Google 服务轻松构建智能联网设备。 连接智能手机有 Android 操作系统，连接智能穿戴设备有 Android Wear，连接平板有 Android Tablets，连接智能电视有 Android TV，连接汽车有 Android AUTO，PC端的还有 Chrome OS。很显然，Google 是想基于 Android 连接一切，打通你生活中的所有需求。 自 2016.12 发布第一个开发者预览版以来，目前 Android Things 依然在孵化中，截至笔者写稿的此时，孵化到了 Developer Preview 8，开发者预览版 8 。 Android Things 会不会在物联网领域发展起来时大展宏图不能确定，但看目前 Android Things 的演进，Google 还是对其抱有梦想。 而作为 Android 开发者，这是值得让我们兴奋的事，Android 充满了更多的可能。 笔者非常看好 Android 和 Android Things 的未来，也是从 Android Things 预览版发布开始就一直关注 Android Things 的动态。笔者认为只要我们的计算平台还是手机，Android 的前景就是光明的，互联网的变革之后，现在我们的人在哪？就在手机里。人在哪服务就会在哪，未来会有更多先进的技术、服务集成到手机里推到“人”这一端，比如现在研究出来的很多 AI 技术在努力的寻找落地应用场景，嗷嗷待哺。而手机中，Android 的全球市场份额占到了 85.9%，并且每年都还在增长，Android 操作系统在体验上也优化的越来越好。 笔者在 2017.5 翻译了 Android Things 的官方开发文档，并做成了一本 Gitbook 电子书，如果你想要更加详细的了解 Android Things 或者是 Android Things 的开发者，可以获得参考，免费的哦~ 电子书地址：Android Things 官方开发文档(中文版) 麻省理工的 Reality Editor下面分享一下麻省理工流体界面实验室花了3年时间研发出来的一款增强现实应用，叫 Reality Editor，实现了设备功能的连接。 Reality Editor的概念是通过手机摄像头取景，以增强现实的方式将用户周围的智能设备连接在一起，通过手指滑动即可将一系列相关的设备联通。 下面就是激动人心的视频啦：(前方高能，非战斗人员迅速撤离)","categories":[{"name":"Android Things","slug":"Android-Things","permalink":"https://www.alankeene.com/categories/Android-Things/"}],"tags":[{"name":"Android Things","slug":"Android-Things","permalink":"https://www.alankeene.com/tags/Android-Things/"},{"name":"IOT","slug":"IOT","permalink":"https://www.alankeene.com/tags/IOT/"}]},{"title":"面向对象的设计原则--一文带你理解清楚","slug":"principles-of-OOD","date":"2018-04-18T05:20:42.000Z","updated":"2019-01-02T07:23:26.257Z","comments":true,"path":"2018/0418/principles-of-OOD.html","link":"","permalink":"https://www.alankeene.com/2018/0418/principles-of-OOD.html","excerpt":"设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 本文主要分享对面向对象程序设计的设计原则的理解，以供想了解 OOD 设计原则的人士作参考。 主要内容包括：对设计原则和设计模式概念的理解，对 OOD 设计原则的理解，对继承和多态的理解。","text":"设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 本文主要分享对面向对象程序设计的设计原则的理解，以供想了解 OOD 设计原则的人士作参考。 主要内容包括：对设计原则和设计模式概念的理解，对 OOD 设计原则的理解，对继承和多态的理解。 什么是设计原则？什么是设计模式?什么是设计原则？怎么理解设计原则？如果要做个比喻，设计原则就像我们的宪法，而设计模式就像我们具体的基于宪法的各部法律，如：劳动法、海商法等等。 也就是说，设计原则是我们设计面向对象程序的纲领性指导，各种设计模式也是基于设计原则而设计的。 什么是设计模式？怎么理解设计模式？设计模式是帮助开发人员在设计应用程序或系统时，解决常见问题的正式最佳实践。 也就是说，设计模式是无数前辈工程师们在日常编码过程中总结出来的一些经验，它告诉你在某种具体的需求场景下该用什么样的方式编写代码才会最好，写出来的代码扩展性和可维护性才会更强，代码更高级，解决的是具体的需求。 Java 的设计模式共有23种，分为3大类，有部分在实际工作中也不常用。 但是，理论上设计模式可以有无数种，而并非23种，因为如上所述，设计模式解决的是具体某种需求场景的设计经验，而随着时间的推移和时代的变化，需求可以发生很多变化，而对应的设计模式理论上也可以被创造出来。 而设计原则就那么几条，相对固定，只要按这几条原则去设计和组织你的代码，解决你的需求，理论上就是在创造一种新的设计模式，如果这种编码方式不属于那23条里面而且也没有人使用过的话。 所以说，设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 我们应该怎样学习和掌握设计原则？在我们的日常工作中，初级工程师，甚至是高级工程师，在实际的编码工作中并不会真真切切的用到设计原则，用的更多的是设计模式去解决工作中具体的需求。 也就是说，实际工作要求我们掌握的其实更多是设计模式，而并非设计原则。所以掌握设计模式是我们的重点，是向优秀工程师迈进的必备技能。 我们为什么还要学习和掌握设计原则呢？就像如果你不是立法机构的话，你似乎并不需要了解和掌握宪法，在日常生活中你碰到劳动相关问题了你就去了解劳动法，碰到海上贸易纠纷问题了你就去了解海商法即可。但是，这些具体的法律都是基于宪法的，如果你不了解宪法的话，你就不知道它们为什么是这样来设计的，虽然并不影响你用来解决实际问题，但你却不知道为什么。 同理，学习和掌握设计原则的目的也是如此。而且更重要的是，其实设计原则很容易理解和掌握，因为基本原则也就 5 条。当你理解了设计原则，再回来理解设计模式时，就会理解他为什么要这样写代码？为什么这样写代码是更加好的，扩展性和可维护性是更强的？ 换句话说，在理解了设计原则的基础上去掌握设计模式，就会理解的更加透彻，而不仅仅是只会使用设计模式而不知道为什么要这样设计。也能以不变应万变，不变的是设计原则，变得是设计模式。 而且，理解了设计原则再去学习设计模式，会相对容易记住和掌握，并大概率是以后都不会容易忘记。否则很有可能是这种情况：在工作中遇到问题去学习一下设计模式，看懂了用来解决了实际的需求，但过几天就忘了，设计模式相关的知识学了又忘，忘了又学，反反复复，好像总是掌握不了设计模式。笔者就经历过这样的一个过程，因为设计模式虽然只有23种，但涉及的相关知识点其实很多，要想想那可是多少人多少年来才总结出来的那么点经验啊，岂能是初学者一下就能完全掌握和记住的，单纯23种设计模式的写法和对应的使用场景都不容易理解和记忆。 但如果你理解了设计原则，情况就会变得好些，在学习具体的某种设计模式的时候，你就会知道它用了什么设计原则，代码为什么是这样写的？这么写的好处是什么? SOLID 设计原则好，了解了为什么要学习设计原则，接下来就要学习和理解设计原则了。 首先，面向对象的设计原则一共有几条？表述不一，江湖上有三种表述方法：有的说面向对象的七大原则，有的说六大原则，有的说五大原则。不过这只是不同的理解方式，对学习来说并不影响。 不过笔者参阅了维基百科 SOLID (面向对象设计)) 的解释，笔者的理解方式是：面向对象程序设计有五条基本原则，其他两条原则也学习了解，但不在基本原则的表述里。 而这五大基本原则，首字母简写就是 “SOLID” , 英文 “solid” 是固体的意思，固体的形态也意味着相对固定不变，很符合设计原则的思想，所以为了方便记忆，笔者也将面向对象的 SOLID 原则称为 “固体原则”。 S (Single reponsibility principle) - 单一职责原则概念：认为 “对象应该仅有一种单一功能”。 换句话说，你在设计一个类的时候，应该有职责单一的特性，就是将一组相关性很高的函数、数据封装到一个类中。 潜台词是：尽量拆分到最小单位，解决复用和组合的问题。 O (Open/closed principle) - 开闭原则概念： 认为 “软件体应该是对于扩展是开放的，但对于修改是封闭” 的。 什么意思呢？ 换句话说，一个类对于扩展是开放的，但对于修改是封闭的。如：我们升级、维护 APP 或系统需要增加新的功能时，应该尽量通过扩展去实现新的功能，而不是通过修改已有的代码来实现，以免带来一些难以发现的Bug。 试想一下，如果你要给一个系统增加新的功能，你通过修改源代码来实现，为了让新增的功能模块能正常运行，改了很多源代码，这时集成到系统中一测试，发现整个系统无法正常运行了，而且这个系统是已经在线上运行为用户提供服务的，你怎么办？你还要百分之百的还原原来的源码吗？ 所以，开闭原则能帮我们避免一些修改风险。 潜台词: 控制需求变动时的风险，缩小维护成本 L (Liskov substitution principle) - 里氏替换原则概念： 认为 “程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的” 。 本质上说，就是告诉我们要好好利用 继承 和 多态。 从技术上简单的描述，就是以父类的形式声明的变量(或形参)，赋值为任何继承于这个父类的子类后不影响程序的执行。 潜台词：尽量使用精准的抽象类或接口。 代码举例：123456789101112131415161718192021222324252627282930//窗口类public class Window &#123; public void show(View child) &#123; child.onDraw(); //调用抽象类View的抽象方法--onDraw方法 &#125;&#125;//抽象类Viewpublic abstract class View &#123; public abstract void onDraw(); public void onMeasure(int width, int length) &#123; //测量视图的大小 ... &#125;&#125;//继承抽象类View的子View,复写抽象方法onDraw()public class Button extends View &#123; public void onDraw() &#123; //绘制一个按钮 ... &#125;&#125;public class TextView extends View &#123; public void onDraw() &#123; //绘制文本 ... &#125;&#125; 实例代码解释: Window 类中的 show 函数需要传入 View, 并且调用 View 对象的 onDraw() 方法，而每个继承于 View 的子类对象都要实现 onDraw() 方法，不存在继承于 View 却没实现 onDraw() 方法的子类对象(abstract方法必须实现)。我们在抽象类 View 的设计时就是运用了里氏替换原则。 而当我们在调用窗口类 Window 的 show() 方法时，可以传入抽象类 View 的任何实现子类 Button类 或 TextView类，均不会影响程序的正常执行：123show(new Button());或show(new TextView()); 这样，你就可以实现在窗口上绘制任意一个的视图的需求了，一旦有增加新的视图的需求时，你只需要继承抽象类view并实现它的抽象方法 onDraw() 即可，作为参数传入 Window 类的 show() 方法中，Window 类就可以帮你把它绘制出来。 比如，你现在学习学累了，想在窗口上画个饼充饥，就可以实现一个画饼的子类：123456789public class Cake extends View &#123; public void onDraw() &#123; //画个饼充饥 ... &#125;&#125;//功能实现完了，然后作为参数传入 Windows 类的 show() 方法show(new Cake()); 其实，这种设计思想无处不在，你每天都能遇到，Android 中的 View 的绘制就是使用了这种思想。 如何理解多态和继承？多态的概念：同一个行为具有多个不同的表现形式或形态的能力。 举例：Window类的 show() 方法都是调用 View.onDraw() 的功能，但 TextView 和 Button 各自的 onDraw() 方法的表现形式不一样。 多态的好处：可以使程序有良好的扩展性，并可以对所有类的对象进行通用处理。用通俗的话说就是：一键修改，到处应用。 举例：实现抽象类 View 的抽象方法 onDraw() ,TextView 和 Button 实现了不同的绘制行为，即多态，扩展成不同的需求或功能。而与此同时，如果修改了抽象父类 View 的绘制行为，所有调用 View 的 Window 对象相应的 show() 行为也统一进行了更改。 笔者想到我们的一句俚语，用来帮助理解继承和多态再合适不过了：“一母生九子，连母十个样”。 “母”即父类，“九子”则继承自“母”这个父类，“连母十个样”：说明子类和父类都可以有不同的行为，也就是多态。 注意：Java 中类只能单继承，但可以多实现。用俚语帮助理解就是：每个人只能有一个爸爸(单继承)，但可以有多个兄弟(多实现)。 I(Interface segregation principle) - 接口隔离原则概念：认为 “多个特定客户端接口要好于一个宽泛用途的接口”。 也就是说，类之间的依赖关系应该建立在最小的接口上。其原则是将非常庞大的、臃肿的接口拆分成更小的更具体的接口。 潜台词： 尽量拆分成功能更具体的接口。 D(Dependency inversion principle) - 依赖反转原则概念：认为 “一个方法应该遵从依赖于抽象而不是一个实例” 。我们常用的依赖注入就是该原则的一种实现方式。 也就是说，要实现解耦，使得高层次的模块不依赖于低层次模块的具体实现细节，二者都应该依赖其抽象(抽象类或接口)。 其实，在我们用的 Java 语言中，抽象就是指接口或者抽象类，二者都是不能直接实例化的；细节就是实现类，实现接口或者继承抽象类而产生的类，就是细节。 使用 Java 语言描述就简单了，就是各个模块之间相互传递的参数声明为抽象类型，而不是声明为具体的类。 潜台词: 要面向抽象编程，解耦调用者和被调用者。 OK, 至此五大基本原则就解释完了，剩下两条原则我们也了解一下，帮助理解。 迪米特原则 - Law of Demeter也称：最少知识原则，认为 “一个对象应当对其他对象有尽可能少的了解”。 也就是说，一个类应该对自己调用的类的实现细节知道的越少越好。 举例：假设类 A 实现了某个功能，类 B 需要调用类 A 去执行这个功能，那么类 A 应该只暴露一个方法(函数)给类 B 去调用即可，而不是让类 A 把实现这个功能的细节(所有细分的方法和成员)暴露给 B 。 其实，这也是面向对象程序设计的最基本思想，是面向对象程序设计语言与面向过程程序设计语言最显著的差异。 潜台词：不要和陌生人说话，有事去找中介。 组合复用原则 - Composite Reuse Principle简称：CRP，也称聚合复用原则 - Aggregate Reuse Principle，简称ARP。或者连起来称：组合/聚合复用原则，简称CARP。 概念：认为 “如果只是为了达到复用的目的，应尽量使用对象组合与聚合，而不是继承。 因为继承的耦合性更大，而组合、聚合只是引用类的方法，没有这么维护风险同时也实现了复用的目的。 潜台词：我只是用了你的方法去实现我要的功能，我们不是同类，没有继承关系。 总结至此，我们把面向对象的设计原则讲解完了。你可能会突然发现：哦，原来这么熟悉，原来面向对象的设计原则就在我们身边。是的，其实它就在我们每天的日常编码工作中，只是可能没发现并试图理解它。 而且设计原则东西就这么点，也很容易学习和掌握。为了帮助读者学习理解并掌握，以及对后面学习设计模式产生帮助，本文花了不少篇幅介绍为什么要学习设计原则，学了有什么好处？真正讲解设计原则方面的知识其实你也发现了，也就那么点。 OK，最后总结一下本文重点：设计原则和设计模式的概念以及怎么去理解，为什么要学习设计原则，面向对象的设计原则(SOLID),怎么理解多态和继承。 下篇预告：学习完了设计原则，我们就要来讲解 设计模式 了。","categories":[{"name":"OOD设计原则","slug":"OOD设计原则","permalink":"https://www.alankeene.com/categories/OOD设计原则/"}],"tags":[{"name":"OOD","slug":"OOD","permalink":"https://www.alankeene.com/tags/OOD/"},{"name":"设计原则","slug":"设计原则","permalink":"https://www.alankeene.com/tags/设计原则/"}]},{"title":"Android 简史","slug":"Android-history","date":"2018-04-17T05:36:17.000Z","updated":"2019-01-02T07:23:26.256Z","comments":true,"path":"2018/0417/Android-history.html","link":"","permalink":"https://www.alankeene.com/2018/0417/Android-history.html","excerpt":"有一种了解一个事物的方法，那就是了解它的发展历史。 本文将持续更新记录 Android 的发展简史，以供喜欢 Android 和想了解 Android 的爱好者作参考。 Android 自 2008 年正式发布至今(2018)，已经走过了十个年头了。像一个小孩的长大一样，十年，对于一生来说，说长不长，仿佛不知不觉就长大了，说短也不短，至少我们不少人都错过了见证 Android 的成长历程，笔者也是 2015 年才开始对 Android 感兴趣并开始了解 Android 的。","text":"有一种了解一个事物的方法，那就是了解它的发展历史。 本文将持续更新记录 Android 的发展简史，以供喜欢 Android 和想了解 Android 的爱好者作参考。 Android 自 2008 年正式发布至今(2018)，已经走过了十个年头了。像一个小孩的长大一样，十年，对于一生来说，说长不长，仿佛不知不觉就长大了，说短也不短，至少我们不少人都错过了见证 Android 的成长历程，笔者也是 2015 年才开始对 Android 感兴趣并开始了解 Android 的。 这十年，Android 已经迭代了好多个版本，解决或优化了一些人们常诟病的问题，也有许多优秀的体验和设计方面的创新，至今已经占有约 85.9% 的全球市场份额，而且我们相信，Android 还会发展的越来越好。那么，接下来我们一起看看 Android 的发展简史吧。 Android 前传即 Android 操作系统的孵化阶段。 Android 是由 Google 和开放手持设备联盟共同开发发展而来的。 Android 在正式发布之前，最开始拥有两个内测版，并且以著名的机器人名称来对其进行命名，它们分别是：铁臂阿童木(Astro boy) 和发条机器人(Bender)。后来，由于涉及版权问题，Google 将其命名规则变更为用 甜点 作为它们系统版本的代号的命名方法。 “甜点命名法”开始于第三版 Android 1.5(实际上是第四版，因为 Android 1.0 其实有两版)。而从 Android 1.6 Donut(甜甜圈) 开始，项目组才正式确定将 Android 开发代号首字母从 “C” 一直延续下去。 Android 命名的由来Android 一词最早出现于法国作家利尔亚当（Auguste Villiers de l’Isle-Adam）在1886年发表的科幻小说《未来夏娃》（L’Ève future）中。他将外表像人的机器人取名为 Android。 Android 的生日5.11 被认为是 Android 的生日。 Android 的标志Android 是一个全身绿色的机器人，颜色采用了 PMS 376C 和 RGB 中十六进制的 #A4C639 来绘制，这是 Android 操作系统的品牌象征。 Android 的标志是由 Ascender 公司设计的，其中的文字使用了 Ascender 公司专门制作的称之为 “Google Droid” 的字体。 Android 发展简史 时间线 发布概述 版本号 版本代号 API 等级 基于的Linux Kernel版本 2008.9.23 Android 1.0 第一个正式版公布。全球第一台 Android 设备 HTC Dream(G1) 搭配的就是 Android 1.0 Android 1.0 Astro “铁臂阿童木” 1 2009.2.2 Android 1.1发布 Android 1.1 Bender “发条机器人” [内部也叫 Petit Four”花式小蛋糕”] 2 2009.4.30 Android 1.5 发布 Android 1.5 Cupcake “纸杯蛋糕” [从此版本开始决定用“甜点命名法”] 3 2.6.27 2009.9.15 Android 1.6 发布 Android 1.6 Donut “甜甜圈” [从此版本开始决定将代号首字母从 “C,D…” 一直延续下去] 4 2.6.29 2009.10.26 Android 2.0 发布 Android 2.0 Eclair “松饼” 5 2.6.29 2009.12.3 Android 2.0.1 发布 Android 2.0.1 Eclair “松饼” 6 2.6.29 2010.1.12 Android 2.1 发布 Android 2.1 Eclair “松饼” 7 2.6.29 2010.5.20 Android 2.2 发布 Android 2.2 Froyo “冻酸奶” 8 2.6.32 2010.12.7 Android 2.3 发布 Android 2.3 Gingerbread “姜饼” 9 2.6.35 2010.12 Android 2.3.3 更新包于 2011.2.9 正式发布，仅对上一个版本进行了API改进 Android 2.3.3 Gingerbread “姜饼” 10 2.6.35 2011.2.2 Android 3.0 发布，Android 3.0 是第一个 Android 平板操作系统，全球第一个使用该版本操作系统的设备是摩托罗拉公司于 2011.2.24 发布的 Motorlola Xoom 平板电脑 Android 3.0 Honeycomb “蜂巢” 11 2.6.36 2011.5.10 Android 3.1 发布 Android 3.1 Honeycomb “蜂巢” 12 2.6.36 2011.7.15 Android 3.2 发布，全球第一台使用该版本操作系统的设备是华为公司制造生产的 MediaPad 平板电脑 Android 3.2 Honeycomb “蜂巢” 13 2.6.36 2011.10.19 Android 4.0 于2011年4月在 Google I/O 大会上首次被宣布，并于 2011.10.19 正式发布 Android 4.0 和搭载 Android 4.0 的 Galaxy Nexus 智能手机。 Android 4.0 Ice Cream Sandwich “雪糕三明治” 14 3.0.1 2011.12.16 Android 4.0.3 发布 Android 4.0.3 Ice Cream Sandwich “雪糕三明治” 15 3.0.1 2012.6.28 Android 4.1 在 Google I/O 大会上和搭载 Android 4.1 的 Nexus 7 平板电脑一起发布 Android 4.1 JellyBean “果冻豆” 16 3.4.0 2012.10.30 Android 4.2 以新闻稿的形式发布。Google原本预计于2012年10月29日于纽约发布Android 4.2，但因为飓风桑迪吹袭被取消，而改以新闻稿发布，以“一种新口味的果冻豆”（A new flavor of Jelly Bean）作口号。首款搭载Android 4.2的手机LG Nexus 4及平板电脑Nexus 10于2012年11月23日上市。 Android 4.2 JellyBean “果冻豆” 17 3.4.0 2013.7.25 Android 4.3 发布 Android 4.3 JellyBean “果冻豆” 18 3.4.0 2013.10.31 Android 4.4 发布，Android 在此版本封锁了Adobe Flash Player 功能，此版本后不再支持 Falsh。 Android 4.4 Kitkat “奇巧巧克力” 19 3.4.0 2014.6.20 Android 4.4.4 发布 Android 4.4.4 Kitkat “奇巧巧克力” 20 3.4.0 2014.10.16 Android 5.0 发布。2014.6.25 在 Google I/O 大会上展示 Android L 的开发者预览版本，并开放下载。并于 2014.10.16 正式发布 Android 5.0 且命名为 Lollipop。此后，Android 沿袭了这种版本演进和发布的方式。此版本后，采用全新的 Material Design 界面，我们喜爱的 MD 设计诞生了。 Android 5.0 Lollipop “棒棒糖” 21 3.4.0 2015.3.10 Android 5.1 发布 Android 5.1 Lollipop “棒棒糖” 22 3.4.0 2015.10.5 Android 6.0 发布。2015.5.29 Google 在 I/O 大会啥昂展示 Android M 的开发者预览版，并于 2015.10.5 正式发布 Android 6.0 并将其命名为 Marshmallow。沿袭了上一版本的演进方式，以至于每年猜测和讨论 Android 版本的最终命名代号成了 Android 爱好者的一大乐趣。 Android 6.0 Marshmallow “棉花糖” 23 3.14.52 2016.8.22 Android 7.0 正式发布。2016.3.9 Google 发布 Android N 的开发者预览版并开放下载。于2016.8.22 正式发布 Android 7.0 并将其命名为 Nougat。 Android 7.0 Nougat “牛扎糖” 24 3.4.0 2016.10.4 Android 7.1 发布 Android 7.1 Nougat “牛扎糖” 25 2017.8.21 Android 8.0 正式发布。2017.3.21 Google 发布 Android O 的开发者预览版，并于 2017.8.21 正式发布 Android 8.0 并将其命名为 Oreo。 Android 8.0 Oreo “奥利奥” 26 2017.12.5 Android 8.1 发布 Android 8.1 Oreo “奥利奥” 27 2018.3.7 Google 发布 Android P 的开发者预览版并开放下载。 历史待续而来.. 笔者猜测叫 Pizza “披萨” 待续… … … … … … … 如果还想了解各版本技术特性上的演进史和更多演进细节，请参阅： Android version history Android历史版本","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"Android简史","slug":"Android简史","permalink":"https://www.alankeene.com/tags/Android简史/"}]},{"title":"用 hexo 搭建博客踩过的坑","slug":"next-problems","date":"2018-04-12T13:43:47.000Z","updated":"2019-01-02T07:23:26.256Z","comments":true,"path":"2018/0412/next-problems.html","link":"","permalink":"https://www.alankeene.com/2018/0412/next-problems.html","excerpt":"路是人走出来的，但有些路，希望你不用再摸索着走一遍。 本文将持续更新记录使用 hexo 框架 NexT 主题搭建博客过程中遇到并解决的坑。以供使用此方式搭建博客的人作参考之用，避免再重复踩坑。","text":"路是人走出来的，但有些路，希望你不用再摸索着走一遍。 本文将持续更新记录使用 hexo 框架 NexT 主题搭建博客过程中遇到并解决的坑。以供使用此方式搭建博客的人作参考之用，避免再重复踩坑。 hexo-leancloud-counter-security插件当你需要按照 这篇教程 去集成 hexo-leancloud-counter-security 插件时，一定要注意要先让 Counter 初始化成功后，再集成 hexo-leancloud-counter-security 插件，否则文章阅读次数的地方会显示未初始化。 也就是说：你需要先别配置部署 hexo-leancloud-counter-security 插件，而只需按照 这篇教程 去为 NexT 主题添加文章阅读量统计功能，登陆LeanCloud后台看到 Counter 初始化成功并有数据后，再回来按照 这篇教程 的步骤去集成 hexo-leancloud-counter-security 插件。 原因: 当初是先有 为NexT主题添加文章阅读量统计功能 这个功能，然后考虑到阅读次数统计数据的安全性，防止被恶意篡改，才产生了 hexo-leancloud-counter-security 这个插件去解决这个问题的。所以老用户直接按照教程直接升级是不可能遇到这个坑的，因为他们原本就已经初始化了 Counter 。而如果你是初次添加 为NexT主题添加文章阅读统计功能 ，而且也是初次集成 hexo-leancloud-counter-security 插件，则必须先初始化 Counter。 关于 必须先初始化 Counter, 再集成 hexo-leancloud-counter-security 插件 这点说明，官方的使用教程 ([中文版] [English]) 目前好像还没有很明确的说明。如果你是按照官方使用教程的说明来操作，则需要注意这点，避免踩到坑。 注： 由于时间有限，并没有制作针对小白的详细操作步骤，如果你按照本避坑说明集成 hexo-leancloud-counter-security 插件还是遇到问题，可通过邮件联系我获得具体每一步的操作指导。 让 MarkdownPad 编辑器支持表格如果在 Windows 系统下用 MarkdownPad 来写 hexo 博客，MarkdownPad编辑器的默认设置是不支持显示表格的。即常用的Markdown语法书写表格的方式(|:—-:|:—:|)在MarkdownPad编辑器中是无法正确识别并预览的。 所以，你需要修改 MarkdownPad 编辑器默认的处理器。修改方式如下： 点击: Tools –&gt; Options –&gt; Markdown –&gt; Markdown Processor,改成Markdown (Extra) 即可。 如果你是中文环境，点击: 工具 –&gt; 选项 –&gt; Markdown –&gt; Markdown 处理器，改成 Markdown (扩展) 即可。 hexo g 出错怎么办当你写完博客，hexo g 出错，若报错如下: 12345FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: unexpected end of file at Object._prettifyError 说明 hexo 框架无法正常渲染你的文章，很有可能是你在书写文章时一不小心哪里的格式没写对造成的。 举个例子，使用 NexT 的 centerquote 标签时，如果不小心在关闭标签 endcenterquote的 { 和 % 之间多加了一个空格，写成了：{ % centerquote %}。 则会出现上述的 hexo 无法帮你渲染文章的错误，而这种格式的错误当你写完长篇的文章后，是很难再发现的。 所以，在你写文章之前，一定要熟悉 hexo 和 NexT 的文档和写作指南，避免因书写格式不对而造成无法渲染。 hexo的标签使用说明 NexT的内建标签使用说明 当然，当你遇到 Template render error 文章无法渲染的问题时，可按提示参阅 hexo的问题解答 查看其他常见的问题，看是否可以找到对应的解决方案。 关于 Gitment 评论系统无法登陆的问题如果你是按照 NexT 默认的方式去配置 Gitment 评论插件的话，你会发现 Gitment 现在登陆不了了。 授权登陆 Github 时会发生 Object ProgressEvent 异常。 因为 https://gh-oauth.imsun.net 域名的 HTTPS 证书今年九月份就过期了，导致无法再正常访问，作者也一直没有更新维护。 详情请参见： https://github.com/imsun/gitment/issues/170 gitment 登录失败 Gitment 的安全性争议 目前网上也有一些对这个问题的解决方案，总结来说就是需要自己搭建个服务器，或者用别人搭好的服务器替换，但万一哪天别人换了你就又不能用了，不是长久之计，所以如果还想用 Gitment 最好还是能自己搭服务器，不然就用别的评论系统吧，比如来必力。而且，网上也存在 Gitment 安全性争议的讨论。","categories":[{"name":"那些踩过的坑","slug":"那些踩过的坑","permalink":"https://www.alankeene.com/categories/那些踩过的坑/"}],"tags":[{"name":"踩的NexT坑","slug":"踩的NexT坑","permalink":"https://www.alankeene.com/tags/踩的NexT坑/"}]}]}