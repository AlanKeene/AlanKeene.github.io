{"meta":{"title":"老陈Android馆","subtitle":null,"description":"Android Developer.<br>玩 Android, 玩技术~<br>追求通俗易懂的技术描述.<br>喜欢追根溯源，探索技术的深度和原由.","author":"老陈","url":"https://www.alankeene.com"},"pages":[{"title":"分类","date":"2018-04-03T09:07:33.000Z","updated":"2019-01-02T07:23:26.257Z","comments":false,"path":"categories/index.html","permalink":"https://www.alankeene.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-04-15T10:24:56.000Z","updated":"2022-05-05T19:03:44.581Z","comments":false,"path":"about/index.html","permalink":"https://www.alankeene.com/about/index.html","excerpt":"","text":"When you are content to be simply yourself and don’t compare or compete, everyone will respect you. 关于我: 你好，欢迎来访我的博客，我是老陈，一名 Android 开发者。 在大中小厂、创业公司都工作过，目前在某互联网大厂工作，也曾做过用户运营相关的工作，有一定的产品和运营能力。对技术商业、艺术和人文类的东西比较感兴趣。 日常也会关注互联网圈子里的大小事，对移动互联网行业有着较深的理解和思考。虽做技术，但也喜欢产品，具备用户 sense 和产品 sense。 现在专注于探索人工智能技术在 Android 上的应用落地，赋能 AIOT 各相关产品线。做过语音助手、人工智能电视、智慧交通、服务型机器人、智慧酒店、智慧社区等产品形态相关 Android 软件的研发，致力于通过移动互联网的方式，将更多更优秀的产品和服务推到 “人” 这一端，从而实现商业价值和社会价值。 目前在做智能语音助手相关的研发、性能优化、用户体验优化、语音架构优化及平台化改造、代码质量管理、代码协作规范搭建、APK 版本管理规范搭建等工作。 写博客的初衷：总结经验，记录自己的成长。 同时也记录一些平时遇到的问题及解决方案，为后来的技术人提供一种参考，避免重复踩坑。也许每篇文章都会包含一张我拍摄的照片。照片和主题也许不相关，只是为了更有趣。 如果你还对 Android Things 感兴趣，欢迎查看 Android Things 官方开发文档-中文版，这是笔者 2017.5 临毕业前花了两个月独自翻译的官方开发文档，当时国内关于 Android Things 还是鲜有完整的文档，故分享一下。 CSDN &emsp;掘金&emsp;SegmentFault 希望你也能在这里跟我一起找到自己的成长。很高兴你能来，也不遗憾你离开。想我的时候记得常回来看看。 微信公众号： 2022 ，一起加油吧 ~ 博客小事记: 2018.04.12 「老陈Android馆」 正式上线运维。 2019.04.22 「老陈Android馆」 访问用户量达到 1024。 2022.04.03 「老陈Android馆」微信公众号开通。"},{"title":"标签","date":"2018-04-03T09:02:35.000Z","updated":"2019-01-02T07:23:26.290Z","comments":false,"path":"tags/index.html","permalink":"https://www.alankeene.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"华为机试题：字符串处理系列(一)","slug":"string-handle","date":"2022-05-07T13:19:14.000Z","updated":"2022-05-07T13:22:38.158Z","comments":true,"path":"2022/0507/string-handle.html","link":"","permalink":"https://www.alankeene.com/2022/0507/string-handle.html","excerpt":"","text":"题目描述： 给定一个常数k，和一个字符串s，s中含有一个及以上的‘-’，以此来连接各个子串。 现对除了第一个子串之外的其他子串进行重新划分，每k个字符作为一个子串，使用‘-’连接， 同时子串需满足一下条件： 1.子串中若大写字母数量大于小写字母数量，则全部转换为大写；若大写字母数量小于小写字母数量，则全部转换为小写； 若大写字母数量等于小写字母数量，则不变。 2.若子串长度不足k，则剩下的字符组成一个子串。 示例1： 输入： 第一行为给定常数k，指定子串长度，第二行输入为字符串s。 3 124asd-ABCabc-abCABc@ 输出： 124asd-ABC-abc-abc-ABC-@ 题解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Scanner;/** * @Author AlanKeene * @Date 2022/05/07 * @Points 字符串处理 */public class StringHandle &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String k = sc.nextLine(); String s = sc.nextLine(); System.out.println(handleString(Integer.valueOf(k), s)); &#125; public static String handleString(int k, String s) &#123; StringBuilder sb = new StringBuilder(); String[] strs = s.split(\"-\"); String otherString; // 先拼接出剩下子串 for (int i = 1; i &lt; strs.length; ++i) &#123; sb.append(strs[i]); &#125; otherString = sb.toString(); int length = otherString.length(); StringBuilder output = new StringBuilder(); output.append(strs[0]).append(\"-\"); // 拼接第一个子串 // rule 1: 按k划分其他子串 while (length &gt; k) &#123; String newString = otherString.substring(0, k); otherString = otherString.substring(k); int upNums = 0; int lowNums = 0; for (int j = 0; j &lt; newString.length(); ++j) &#123; char ch = newString.charAt(j); if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; upNums++; &#125; else if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; lowNums++; &#125; &#125; // rule 2: 大小写转换 if (upNums &gt; lowNums) &#123; // 全部转换成大写 newString = newString.toUpperCase(); &#125; else if (lowNums &gt; upNums) &#123; // 全部转换成小写 newString = newString.toLowerCase(); &#125; // 拼接到后面 output.append(newString).append(\"-\"); // 长度减k length -= k; &#125; output.append(otherString); return output.toString(); &#125;&#125;","categories":[{"name":"华为机试题","slug":"华为机试题","permalink":"https://www.alankeene.com/categories/华为机试题/"}],"tags":[{"name":"String处理系列","slug":"String处理系列","permalink":"https://www.alankeene.com/tags/String处理系列/"}]},{"title":"SourceSet with name 'main' not found.","slug":"as-main-error","date":"2022-05-07T12:52:30.000Z","updated":"2022-05-07T13:18:42.781Z","comments":true,"path":"2022/0507/as-main-error.html","link":"","permalink":"https://www.alankeene.com/2022/0507/as-main-error.html","excerpt":"","text":"问题描述： Android Studio 上运行 main 方法报错： What went wrong:A problem occurred configuring project ‘:app’. Could not create task ‘:app:StringHandle.main()’. SourceSet with name &apos;main&apos; not found. 解决办法： 在.idea文件夹下的gradle.xml文件中添加，然后重新运行就可以了。","categories":[{"name":"使用AndroidStudio遇到的问题","slug":"使用AndroidStudio遇到的问题","permalink":"https://www.alankeene.com/categories/使用AndroidStudio遇到的问题/"}],"tags":[{"name":"main方法运行报错","slug":"main方法运行报错","permalink":"https://www.alankeene.com/tags/main方法运行报错/"}]},{"title":"动态规划系列(四)：LeetCode 300. Longest Increasing Subsequence(最长递增子序列)","slug":"longest-increasing-subsequence","date":"2022-05-06T16:56:54.000Z","updated":"2022-05-06T16:59:35.373Z","comments":true,"path":"2022/0507/longest-increasing-subsequence.html","link":"","permalink":"https://www.alankeene.com/2022/0507/longest-increasing-subsequence.html","excerpt":"","text":"题目描述： 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入： nums = [10,9,2,5,3,7,101,18]输出： 4解释： 最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入： nums = [0,1,0,3,2,3]输出： 4 示例 3： 输入： nums = [7,7,7,7,7,7,7]输出： 1 提示： 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104 题解：1234567891011121314151617181920212223242526272829303132/** * @Author AlanKeene * @Date 2022/05/07 * @Points DP */class Solution &#123; public int lengthOfLIS(int[] nums) &#123; // step 1: 初始化数组 int n = nums.length; int[] dp = new int[n]; // step 2: 初始值 dp[0] = 1; int maxLength = 1; // step 3: 计算顺序：从左到右 for (int i = 1; i &lt; n; ++i) &#123; // 默认值 dp[i] = 1; // step 4: 状态转移方程 // dp[i] = max(dp[j]) + 1 AND 0 &lt;= j &lt; i &amp;&amp; nums[i] &gt; nums[j] for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[j] + 1, dp[i]); &#125; &#125; maxLength = Math.max(dp[i], maxLength); &#125; return maxLength; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.alankeene.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.alankeene.com/tags/动态规划/"}]},{"title":"动态规划系列(三)：LeetCode 55. Jump Game(跳跃游戏)(用贪心算法优化时间复杂度)","slug":"jump-game-greedy","date":"2022-05-06T10:41:23.000Z","updated":"2022-05-06T10:43:54.706Z","comments":true,"path":"2022/0506/jump-game-greedy.html","link":"","permalink":"https://www.alankeene.com/2022/0506/jump-game-greedy.html","excerpt":"","text":"题目描述： 给定一个非负整数数组 nums ，你最初位于数组的第一个下标。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 输入： nums = [2,3,1,1,4]输出： true解释： 可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 输入： nums = [3,2,1,0,4]输出： false解释： 无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ，所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 3 * 10的四次方0 &lt;= nums[i] &lt;= 10的5次方 题解： 123456789101112131415161718192021/** * @Author AlanKeene * @Date 2022/05/06 * @Points Greedy */class Solution &#123; public boolean canJump(int[] nums) &#123; int farthest = 0; int n = nums.length; for (int i = 0; i &lt; n; ++i) &#123; // 能达到的最远距离小于i，说明不能往下跳了 if (farthest &lt; i) &#123; return false; &#125; farthest = Math.max(i + nums[i], farthest); &#125; return true; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.alankeene.com/categories/算法/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://www.alankeene.com/tags/贪心算法/"}]},{"title":"动态规划系列(三)：LeetCode 55. Jump Game(青蛙跳跃游戏)","slug":"jump-game","date":"2022-05-06T09:06:22.000Z","updated":"2022-05-06T09:08:27.077Z","comments":true,"path":"2022/0506/jump-game.html","link":"","permalink":"https://www.alankeene.com/2022/0506/jump-game.html","excerpt":"","text":"题目描述： 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 输入： nums = [2,3,1,1,4]输出： true解释： 可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 输入： nums = [3,2,1,0,4]输出： false解释： 无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ，所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 3 * 10的四次方0 &lt;= nums[i] &lt;= 10的5次方 题解： 1234567891011121314151617181920212223242526272829/** * @Author AlanKeene * @Date 2022/05/06 * @Points DP */class Solution &#123; public boolean canJump(int[] nums) &#123; // step 1: 初始化数组 boolean[] f = new boolean[nums.length]; // step2: 初始值 f[0] = true; // step3: 状态转移方程： f[j] = Or(0&lt;=i&lt;j) And f[i] &amp;&amp; i + nums[i] &gt;= j for (int j = 1; j &lt; nums.length; ++j) &#123; // 默认值 f[j] = false; for (int i = 0; i &lt; j; ++i) &#123; if (f[i] &amp;&amp; i + nums[i] &gt;= j) &#123; f[j] = true; break; &#125; &#125; &#125; // 返回最后一项 return f[nums.length - 1]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.alankeene.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.alankeene.com/tags/动态规划/"}]},{"title":"动态规划系列(二)：LeetCode 62. Unique Paths(不同路径)","slug":"unique-paths","date":"2022-05-06T08:15:29.000Z","updated":"2022-05-06T08:16:53.851Z","comments":true,"path":"2022/0506/unique-paths.html","link":"","permalink":"https://www.alankeene.com/2022/0506/unique-paths.html","excerpt":"","text":"题目描述： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 输入： m = 3, n = 7输出： 28 示例 2： 输入： m = 3, n = 2输出： 3解释： 从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向下 示例 3： 输入： m = 7, n = 3输出： 28 示例 4： 输入： m = 3, n = 3输出： 6 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 109 题解： 12345678910111213141516171819202122232425262728/** * @Author AlanKeene * @Date 2022/05/06 * @Points DP */class Solution &#123; public int uniquePaths(int m, int n) &#123; // step1: 初始化数组 int[][] f = new int[m][n]; // step2: 初始值：第一行和第一列都为1 for(int i = 0; i &lt; m; ++i) &#123; f[i][0] = 1; &#125; for(int j = 0; j &lt; n; ++j) &#123; f[0][j] = 1; &#125; // step3: 转移方程：f[i][j] = f[i][j-1] + f[i-1][j]; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; f[i][j] = f[i-1][j] + f[i][j-1]; &#125; &#125; return f[m-1][n-1]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.alankeene.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.alankeene.com/tags/动态规划/"}]},{"title":"动态规划系列(一)：LeetCode 322. Coin Change(零钱兑换)","slug":"coinchange","date":"2022-05-06T07:29:49.000Z","updated":"2022-05-06T09:09:16.560Z","comments":true,"path":"2022/0506/coinchange.html","link":"","permalink":"https://www.alankeene.com/2022/0506/coinchange.html","excerpt":"","text":"题目描述： 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 输入： coins = [1, 2, 5], amount = 11输出： 3解释： 11 = 5 + 5 + 1 示例 2： 输入： coins = [2], amount = 3输出： -1 示例 3： 输入： coins = [1], amount = 0输出： 0 提示： 1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 231 - 1 0 &lt;= amount &lt;= 104 题解： 1234567891011121314151617181920212223242526272829303132333435/** * @Author AlanKeene * @Date 2022/05/06 * @Points DP */class Solution &#123; // 动态规划 public int coinChange(int[] coins, int amount) &#123; // 1: 初始化 int[] f = new int[amount + 1]; // 2: 初始值 f[0] = 0; // 3: 计算顺序：从小到大 f[0],f[1],f[2],......,f[amount] for (int i = 1; i &lt;= amount; ++i) &#123; f[i] = Integer.MAX_VALUE; // 4: 转移方程 f[x] = min&#123;f[x - coins[0]] + 1,......,f[x - coins[coins.length -1]] + 1&#125; for (int j = 0; j &lt; coins.length; ++j) &#123; // 5: 处理边界条件 if ( i &gt;= coins[j] &amp;&amp; f[i - coins[j]] != Integer.MAX_VALUE) &#123; f[i] = Math.min(f[i - coins[j]] + 1, f[i]); &#125; &#125; &#125; // 返回 if(f[amount] == Integer.MAX_VALUE) &#123; return -1; // 没有组合返回-1 &#125; return f[amount]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.alankeene.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.alankeene.com/tags/动态规划/"}]},{"title":"华为机试题：出勤奖的判断","slug":"award","date":"2022-05-05T18:54:07.000Z","updated":"2022-05-05T18:59:07.089Z","comments":true,"path":"2022/0506/award.html","link":"","permalink":"https://www.alankeene.com/2022/0506/award.html","excerpt":"","text":"题目描述： 公司用一个字符串来标识员工的出勤信息。 absent: 缺勤 late: 迟到 leaveearly:早退 present: 正常上班 现需根据员工出勤信息,判断本次是否能获得出勤奖。 能获得出勤奖的条件如下： 缺勤不超过1次 没有连续的迟到/早退 任意连续7次考勤 缺勤/迟到/早退 不超过3次 输入描述： 用户的考勤数据字符串记录条数 &gt;=1，输入字符串长度 &lt;10000，不存在非法输入。 输出描述： 根据考勤数据字符串，如果能得到考勤奖输出true否则输出false。 示例： 输入： 2 present present present 输出： true true 输入： 2 present present absent present late present present present present leaveearly late present present 输出： true false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;import java.util.stream.Collectors;public class Award &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String s = canAward(n); System.out.println(s); &#125; public static String canAward(int n) &#123; Scanner sc = new Scanner(System.in); // 1：处理输入数据，转换成数组集合 ArrayList&lt;List&lt;String&gt;&gt; persons = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; String[] days = sc.nextLine().split(\" \"); List&lt;String&gt; list = Arrays.stream(days).collect(Collectors.toList()); persons.add(list); &#125; sc.close(); StringBuilder sb = new StringBuilder(); for (List&lt;String&gt; person : persons) &#123; // rule 1: 缺勤超过1次的次数统计 long absent = person.stream() .filter(x -&gt; x.equals(\"absent\")).count(); if (absent &gt; 1) &#123; sb.append(\"false\").append(\" \"); continue; &#125; // rule 2: 没有连续的迟到/早退 boolean flag = true; for (int i = 0; i &lt; person.size() - 1; ++i) &#123; // 遍历到倒数第二项即可 String cur = person.get(i); // 当天的考勤 String next = person.get(i + 1); // 第二天的考勤 if ((\"late\".equals(cur) || \"leaveearly\".equals(cur)) &amp;&amp; (\"late\".equals(next) || \"leaveearly\".equals(next))) &#123; flag = false; break; &#125; &#125; if (!flag) &#123; sb.append(flag).append(\" \"); continue; &#125; // rule 3: 任个意连续7天考勤 缺勤/迟到/早退 不能超过3次 for (int i = 0; i &lt; person.size() - 7; ++i) &#123; // 遍历到倒数第7项即可 List&lt;String&gt; days = new ArrayList&lt;&gt;(); // 连续7天的考勤记录 for (int j = 0; j &lt; 7; ++j) &#123; String day = person.get(i + j); days.add(day); &#125; // 分别统计缺勤/迟到/早退的次数 long absentCount = days.stream().filter(x -&gt; x.equals(\"absent\")).count(); long lateCount = days.stream().filter(x -&gt; x.equals(\"late\")).count(); long leaveEarlyCount = days.stream().filter(x -&gt; x.equals(\"leaveearly\")).count(); long count = absentCount + lateCount + leaveEarlyCount; if (count &gt; 3) &#123; flag = false; break; &#125; &#125; if (!flag) &#123; sb.append(flag).append(\" \"); continue; &#125; else &#123; // 能拿出勤奖的人 sb.append(flag).append(\" \"); &#125; &#125; return sb.toString(); &#125;&#125;","categories":[{"name":"华为机试","slug":"华为机试","permalink":"https://www.alankeene.com/categories/华为机试/"}],"tags":[{"name":"华为机试","slug":"华为机试","permalink":"https://www.alankeene.com/tags/华为机试/"}]},{"title":"Git修改远程仓库地址","slug":"git-modify-remote-url","date":"2022-04-02T18:19:02.000Z","updated":"2022-04-02T18:20:17.253Z","comments":true,"path":"2022/0403/git-modify-remote-url.html","link":"","permalink":"https://www.alankeene.com/2022/0403/git-modify-remote-url.html","excerpt":"","text":"问题描述：今天push hexo 源代码到 coding 上时，报错说： atal: unable to access ‘https://git.dev.tencent.com/AlanKeene/hexo.git/&#39;: Couldn’t connect to server 猜测是 Coding 的地址又改了，登上 Coding 一看，果然没错。把仓库地址修改过来就好了。 修改本地仓库关联的远程仓库地址 进入项目的 **/.git 文件夹， （是个隐藏文件夹） 找到 config 配置文件，修改关联的远程仓库地址，如下图：修改完，git push 就能成功部署了。 也可以用git命令查看本地所关联的远程仓库地址 git remote -v","categories":[{"name":"Git","slug":"Git","permalink":"https://www.alankeene.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.alankeene.com/tags/Git/"}]},{"title":"Jetpack寻英贴发起，寻找50名Jetpack爱好者","slug":"Jetpack","date":"2021-07-05T01:48:23.000Z","updated":"2021-07-13T12:41:44.599Z","comments":true,"path":"2021/0705/Jetpack.html","link":"","permalink":"https://www.alankeene.com/2021/0705/Jetpack.html","excerpt":"","text":"01 — Jetpack 寻英贴 02 — 背景1. Jetpack 的出现缘由和价值熟悉 Jetpack 的开发者都知道，Jetpack 是 Google 为了解决我们在 Android 日常开发中遇到的一些痛点而推出的一套组件。比如： 为了解决因为屏幕旋转等配置变化引起 Activity 销毁重建而引发的数据丢失或崩溃问题，推出了 Lifecycle 组件。 为了解决依赖注入 Dagger 框架使用技术门槛高的问题，推出了 Hilt。 为了解决后台任务管理的问题，推出了 WorkManager。 为了解决SQLite数据库使用便利性和门槛的问题，推出了ORM框架 Room，代替 GreenDao。 为了解决 Fragment 之间导航的问题，推出了 Navigation。 为了解决传统 MVC、MVP 模式下 UI 更新和数据源之间的同步问题，推出了 Databinding+Viewmodel+Livedata的 MVVM 架构模式，可以很方便的实现双向绑定和动态更新。 Kotlin 协程与架构组件一起使用，进一步简化了我们异步任务的处理。 Jetpack 出现的主要意义有两个： 简化 Android 开发者的工作，让开发者更方便、成本更低的构建应用。 通过一些推荐的、标准化的做法，便于构建优质的应用。 为了介绍和推广 Jetpack 的使用，Google 官方还推出了将这些架构组件组合在一起使用的 Demo 应用 Sunflower，Jetpack 相关的官方技术文档现在也比较完善了。比如官方推荐的应用架构如下图： 2. 那我们还有必要做什么吗？但是，有一点比较有意思的是，「通常官方的东西在实际的工程实践中，都会有一些特定的需求没法很好的满足」。 为了解决这些痛点，有些开发者就会去造一些很好用的轮子开源出来，然后 Google 慢慢吸收一些好的设计，融进自己的体系中，推出官方的解决方案。这也很正常，也算软件开发中常见的情况。比如 okhttp、ButterKnife、GreenDao、Dagger，都是这么过来的，Google 也在不断的迭代和优化。 那这次的 Jetpack 也一样，最近我在项目中使用 Room 和 WorkManager 的时候就遇到了一些问题和一些疑惑。也是直接导致这篇文章和这个活动产生的原因。 3. 我和 Jetpack 的结缘我开始知道 Jetpack 和 Kotlin 还算是比较早的，前几年也参加过几次深圳线下官方推广 Jetpack 和 Kotlin 的技术论坛，有幸见到了 Kotlin 语言的技术布道师 Hadi Hariri，有过短暂的交流。但是一直也没有很深的研究，更多处于了解和关注它的演进的层面。 由于各种历史原因，我们的项目也没有使用 Kotlin 来写，直到去年底才重构成 Kotlin 版本。做技术的朋友都知道，了解理论和真正在项目中用过，理解层面的深度差异还是挺大的。 最近新开了个项目，完全用标准的 MVVM、Kotlin、Jetpack 来构建，我才真正得到了一些很好的锻炼，也引发了一些思考和更深入的探索。 4. 我目前碰到的问题 1) 我在使用 Room 中遇到的问题 但是，Room 也有很多先进的设计，比如不能在主线程执行操作，在主线程执行操作运行时会崩溃；还有写 SQL 语句时如果写的不对编译时就能报错。使用 Room 确实比直接用 SQLite 高效多了，需要写的代码也少了很多。 2）我在使用 WorkManager 和看官网文档时遇到的一些疑惑和问题 03 — 我们想做些什么？很显然，Google 官方的方案也不是全能的，它可能是从各个渠道收集来的一些痛点然后推出解决方案，但也不可能全都能覆盖，它也需要去迭代和优化。在工程实践中，面对复杂的需求场景，还是可能会有一些痛点没有得到很好地满足的。 也许是他们都没有想到或遇到过的场景，比如我们国家的互联网规模比较大，有好几个用户群体比较大的超级 APP，面临的场景和技术挑战也许是目前其他国家都没有遇到过的，这些过程中沉淀出来的技术方案也许是有指导价值的。 比如我们在跟 Android 系统限制斗智斗勇过程中沉淀出来的插件化技术，这个氛围要比国外的要好一些，也是一些需求场景推动下的产物。中国软件行业发展到今天，我们有一些领域是可以平等交流的了，也是可以进行一些技术输出的。 基于以上的原因，我们主要想探讨： Jetpack 组件的最佳实践，有什么优缺点，什么场景该用它，什么场景不能用它。（解决使用上的问题） 探究 Jetpack 的原理以及理论和工程实践之间的差距，有什么地方是设计得还不够友好的，或者是不能很好的满足需求场景的，是还可以优化的（解决优化的问题） 通过以上的探索，我们想沉淀出一些更有实用价值的最佳实践。 另外，一个人学技术是枯燥、低效、有限的，找一群志同道合的人一起学习，大家互相学习，所长互补，也是一件幸事。 如果能因缘际会帮助到更多遇到同类问题的人，那也挺好的。 最后，对 Jetpack 感兴趣也满足招募条件的 Android 开发者，欢迎联系我交流。（请备注明：Jetpack）","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://www.alankeene.com/categories/Jetpack/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"https://www.alankeene.com/tags/Jetpack/"}]},{"title":"聊聊华为鸿蒙发布会","slug":"HarmonyOS","date":"2021-06-09T02:31:33.000Z","updated":"2021-06-09T02:39:00.429Z","comments":true,"path":"2021/0609/HarmonyOS.html","link":"","permalink":"https://www.alankeene.com/2021/0609/HarmonyOS.html","excerpt":"","text":"今晚看了一小部分「2021 鸿蒙操作系统及华为全场景新品发布会」，作为一个在 AIOT 领域摸爬滚打快 4 年、目前也在做这方面工作的从业者，觉得还是可以聊一聊分享一下自己的看法。 其实 IOT 已经谈了好多年了，之前一直不温不火，甚至还有过一轮洗牌，有很多大大小小的企业杀进来然后又倒闭了，一直有两个主要的问题没有得到很好的解决： 1.让物体能方便地移动上网。 2.让物体能产生数据、并能进行数据传输、数据交换和交互。 但是，我们目前连第一个问题都没有得到很好的解决，更不用说第二个问题了。之前比较火的车联网，很多稍微老一点的车机都是需要连着手机上的热点才能上网的。还有很多智能家居设备，能上网，但是要么不是很便捷要么不能实现移动化，比如需要连着家里的 wifi，被限制在了一定的空间里面。 第一个问题更多不是技术上的问题，它更多的是一个商业上的问题。而第二个问题依赖于第一个问题的解决并且还考验资源整合能力才能很好的解决，第二个问题不是一般的公司都可以搞得好的。 第一个问题技术上的一个解决方案是 eSIM，我在 2019 年的时候了解过 eSIM，技术上其实比较成熟了，但商业上就没有那么简单，再加上市场用户习惯也还没形成，一直没有得到很广泛的推广和应用，只是在一些很小的场景里应用。 但是，这次发布会让我最惊喜的是 HUAWEI WATCH 3 可以把整个链条打通了，说明商业上是可以走通的，在我看来，这是 IOT 行业一次重大的进步。 而第二个问题，是离我们想象的万物智能互联世界最近的一环。前段时间的新闻：「大连某司机撞飞斑马线上的数人后逃逸，造成 4 死 3 伤」，那个视频我看了，真的很恐怖。 我当时在想，我们有没有办法可以避免类似的事故发生，红绿灯杆的报警器 + 摄像头就能做到。现在在国内稍微发达一点的城市，基础设施都发展得很不错了。像在深圳，摄像头到处都是，有很多十字路口的红绿灯杆也是带有报警系统的，可以通过摄像头检测异常超速的车辆然后提醒对应的报警系统进行报警提醒过马路的行人。但是就是缺乏设备之间的数据联动和沟通。当然我相信相关的从业人员也正在做一些这方面的事情，只是还没那么快。 大家别以为绿灯了我过马路就安全了，特定的社会环境下会产生一些特定的社会矛盾，酒驾的、有急事开飞车的、情绪突然激动或暴躁的、报复社会的、飙车的、新手司机、甚至现代人有很多近视的等等，我们没有办法控制外在的意外因素，但是可以注意自己的安全。 我看了那个视频之后现在走路都不敢玩手机了，过马路即使是绿灯，我也会等车子停定下来再走，走的时候还会不断左右两边看看有没有车辆冲过来。 最后，未来的世界会变得越来越好么？万物互联的世界会实现么？我相信会的，那是我们无数人共同努力的结果。","categories":[{"name":"我的商业思考","slug":"我的商业思考","permalink":"https://www.alankeene.com/categories/我的商业思考/"}],"tags":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://www.alankeene.com/tags/HarmonyOS/"},{"name":"华为鸿蒙发布会","slug":"华为鸿蒙发布会","permalink":"https://www.alankeene.com/tags/华为鸿蒙发布会/"}]},{"title":"分享一份app性能优化方案","slug":"performance-optimization","date":"2021-05-31T16:40:46.000Z","updated":"2021-06-01T04:08:22.583Z","comments":true,"path":"2021/0601/performance-optimization.html","link":"","permalink":"https://www.alankeene.com/2021/0601/performance-optimization.html","excerpt":"","text":"移动互联网的发展不知不觉已经十多年了，可以说，国内移动互联网的红利期已经过去了，现在是增量有限，存量厮杀，从争夺用户到争夺时长。不管是用户也好、企业也好，都对 App 的用户体验和性能提出了更高的要求。 然而，一个 App 产品在快速迭代的过程中总会也必然会留下一些技术债务，当一个 App 产品逐渐走向成熟、用户体量逐渐增多，也必然会面临一个问题：性能优化。 性能优化也成了移动开发工程师迈向高级工程师道路上一道避不开的坎，而这道坎，说实话门槛和学习成本还是挺高的。性能优化也是企业考察一个高级 Android 工程师技术水平的重要维度。 这是我在公司内部做技术分享时的一份 Android App 性能优化方案的知识图谱，拿出来分享给大家。希望从事 Android 开发的同行朋友们越做越精深，越走越远。也期待和大家多多交流探讨、互相学习进步。 做技术的我们，学习压力还是挺大的，好像一旦上了 “技术” 这艘贼船，就必须成为一个「终身学习者」。现在的时代背景下，初级移动开发人员也很 “卷”，但优秀的高级工程师又比较稀缺。但我觉得大家也没必要太过焦虑，找到适合自己的终身学习的方式以及那些中短期内不太会变的底层逻辑、跟随时代跳动的频率，去不断地迭代演进自己就好了。 希望热爱技术的我们，都能拥有一个更加美好的技术人生。 可能涉及的内容比较多，原图有点大，上传之后就模糊看不太清了，需要原图的可以关注公众号，回复「app性能优化方案」去下载原图。 涉及到的模块如下图，内容全部展开之后就是上图了。","categories":[{"name":"我的技术人生","slug":"我的技术人生","permalink":"https://www.alankeene.com/categories/我的技术人生/"}],"tags":[{"name":"app性能优化","slug":"app性能优化","permalink":"https://www.alankeene.com/tags/app性能优化/"},{"name":"我的技术人生","slug":"我的技术人生","permalink":"https://www.alankeene.com/tags/我的技术人生/"}]},{"title":"聊聊关于「造车热」的思考","slug":"intelligent-electric-vehicle","date":"2021-05-31T15:46:29.000Z","updated":"2021-05-31T15:59:17.966Z","comments":true,"path":"2021/0531/intelligent-electric-vehicle.html","link":"","permalink":"https://www.alankeene.com/2021/0531/intelligent-electric-vehicle.html","excerpt":"","text":"1. 大厂纷纷宣布造车「极狐联合华为自动驾驶辅助系统发布阿尔法 S 车型并在上海车展亮相」这一事件把「造车热」推向了高潮。之前在调研、观望的一些大厂，近期也纷纷宣布进场。 不仅是互联网科技型大厂，做手机、做家电的大厂也纷纷宣布要造车。 宣布造车的企业 宣布造车的时间 百度 2021.1.11 小米 2021.3.30 滴滴 2021.4.6 创维 2021.4.27 OPPO 2021.4.28 360 2021.5.10 2. 假如我是企业的老板，我会怎么决策？大势所趋，我觉得「要造车」的想法甚至决策是合理的。如果是我，我也会产生这样的想法和决策，我会选择主动拥抱趋势，毕竟谁也不想被时代抛弃。 曾经的手机巨头诺基亚，一眨眼跟不上说洗掉就洗掉了；曾经的 PC 王者百度，在移动互联网时代稍微不留神没跟上，结果后面耗费了很大的力气和资金也没能找补回来，现在就很被动，当想做一些事情的时候，发现这也打不通那也打不通。 3 年前，2018 年初，当时百度度秘事业部刚成立 1 年，才刚刚小有成绩，真正做自动驾驶的落地也没多久，当时我写过一句话描述百度：在移动互联网时代铩羽而归的 PC 王者，能否再打造一个移动物联时代的超级入口？现在回过头来看，3 年过去了，这句描述依然适用，百度依然被困在一个局里。 时代车轮滚滚，残酷而真实。但是如何做得成功以及如何能坚持打到最后并看到曙光又是另一个探讨维度的事情了。 假如我是一位功成名就的企业家，比如马老师、雷老师，如果仅仅出于个人的考虑，我可能不会披荆斩棘再出发，我可能更会选择享受生活去了。但是一旦到了一定程度，你的所有决策都不再仅仅涉及到个人，背后是几万员工、几万个家庭、还有很多用户，这都是一个个实实在在的人。有些事不是「想做」，而是「要做」、「不得不做」。 做手机、做家电的大厂宣布要造车，也很好理解，从产品形态上来看，智能车无非就是一个尺寸更大的移动智能终端，虽然它的生产过程会复杂很多，但跟智能手机、智能电视本质上是相似的。 手机做的不是很成功的 360，自然雄心未泯，红衣教主说：雷军能干，我也可以。 如果它是下一个争夺的时代战场的话，那么大厂们进场抢滩掠地的渴望和迫切是不言而喻的。接下来也许还会有一些企业进场或者观望。 百舸争流，千帆竞发，接下来我们可能会看到的是「百车大战」的江湖，一如「百团大战」、「O2O大战」、「千播大战」、「共享单车大战」那样，杀到最后剩下那么 2～3 家能被广大用户所熟知和青睐。 或许还有一些比较有意思的话题可以探讨，比如：面对互联网大厂的杀来，造车新势力们、传统车企们该如何守住市场？ 3. 对“势”的理解在“势”的面前，个体的力量是很渺小的，能够通过个体的力量改变人类历史进程的伟人是极少数的。不管是主动拥抱还是被动裹挟，我们好像只有「了解“势”的必然性、找到顺应方式或对冲方式」这一条路。 历史比较有意思的一点是：很多规律，会不断地上演。 滚滚长江东逝水， 浪花淘尽英雄。是非成败转头空。青山依旧在， 几度夕阳红。白发渔樵江渚上， 惯看秋月春风。一壶浊酒喜相逢。古今多少事， 都付笑谈中。","categories":[{"name":"我的商业思考","slug":"我的商业思考","permalink":"https://www.alankeene.com/categories/我的商业思考/"}],"tags":[{"name":"造车","slug":"造车","permalink":"https://www.alankeene.com/tags/造车/"}]},{"title":"关于产品经理和程序员","slug":"pm-and-coder","date":"2021-05-31T14:18:42.000Z","updated":"2021-05-31T15:33:47.156Z","comments":true,"path":"2021/0531/pm-and-coder.html","link":"","permalink":"https://www.alankeene.com/2021/0531/pm-and-coder.html","excerpt":"","text":"一直在思考: 一个可以写代码的产品经理的优势是什么？它有必要么？ 2021.05.22 在跑步的过程中终于憋出了一个目前还算比较认可的答案。 1. 说服力当达到一定高度，当前方是一片迷茫和未知，当你做的是探索性的产品的时候，当你的技术也不清楚你要的产品逻辑或者忽悠你说这个需求实现不了的时候，当你们也只能摸着石头往前探索的时候，你还可以通过技术性的语言描述、画流程图、画UML类图、写伪代码等技术性的语言把你的想法和产品逻辑呈现出来。如果实在不行，你还可以自己动手来写。 这种产品能力+技术能力的结合产生的说服力可能会强一些，这样在真实的企业工作环境中更容易说服你的团队跟着你往前走，不容易让你的探索因推动不了而中道崩殂。 2. 把控力如果对技术有一定的理解，在进行需求评估的时候，研发周期的安排、研发过程的管理、对产品演进节奏的把控可能会更准确一些。 另外，在团队协作的过程中沟通成本、协作成本会低一些，你的技术做出来的东西匹配你预期的概率会高一些，技术人员和产品经理之间因认知理解偏差导致干出来的活儿跟预期需求相差太大的概率会低一些，不至于要严重返工调整而导致项目进度 delay 严重，从而保障能按预期上线。 互联网产品的研发是一个综合性团队作战的大工程，在互联网产品的商业竞争中，同质化程度通常都比较高，有时候「快一步」就能决定很多东西。 3. 领导力因为你们在做的事情之前没有很好的经验可以复制或参考，很多事情和想法都是还没有得到成功验证的。 在一片混沌的探索环境下，你如何能保障带领项目组团队是往一个正确的方向在走？这个时候仅仅有产品能力是不够的。它考验对技术的理解、对产品的理解和对商业洞察的结合。 另外，在产品的业务演进过程中，可以带领你的技术团队做一些很好的甚至比较超前的技术尝试，让你的技术团队在实现产品功能，满足业务发展需求的同时，也能获得技术上的成长和成功。产品经理和程序员是有方法可以共赢的。 4. 通过技术手段做一些先验产品尝试通过技术手段，有能力去思考和实施一些先验产品尝试，以降低探索性产品的试错成本和对用户的影响，这在产品演进过程中是非常有价值的，特别是用户体量大的产品。 而这些 soft skills，是一个没有技术背景的产品经理不容易习得或者习得成本很高的。 同样的，一个优秀的工程型程序员如果仅仅关注技术实现也是不够的，还需要对产品、对商业有一定的理解，如果是研究型的程序员那就另说了。 一个优秀的产品经理不仅仅是一个产品经理，一个优秀的工程型程序员也不仅仅是一个程序员。 中国的互联网行业、软件行业已经度过了野蛮增长期，也度过了 copy 的时期，在接下来寻求高质量发展和持续性创新的过程中，希望我们能多一些优秀的产品经理和优秀的工程型程序员，为中国这个巨大的引擎提速增效，更快更好地走向复兴。","categories":[{"name":"我的产品思考","slug":"我的产品思考","permalink":"https://www.alankeene.com/categories/我的产品思考/"}],"tags":[{"name":"产品经理","slug":"产品经理","permalink":"https://www.alankeene.com/tags/产品经理/"},{"name":"程序员","slug":"程序员","permalink":"https://www.alankeene.com/tags/程序员/"}]},{"title":"hexo g -d 突然部署失败 ChildProcess.<anonymous> hexo/node_modules/hexo-util/lib/spawn.js:37:17","slug":"hexo-g-d-failed","date":"2020-12-07T11:54:19.000Z","updated":"2020-12-07T12:39:16.953Z","comments":true,"path":"2020/1207/hexo-g-d-failed.html","link":"","permalink":"https://www.alankeene.com/2020/1207/hexo-g-d-failed.html","excerpt":"","text":"前言前段时间忙于工作，有段时间没更新博客了，今天更新博客部署发现突然部署失败了。 刚开始根据报错信息，在网上搜索了一圈，各种答案都有，发现都不太准确，有的还说是git的版本问题要升到最新的git版本，为此我还升级了mac的系统和git的版本。但发现并不能解决问题。 最后，冷静下来分析报错的信息，突然有了方向，最后定位到是Coding 仓库的地址改变了导致的突然部署失败，也验证了自己的猜想是正确的。 我的博客是同时部署在 Github 和 Coding 上的，Coding 突然把仓库地址的规则改了，我也不知道，太坑了.. 原因分析思路分析问题的思路如下： 解决方法上 Coding 仓库上查看修改后的仓库地址，把 Coding 的部署地址修改过来就好了。Coding部署地址的配置地方在：hexo 文件夹根目录的 _config.yml 文件里。如下： 修改之后保存配置问题，重新 hexo g -d 生成并部署就可以部署成功了。问题解决。 至于博客源码仓库，我也是存放在Coding上的（之前Github还不支持私有仓库），不过上传博客源码的时候不用修改仓库目录， git push 的时候会自动重定向为Coding修改后的仓库地址。","categories":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://www.alankeene.com/categories/hexo博客/"}],"tags":[{"name":"hexo部署失败","slug":"hexo部署失败","permalink":"https://www.alankeene.com/tags/hexo部署失败/"}]},{"title":"mac zsh 配置 adb 环境变量 \"zsh command not found adb\"","slug":"command-not-found-adb","date":"2020-03-15T14:18:12.000Z","updated":"2020-03-15T14:27:31.822Z","comments":true,"path":"2020/0315/command-not-found-adb.html","link":"","permalink":"https://www.alankeene.com/2020/0315/command-not-found-adb.html","excerpt":"","text":"“zsh: command not found: adb” 的解决方法： 前提已经成功安装了 Android Studio. 打开 iTerm 终端依次输入下面命令：12echo 'export ANDROID_HOME=/Users/$USER/Library/Android/sdk' &gt;&gt; ~/.zshrcecho 'export PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools' &gt;&gt; ~/.zshrc 然后保存设置：1source ~/.zshrc 即可完成 adb 环境变量的配置。可通过 adb version 验证是否配置成功。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"adb","slug":"adb","permalink":"https://www.alankeene.com/tags/adb/"}]},{"title":"华强北复活","slug":"sz-huaqiangbei","date":"2019-11-30T15:31:19.000Z","updated":"2019-11-30T15:53:54.661Z","comments":true,"path":"2019/1130/sz-huaqiangbei.html","link":"","permalink":"https://www.alankeene.com/2019/1130/sz-huaqiangbei.html","excerpt":"","text":"","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"https://www.alankeene.com/categories/个人随笔/"}],"tags":[{"name":"华强北","slug":"华强北","permalink":"https://www.alankeene.com/tags/华强北/"}]},{"title":"探索CameraX (一) CameraX 是什么","slug":"cameraX-overview","date":"2019-07-09T07:49:07.000Z","updated":"2019-07-09T10:36:11.364Z","comments":true,"path":"2019/0709/cameraX-overview.html","link":"","permalink":"https://www.alankeene.com/2019/0709/cameraX-overview.html","excerpt":"","text":"前言Google 最近推出了 Jetpack 新组件：CameraX。 Google 官方的介绍：”CameraX is a Jetpack support library, built to help you make camera app development easier.” 很好地诠释了这个库诞生的初衷和用途：帮助相机APP开发者更简单更轻松地实现摄像头功能的开发。 这对于做 Camera 开发的工程师来说是个好消息。 CameraX 介绍在 Android 应用中要实现 Camera 功能还是比较困难的，为了保证在各品牌手机设备上的兼容性、响应速度等体验细节，Camera 应用的开发者往往需要花很大的时间和精力进行测试，甚至需要手动在数百种不同设备上进行测试。CameraX 正是为解决这个痛点而诞生的。 CameraX 是基于 Camera2 API 实现的，向后兼容到 Android 5.0（API Level 21）。 CameraX 的优势在于： CameraX 和 Lifecycle 结合在一起，方便开发者管理生命周期。且相比较 camera2 减少了大量样板代码的使用。 兼容至 Android L (API 21)，从而确保兼容到市面上绝大多数手机 开发者可以通过扩展的形式使用和原生摄像头应用同样的功能（如：人像、夜间模式、HDR、滤镜、美颜） Google 自己还打造了 CameraX 自动化测试实验室，对摄像头功能进行深度测试，确保能覆盖到更加广泛的设备。相当于 Google 帮我们把设备兼容测试工作给做了。 对于开发者来说，简单易用的 API、更少的模版代码、更强的兼容性，意味着更高的开发和测试效率。而丰富的扩展性则意味着开发者可以为用户们带来更多基于摄像头的光影体验。 特别注明：CameraX 目前处于 alpha 版本，Google 官方并不推荐在生产环境中使用。可能会有较多的bug，后期 API 也可能有变化。 现状据 Google 官方介绍说，目前已经有不少团队开始尝试使用 CameraX，并且带来了很不错的效果。包括：Camera360、TikTok、Snapchat、Twitter 等。 总结本文简要介绍了 CameraX 是什么，它的出现是为了解决现在的什么痛点以及它有什么优势。还介绍了目前有哪些团队正在采用和实践 CameraX。 期待 CameraX 能带来更多的新特性～ 参考CameraX overview 摄像头功能开发不再复杂，CameraX 助您轻松打造光影体验 Exploring CameraX on Android: Camera View Google Jetpack 新组件 CameraX 介绍与实践","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"CameraX","slug":"CameraX","permalink":"https://www.alankeene.com/tags/CameraX/"}]},{"title":"面试题：计算 n！阶乘的结果的末尾有几个0","slug":"calculate-zero-in-factorial","date":"2019-07-08T04:19:34.000Z","updated":"2019-07-08T09:30:28.303Z","comments":true,"path":"2019/0708/calculate-zero-in-factorial.html","link":"","permalink":"https://www.alankeene.com/2019/0708/calculate-zero-in-factorial.html","excerpt":"","text":"前言首先基于一个事实：我们不可能真的把 n! 的结果计算出来，再去数结果的末尾有几个0；n 很小还好，如果n很大，甚至趋近于无穷大，我们是不可能这样做的。原因主要有二： 一般计算机的计算能力和存储能力也有限，是计算不出那么大的数的。 即使计算机能算出来，这样做也很耗时，可能要算很久。 连计算机都算不出来，那我们怎么办呢？别慌，虽然我们不能直接算出结果，但我们可以把问题一步步拆解。 拆解思路首先，我们想什么情况下会产生一个0？ 诶，一个数乘以 10，在末尾就会多出一个 0。而 10 = 5 * 2。 一组数相乘的结果末尾有几个0，取决于这组数因式分解后有几对 5 和 2 的因子。 针对于 n! 这个题目，有这样一个事实：把相乘的数因式分解后，2 的个数肯定大于 5 的个数。 所以，这个问题可以拆解为：只要求出因式分解后有几个 5 的因子即可，5的个数即是末尾出现的0的个数。 解法一：直接法这种解法的思路是：直接将 n! 中的每个数，按照 5 来因式分解，最后把出现的 5 的个数加起来。 123456789101112131415public int calculateZeroInFactorial(int n) &#123; int count = 0; // 循环判断所有的乘数 for (int i = n; i &gt; 0; i++) &#123; if (i % 5 == 0) &#123; // 如果这个乘数可以对 5 进行因式分解，再看这个乘数可以分解出几个5 int a = i; while(a % 5 == 0) &#123; a = a / 5; count++; &#125; &#125; &#125; return count;&#125; 但是这种算法的时间复杂度为 O(nlog(n))，那有没有更快的算法呢？ 解法二： log(n) 解法分析： n! 这些乘数中，每隔 5 个数，肯定会有一个数至少能拆出一个 5 因子。所以 n / 5 = 至少会出现的 5 的个数。 上面说至少，因为 n / 5 并不能完全算出 5 因子的个数，比如若某个数 25 = 5 * 5，分解后得到的 5 也算一个，所以能被 25 因式分解相当于会出现 2 个 5 因子，而第一步中除以 5 算个数的时候已经算了一个了，所以相当于比之前会多一个 5 因子。 依此类推，能被 25 5 = 125 因式分解的相当于比之前按 25 因式分解的时候又多出一个 5 因子。能被 125 5 = 625 因式分解的相当于比按 125 因式分解时又多出一个 5 因子。还有 625 * 5 …… 所以，n! 的结果可以拆分为多少个 5 因子呢？ n/5 + n/25 + n /125 + n/625 + …. 比如 128！的阶乘的结果末尾有几个0呢？ 128/5 +128/25 + 128/125 = 25+5+1 = 31 个 又如：1247! 的阶乘的结果末尾有几个0呢？ 1247/5 + 1247/25 + 1247/125 + 1247/625 = 249+49+9+1 = 308 个 12345678public int calculateZeroInLogN(int n) &#123; int count = 0; while (n &gt; 0) &#123; count += n / 5; n /= 5; &#125; return count;&#125; 这种算法的时间复杂度为 O(log(n))，效率会高很多，而且仅需几行代码。","categories":[{"name":"面试题","slug":"面试题","permalink":"https://www.alankeene.com/categories/面试题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.alankeene.com/tags/算法/"}]},{"title":"解决 hexo d 提示：ssh_exchange_identification：read：Connection reset by peer 的问题","slug":"Connection-reset-by-peer","date":"2019-07-02T07:07:39.000Z","updated":"2019-07-02T08:56:46.278Z","comments":true,"path":"2019/0702/Connection-reset-by-peer.html","link":"","permalink":"https://www.alankeene.com/2019/0702/Connection-reset-by-peer.html","excerpt":"","text":"问题今天写完博客，用 hexo d 部署到 github，突然报了个错误： 12345Error: ssh_exchange_identification: read: Connection reset by peerfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决办法最后发现是上网环境导致的，因为现在在图书馆，连的是图书馆的 wifi，可能是图书馆的防火墙或者代理服务器导致不能连接到 github，换个上网网络就能 hexo d 提交了。 所以如果你的上网环境从家里换成公司或者其他公共场合，就要注意了，可能是提供网络的路由器或者机构的防火墙搞的鬼哦。 最后发现原来是被图书馆的 wifi 网络整蛊了之后，有点抓狂，在此记录一下问题以及解决问题的思路，希望对遇到同样问题的人有所帮助。 解决问题的思路过程咦，奇了怪了，前几天明明还好好的，突然就提交不了了，看日志大意是：SSH验证失败，连接被重置了。 看到 Please make sure you have the correct access rights and the repository exists. ，刚开始怀疑是不是远程仓库的密钥过期了，因为我之前遇到过密钥过期导致提交不上的情况，所以赶紧去远端仓库查看一下密钥的有效期限，发现并没有过期。排除这种可能。✖️ 会不会是 SSH 密钥的问题？去确认一下，远端仓库密钥没有更改过，回想一下最近本机也没有重新生成过 SSH key，所以这种可能也排除。✖️ 实在没有想到好的解决方法，OK，google，在 StackOverFlow 上发现说这种异常的连接重置，原因可能是：服务器进程退出时没有关闭连接，或者crash，或者防火墙或代理、或者负载平衡器干扰连接 导致的。 https://stackoverflow.com/a/27692498/9031185 OK，我确实开了代理，检查一下防火墙是否关闭，把代理也关了，重试还是没解决。也排除。✖️ 缩小关键字，继续搜索，搜索 hexo ssh_exchange_identification: read: Connection reset by peer ，最终搜索到了相关性更强的有价值的参考方案。 http://dtoucoin.com/2017/05/20/Github的Push操作后提示Connection-reset-by-peer问题解决方法/ 最后定位到：是图书馆 wifi 网络的防火墙或者代理服务器导致的连接不到 github。 总结 遇到让你感到莫名其妙的问题时，先要理清思路，其次要有耐心，逐个可能性去排除，逐步逼近真相，找到最后的成因。 在用搜索引擎搜索解决方案时，要注意先想好跟问题相关性较强的关键词，否则会搜出很多相关性很弱的答案，既混淆你的思路和判断，又耗费你很多时间。 遇到之前能正常工作，突然就不能正常工作了这类问题时，要重点从对比前后的 变量 入手，看现象出现前和现在相比，哪些因素发生了变化？哪些环境发生了变化？通常都是某个特定的因素变化了，而导致的现在的现象。","categories":[{"name":"日常解决问题集锦","slug":"日常解决问题集锦","permalink":"https://www.alankeene.com/categories/日常解决问题集锦/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.alankeene.com/tags/hexo/"}]},{"title":"面试题：寻找一个字符串中出现次数最多的字符以及出现的次数","slug":"Find-char-appear-more-frequently-in-String","date":"2019-06-19T12:00:29.000Z","updated":"2019-06-20T07:15:06.633Z","comments":true,"path":"2019/0619/Find-char-appear-more-frequently-in-String.html","link":"","permalink":"https://www.alankeene.com/2019/0619/Find-char-appear-more-frequently-in-String.html","excerpt":"","text":"解法一：用删除法实现 (挺巧妙的一种)12345678910111213141516171819202122232425262728public class FindTheMostAppearChar &#123; public static void main(String[] args) &#123; deleteMethodToAchieve(); &#125; /** * 用删除法实现 （挺巧妙的） * 解题思路：每次取出字符串的第一个字符，将字符串中与第一个字符相同的字符全部删掉， * 然后通过计算删除前后字符串的长度来确定该字符在字符串出现的次数，最终比较出出现次数最多的字符 */ public static void deleteMethodToAchieve() &#123; Scanner scanner = new Scanner(System.in); String string = scanner.nextLine().trim(); scanner.close(); int max_length = 0; String max_str = \"\"; while (string.length() &gt; 0) &#123; String firstChar = string.substring(0,1); int length = string.length(); string = string.replaceAll(firstChar, \"\"); if (length - string.length() &gt; max_length) &#123; max_length = length - string.length(); max_str = firstChar; &#125; &#125; System.out.println(\"出现次数最多的字符是：\" + max_str + \"，出现的次数：\" + max_length); &#125;&#125; 解法二：用查找法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class FindTheMostAppearChar &#123; public static void main(String[] args) &#123; hashMapMethodToAchieve(); &#125; /** * 用字符数组查找法实现 * 解题思路：先将字符串拆分成字符数组，然后转存到 HashMap 集合中， * 该集合的key为字符串中出现的字符，value为对应字符串出现的次数。 * 最后只需要在HashMap集合中找到Value值最大的key即可。 */ public static void hashMapMethodToAchieve() &#123; Scanner scanner = new Scanner(System.in); String string = scanner.nextLine().trim(); scanner.close(); // 将字符串转换成字符数组 char[] arr = string.toCharArray(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // key为出现的字符，value 为该字符出现的次数，将字符数组转存在 HashMap 中 if (arr != null &amp;&amp; arr.length &gt; 0) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; if (map.get(arr[i]) != null) &#123; // 若不为空，说明已经存在相同的字符，则 value 值在原来的基础上加1 map.put(arr[i],map.get(arr[i]) + 1); &#125; else &#123; map.put(arr[i], 1); &#125; &#125; &#125; // 查找出出现次数最多的字符以及出现的次数也有多种写法 FindTheMostCharByMap(map); // 查找写法一：用 Iterator 遍历 Map 来查找 // FindTheMostCharByMapEntry(map); // 查找写法二：用 Map.Entry 提高效率 // FindTheMostCharByForLoop(map, arr); // 查找写法三：直接用 for 循环来遍历查找 &#125; // 查找写法一：用 Iterator 遍历 Map 来查找 public statice void FindTheMostCharByMap(Map&lt;Character, Integer&gt; map) &#123; Set&lt;Character&gt; keys = map.keySet(); // 获取所有的key Iterator iterator = keys.iterator(); // 实例化 Iterator Character maxKey = (Character) iterator.next(); //定义第一个为最大的value和对应的key int maxValue = map.get(maxKey); while (iterator.hasNext()) &#123; Character temp = (Character) iterator.next(); if (maxValue &lt; map.get(temp)) &#123; maxKey = temp; maxValue = map.get(temp); &#125; &#125; System.out.println(\"出现次数最多的字符是：\" + maxKey + \", 出现的次数：\" + maxValue); &#125; // 查找写法二：用 Map.Entry 提高效率 public static void FindTheMostCharByMapEntry(Map&lt;Character, Integer&gt; map) &#123; Iterator iterator = map.entrySet().iterator(); Map.Entry entry = (Map.Entry) iterator.next(); char maxKey = (char) entry.getKey(); // 获取key int maxValue = (int) entry.getValue(); // 获取value while (iterator.hasNext()) &#123; entry = (Map.Entry) iterator.next(); char tempKey = (char) entry.getKey(); int tempValue = (int) entry.getValue(); if (maxValue &lt; tempValue) &#123; maxKey = tempKey; maxValue = tempValue; &#125; &#125; System.out.println(\"出现次数最多的字符是：\" + maxKey + \", 出现的次数：\" + maxValue); &#125; // 查找写法三：直接用 for 循环来遍历查找 public static void FindTheMostCharByForLoop(Map&lt;Character, Integer&gt; map, char[] arr) &#123; int maxValue = map.get(arr[0]); char maxKey = ' '; for (int i = 0; i &lt; arr.length; i++) &#123; if (maxValue &lt; map.get(arr[i])) &#123; maxValue = map.get(arr[i]); maxKey = arr[i]; &#125; &#125; System.out.println(\"出现次数最多的字符是：\" + maxKey + \", 出现的次数：\" + maxValue); &#125; &#125; 解法三：排序法实现12345678910111213141516171819202122232425262728293031323334public class FindTheMostAppearChar &#123; public static void main(String[] args) &#123; sortMethodToAchieve(); &#125; /** * 用排序法实现 * 解题思路：先将字符串转换成字符数组，然后对字符数组进行排序， * 统计每个字符重复出现的次数，最后比较得出出现次数最多的字符以及出现次数 */ public static void sortMethodToAchieve() &#123; Scanner scanner = new Scanner(System.in); String string = scanner.nextLine().trim(); scanner.close(); char[] arr = string.toCharArray(); Arrays.sort(arr); // 对数组进行排序 char maxValue = 'a'; // 记录出现次数最多的元素 int maxCount = 0; // 记录出现次数 int count = 1; for (int i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] == arr[i+1]) &#123; count++; &#125; if (arr[i] != arr[i+1]) &#123; if (count &gt; maxCount) &#123; maxCount = count; maxValue = arr[i]; &#125; count = 1; &#125; &#125; System.out.println(\"出现次数最多的字符是：\" + maxValue + \", 出现的次数：\" + maxCount); &#125;&#125;","categories":[{"name":"面试题","slug":"面试题","permalink":"https://www.alankeene.com/categories/面试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://www.alankeene.com/tags/面试题/"},{"name":"字符串查找","slug":"字符串查找","permalink":"https://www.alankeene.com/tags/字符串查找/"}]},{"title":"Android 事件分发过程源码阅读总结","slug":"view-dispatch-process","date":"2019-03-08T09:17:53.000Z","updated":"2020-12-20T05:52:39.170Z","comments":true,"path":"2019/0308/view-dispatch-process.html","link":"","permalink":"https://www.alankeene.com/2019/0308/view-dispatch-process.html","excerpt":"Android 事件分发过程的源码主要分为四大过程： Activity 对点击事件的处理过程 Window 对点击事件的处理过程 顶级 ViewGroup 对点击事件的处理过程 View 对点击事件的处理过程","text":"Android 事件分发过程的源码主要分为四大过程： Activity 对点击事件的处理过程 Window 对点击事件的处理过程 顶级 ViewGroup 对点击事件的处理过程 View 对点击事件的处理过程 Activity 对点击事件的处理过程当一个点击事件产生后，事件先传递给当前的 Activity，由 Activity 的 dispatchTouchEvent 方法进行事件派发。在内部具体的工作是由 Window 来完成的，Activity 将事件传递给了 Window。 1234567891011public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow.superDispatchTouchEvent(ev)) &#123; // 若 getWindow.superDispatchTouchEvent(ev) 返回true，则说明事件被 Window 处理了，整个事件就结束了 return true; &#125; // 若 getWindow.superDispatchTouchEvent(ev) 返回 false，则说明事件没人处理，会调用Activity的onTouchEvent 方法处理 return onTouchEvent(ev);&#125; Window 对点击事件的处理过程Window 是个抽象类，它的唯一实现类是 PhoneWindow，PhoneWindow 通过 superDispatchTouchEvent 方法内部调用 DecorView 的 superDispatchTouchEvent 方法将事件传递给 DecorView。由于 DecorView 继承自 FrameLayout，它是我们 Activity 布局的容器，是顶级的父 View，所以最终事件会传递给顶级的根 View，即我们通过 setContentView 设置的 View，一般来说都是 ViewGroup。 123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); // PhoneWindow 将事件传递给 DecorView&#125; 顶级 ViewGroup 对点击事件的处理过程ViewGroup 接收到事件后的处理过程主要分为两大部分： ViewGroup 对 ACTION_DOWN 事件的处理过程 ViewGroup 对非 ACTION_DOWN 事件的处理过程 ViewGroup 对 ACTION_DOWN 事件的处理过程 ViewGroup 先判断是否是 ACTION_DOWN 事件，如果是 DOWN 事件，则将 target 置空，接下来会调用 ViewGroup 的 onInterceptTouchEvent 方法判断 ViewGroup 是否要拦截这个事件，如果拦截，则后续的 ACTION_MOVE、ACTION_UP 都由 ViewGroup 处理，不会传递给子 View，并且 ViewGroup 的 onInterceptTouchEvent 不会再被调用。(因为ViewGroup已经知道自己要拦截这次事件了，就不需要再次判断了) 如 ViewGroup 的 onInterceptTouchEvent 返回 false，则表示 ViewGroup 不拦截此次 DOWN 事件，接下来会调用子 View 的 dispatchTouchEvent 方法继续往下分发，如果子 View 处理该事件，则将子 View 标记为处理该事件的 target，并且子 View 的 dispatchTouchEvent 方法返回 true。如果子 View 也不处理，则调用 super.dispatchTouchEvent 方法往上返回给父 View。 ViewGroup 对非 ACTION_DOWN 事件的处理过程 先判断有无 target(即 target 是否为空)，如果 target 为空，则 ViewGroup 的 dispatchTouchEvent 方法返回 true，说明 ViewGroup 处理后续所有的非 DOWN 事件。 如果 target 不为空，则判断 disallowIntercept 禁止拦截标志，如果 disallowIntercept = true，说明子 View 设置了 FLAG_DISALLOW_INTERCEPT 标志禁止 ViewGroup 拦截非 DOWN 事件(当然前提是 ViewGroup 不拦截 DOWN 事件)，则会调用 target.dispatchTouchEvent 方法，交给子 View 去往下分发。 如果 disallowIntercept = false，说明子 View 不禁止 ViewGroup 去拦截非 DOWN 事件，则 ViewGroup 会调用自己的 onInterceptTouchEvent 方法进一步判断自己是否需要拦截。 如果 ViewGroup 拦截说明 ViewGroup 要拦截此次非 DOWN 事件，则会将 target 置空，ViewGroup 的 onInterceptTouchEvent 方法返回 true，后续的事件都会交给 ViewGroup 去处理，不会传给子 View，onInterceptTouchEvent 也不会再次调用。 如果 ViewGroup 不拦截，则会调用 target.dispatchTouchEvent 方法继续往下分发，由 target.dispatchTouchEvent 方法确定返回值。 View 对事件的处理过程 如果子 View 不处理事件，则会调用 super.dispatchTouchEvent 方法将事件往回传给父 View。 如果子 View 处理该事件，则会先判断是否设置了 onTouchListener 监听器，如果设置了 onTouchListener，则会回调其 onTouch 方法，并且 onTouchEvent 方法将不会被调用。 如果没设置 onTouchListener，则会调用 onTouchEvent 方法，在 onTouchEvent 方法内部会判断是否设置了 onClickListener 监听器，如果设置了则会回调 onClickListener 的 onClick 方法。 推荐阅读： Android事件分发机制的一些基本知识","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/tags/Android/"},{"name":"事件分发","slug":"事件分发","permalink":"https://www.alankeene.com/tags/事件分发/"}]},{"title":"Android事件分发机制的一些基本知识","slug":"view-dispatch-basic-knowledge","date":"2019-03-08T08:02:47.000Z","updated":"2020-12-20T05:52:44.845Z","comments":true,"path":"2019/0308/view-dispatch-basic-knowledge.html","link":"","permalink":"https://www.alankeene.com/2019/0308/view-dispatch-basic-knowledge.html","excerpt":"有一种学得快的方法，就是不要一次学太多。 什么是View的事件分发在 Android 中，用户的在屏幕上的点击事件被抽象成 MotionEvent 这个类，点击事件的类型中比较重要的有 ACTION_DOWN、ACTION_MOVE、ACTION_UP 三种类型。当一个 MotionEvent 事件产生后，系统 需要把这个事件传递给一个具体的 View 来处理，而 MotionEvent 的这个分发过程，就叫 View 的事件分发过程。","text":"有一种学得快的方法，就是不要一次学太多。 什么是View的事件分发在 Android 中，用户的在屏幕上的点击事件被抽象成 MotionEvent 这个类，点击事件的类型中比较重要的有 ACTION_DOWN、ACTION_MOVE、ACTION_UP 三种类型。当一个 MotionEvent 事件产生后，系统 需要把这个事件传递给一个具体的 View 来处理，而 MotionEvent 的这个分发过程，就叫 View 的事件分发过程。 点击事件分发过程中有几个重要方法？他们之间的关系是怎么的？有三个重要的方法： dispatchTouchEvent 、onInterceptTouchEvent、onTouchEvent 。 他们之间的关系即代表了 View 的分发规则，用下面一段伪代码来表示会比较清晰： 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 开始分发该事件 boolean consume = false; // 事件是否消费 if (onInterceptTouchEvent(ev)) &#123; // 父View是否拦截该事件 consume = onTouchEvent(ev); // 父View处理该事件，判断是否要消费 &#125; else &#123; consume = child.dispatchTouchEvent(ev); // 交给子View，继续往下分发。 &#125; return consume; // 返回值表示是否消费当前事件&#125; 下面对这三个方法的作用进一步描述： dispatchTouchEvent：用来进行事件的分发，返回结果受当前 View 的 onTouchEvent 方法和下级 View 的 dispatchTouchEvent 方法决定，表示是否消费当前事件。此方法在事件传递给当前 View 时调用。 onInterceptTouchEvent：用来判断是否拦截某个事件。如果当前 View 拦截了某个事件，那么同一事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。此方法在 dispatchTouchEvent 方法中被调用。 onTouchEvent：用来处理点击事件，返回结果表示是否消费当前的事件，如果不消费，则在同一事件序列中，当前 View 无法再次接收到事件。此方法在 dispatchTouchEvent 方法中被调用。 事件分发机制这里说的事件分发机制是指从 ViewGroup 开始的事件分发机制，我们平时说的 View 的事件分发机制也是指从 ViewGroup 开始的事件分发机制。 点击事件的传递过程点击事件的传递过程： Activity —&gt; Window —&gt; View 即事件总是先传递给 Activity，Activity 再传递给 Window，Window 再传递给顶级 View，顶级 View (如 DecorView) 接收到事件后，就会按照事件分发机制去分发事件，找到需要消费当前事件的消费者。 事件分发机制对于一个根 ViewGroup 来说，当点击事件产生后，首先会传递给它，这时它的 dispatchTouchEvent 方法会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true，就表示它要拦截当前事件，接着事件就会交给 ViewGroup 来处理，这时它的 onTouchEvent 方法会被调用。 如果 ViewGroup 的 onInterceptTouchEvent 方法返回 false，就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 dispatchTouchEvent 方法就会被调用，如此反复直到事件被最终处理。 一个 View 是如何处理点击事件的？它会首先判断是否设置了 onTouchListener，如果设置了则会回调 onTouchListener 的 onTouch 方法，这时事件如何处理要看 onTouch 方法的返回值。如果 onTouch 方法返回 true，表示 onTouch 方法要处理这个事件，则 onTouchEvent 将不会再被调用；如果 onTouch 方法返回 false，表示 onTouch 方法不处理这个事件，则 onTouchEvent 方法会被调用。 在 onTouchEvent 方法中，如果当前设置的监听器中有 onClickListener，那么 onClickListener 的 onClick 方法会被回调。 调用优先级：onTouchListener &gt; onTouchEvent &gt; onClickListener","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/tags/Android/"},{"name":"事件分发","slug":"事件分发","permalink":"https://www.alankeene.com/tags/事件分发/"}]},{"title":"Java8 和 Java9 的主要新特性","slug":"java-new-features","date":"2019-03-04T02:42:13.000Z","updated":"2019-03-04T03:32:32.563Z","comments":true,"path":"2019/0304/java-new-features.html","link":"","permalink":"https://www.alankeene.com/2019/0304/java-new-features.html","excerpt":"","text":"Java 8 的主要新特性1.Lambda 表达式Lambda 允许把函数作为一个方法的参数传递进方法中。 作用：解决 Java 被诟病的匿名内部类的问题。 2.接口中可增加了默认方法作用：在接口中也可以有实现方法了。 3.HashMap 底层数据结构的变化java 8 之前，HashMap 底层的数据结构是数组+链表实现的， Java 8 之后是数组+链表+红黑树实现的，当链表的长度超过 8 之后，会转换成红黑树。 作用：解决因哈希冲突导致的链表过长，查询效率低的问题。 4.Stream API新添加 Stream API (java.util.stream)，把真正函数式编程的风格引入 Java。 5.提供一个新的 JavaScript 引擎Java 8 提供了一个新的 Nashorn JavaScript 引擎，它允许在 JVM 上运行特定的 JavaScript 应用。 作用：解决日益增长的 Java 跟 JS 交互混合的需求。 Java 9 新特性1.模块系统模块是一个包的容器，Java 9 最大的变化之一是引入模块系统。（Jigsaw 项目） 作用：解决大型项目模块化开发的需求。 2.支持 HTTP/2 标准HTTP/2 标准是 HTTP 协议的最新版本，新的 HTTPClient API 支持 Websocket 和 HTTP2 流以及服务器推送特性。 3.提供创建不可变集合的静态工厂方法List、Set、Map 接口中，提供新的静态工厂方法直接创建不可变的集合实例。 作用：创建不可变集合更方便，一行代码就搞定，节省了开销。 4.私有接口方法在接口中也允许编写 private 修饰的私有方法了。 作用：增强了接口的功能，提高了可扩展性。 5.轻量级的 JSON API内置了一个轻量级的 JSON API。 6.引入响应式流 APIJava 9 引入了新的响应式流 API。 作用：支持响应式编程的需求。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.alankeene.com/categories/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://www.alankeene.com/tags/Java8/"},{"name":"Java9","slug":"Java9","permalink":"https://www.alankeene.com/tags/Java9/"}]},{"title":"Window 的添加过程","slug":"add-window-process","date":"2019-03-03T10:02:53.000Z","updated":"2020-12-20T05:51:47.921Z","comments":true,"path":"2019/0303/add-window-process.html","link":"","permalink":"https://www.alankeene.com/2019/0303/add-window-process.html","excerpt":"Window 的添加过程Window(或者说View) 是怎么添加到 Android 系统中然后展示给用户的？让我们来探索一下 Window 的添加过程。","text":"Window 的添加过程Window(或者说View) 是怎么添加到 Android 系统中然后展示给用户的？让我们来探索一下 Window 的添加过程。 Window 添加过程的入口方法要探索添加的过程，必须先在源代码中找到添加 Window 的入口方法。 Window 的添加需要通过 WindowManager 的 addView 方法实现，但 WindowManager 是个接口，它的真正实现类是 WindowManagerImpl 类，但 WindowManagerImpl 也并没有直接实现对 Window 的添加、删除、更新操作，而是通过桥接模式将所有操作委托给 WindowManagerGlobal 去实现。最终会调用 WindowManagerGlobal 类的 addView 方法真正开启 View 的添加过程。 所有，Window 添加过程的真正入口方法实际上是 WindowManagerGlobal 类的 addView 方法。 Window 添加过程的主要流程WindowManagerGlobal 的 addView 方法主要分为三大步： 1.检查参数 params 是否是 WindowManager.LayoutParams，如果不是说明参数不合法，则会抛出异常。 12345678910111213public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; // 检查 params 参数是否合法 throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; ...&#125; 2.创建 ViewRootImpl，并将 View 添加到列表中。 12345678910public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ...44root = new ViewRootImpl(view.getContext(), display); // 创建 ViewRootImpl view.setLayoutParams(wparams); mViews.add(view); // 将View添加到mView列表中，mView 存储的是所有Window对应的View mRoots.add(root); mParams.add(wparams); ...&#125; 3.通过 ViewRootImpl 的 setView 方法来添加更新界面并通过 IPC 的方式调用 WindowManagerService 的 addWindow 方法完成 Window 的添加过程。 1234567891011121314151617public void addView(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow) &#123;44... // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); // ViewRootImpl的setView 方法 &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125;&#125; 那 ViewRootImpl 的setView 方法是如何实现界面的更新的呢？ setView 方法中会调用 requestLayout() 方法去完成异步刷新请求： 12345678910@SuppressWarnings(&#123;\"EmptyCatchBlock\", \"PointlessBooleanExpression\"&#125;)public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, HardwareRenderer.HardwareDrawCallbacks &#123; private static final String TAG = \"ViewRootImpl\";4... // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. requestLayout(); &#125; 我们再查看 requestLayout 方法的源码，看它干了什么： 12345678@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); // scheduleTraversals 方法是View绘制的入口 &#125;&#125; 可以看到，是调用了 scheduleTraversals 方法进行绘制，我们知道 scheduleTraversals 是 View 执行绘制过程的入口方法，该方法会经过测量、布局、绘制这三个过程把 View 绘制出来。 那 View 绘制出来以后是怎么通过IPC调用的方式添加到 Window 中的呢？ 我们知道，WindowManager 是外界访问 Window 的入口，所以最终 WindowManager 会通过 IPC 的方式调用 WindowManagerService 的 addWindow 方法，这样一来， Window 的添加请求就交给了 WindowManagerService 来处理了，然后 WindowManagerService 会经过一系列的操作将 View 添加到 Window 中并展示出来。 作为应用层开发者来说，了解到这个程度个人觉得就可以了，没必要去深究 WindowManagerService 的实现细节，至于 WindowManagerService 是如何处理 Window 的添加请求的，感兴趣的读者可以去查看源码。 ​ 参考书籍：《Android 开发艺术探索》","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"Window","slug":"Window","permalink":"https://www.alankeene.com/tags/Window/"}]},{"title":"Window、WindowManager、View 之间的关系","slug":"window-and-windowmanager","date":"2019-03-03T09:08:50.000Z","updated":"2020-12-20T05:43:58.414Z","comments":true,"path":"2019/0303/window-and-windowmanager.html","link":"","permalink":"https://www.alankeene.com/2019/0303/window-and-windowmanager.html","excerpt":"如果问你这三个问题，你的理解是什么呢。 Window 和 WindowManager 是什么关系？ Window 和 View 是什么关系？ WindowManager 和 View 是什么关系？","text":"如果问你这三个问题，你的理解是什么呢。 Window 和 WindowManager 是什么关系？ Window 和 View 是什么关系？ WindowManager 和 View 是什么关系？ Window 和 WindowManager 是什么关系？Widow 是个抽象类，在 Android 中所有的视图都是通过 Window 来呈现的，包括 Activity、Dialog、Toast，它们的视图实际上都是附加在 Window 上的。Window 的具体实现类是 PhoneWindow。而 WindowManager 是外界访问 Window 的入口，WindowManager 和 WindowManagerService 之间通过 IPC 进行通信，从而实现对 Window 的访问和操作。 Window 和 View 是什么关系？Window 是 View 的承载者，而 View 是 Window 的体现者。两者之间通过 ViewRootImpl 建立联系。 怎么理解这句话呢？ Window 是 View 的承载者：Android 中的所有视图都是附加在 Window 上呈现出来的 。 View 是 Window 的体现者：因为 Window 是个抽象的概念，并不实际存在，View 才是 Window 存在的实体。 而 ViewRootImpl 是用来建立 Window 和 View 之间的联系的，是两者之间的纽带。 WindowManager 和 View 是什么关系？WindowManager 是 View 的直接管理者，对 View 的添加、删除、更新操作都是通过 WindowManager 来完成的，对应于 WindowManager 的 addView、removeView、updateViewLayout 三个方法。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"Window","slug":"Window","permalink":"https://www.alankeene.com/tags/Window/"},{"name":"WindowManager","slug":"WindowManager","permalink":"https://www.alankeene.com/tags/WindowManager/"}]},{"title":"赛格还会重生吗？","slug":"sz-saige","date":"2019-03-02T06:17:29.000Z","updated":"2019-03-02T06:30:15.337Z","comments":true,"path":"2019/0302/sz-saige.html","link":"","permalink":"https://www.alankeene.com/2019/0302/sz-saige.html","excerpt":"","text":"","categories":[{"name":"个人随笔","slug":"个人随笔","permalink":"https://www.alankeene.com/categories/个人随笔/"}],"tags":[{"name":"赛格","slug":"赛格","permalink":"https://www.alankeene.com/tags/赛格/"}]},{"title":"一个有趣的问题，如何用HashSet来存储重复的字符串？","slug":"how-to-store-same-string-in-hashset","date":"2019-02-23T13:46:05.000Z","updated":"2020-12-20T05:33:18.400Z","comments":true,"path":"2019/0223/how-to-store-same-string-in-hashset.html","link":"","permalink":"https://www.alankeene.com/2019/0223/how-to-store-same-string-in-hashset.html","excerpt":"有一种学得快的方法，就是不要一次学太多。 1. 前言今天，我们来探讨一个实际中不常用但却比较有意思的问题。它能帮助你理解 “HashSet中的键值是唯一的，不可重复的” 这句话的真正含义，也考验你对问题的思考深度。","text":"有一种学得快的方法，就是不要一次学太多。 1. 前言今天，我们来探讨一个实际中不常用但却比较有意思的问题。它能帮助你理解 “HashSet中的键值是唯一的，不可重复的” 这句话的真正含义，也考验你对问题的思考深度。 注：实际应用中，我们一般是用 ArrayList 集合来存储相同的字符串的，不会用 HashSet 来存。 我们平时都看到或听说 HashSet 是不能用来存放重复的字符串的，是真的存放不了吗？如果面试问你这个问题，你能给出解决方案吗？ 2. 参考解答先给出参考解答，然后我们再来分析为什么。 解答：虽然我们不能用 HashSet 来存放 String 类型重复的字符串，但我们可以用 HashSet 来存储 StringBuilder 类型重复的字符串呀。12345678910111213141516171819202122232425262728293031323334353637public class HashSetTest &#123; public static void main(String[] args)&#123; // 用 HashSet 来存放 String 类型的重复的字符串会发生什么？ HashSet&lt;String&gt; hs1 = new HashSet&lt;&gt;(); String s1 = new String(\"aaa\"); String s2 = new String(\"aaa\"); String s3 = new String(\"aaa\"); hs1.add(s1); hs1.add(s2); hs1.add(s3); System.out.println(\"hs1:\"+hs1); // 重复的字符串是存不进去的 // 用 HashSet 来存放 StringBuilder 类型的重复的字符串又会发生什么？ HashSet&lt;StringBuilder&gt; hs2 = new HashSet&lt;&gt;(); StringBuilder sb1 = new StringBuilder(\"aaa\"); StringBuilder sb2 = new StringBuilder(\"aaa\"); StringBuilder sb3 = new StringBuilder(\"aaa\"); hs2.add(sb1); hs2.add(sb2); hs2.add(sb3); System.out.println(\"hs2:\"+hs2); // 咦，结果发现重复的字符串也能存进去了 // 那为什么呢？我们来打印一个各个对象的hashCode看一下 System.out.println(\"s1的hashCode:\"+s1.hashCode()); System.out.println(\"s2的hashCode:\"+s2.hashCode()); System.out.println(\"s3的hashCode:\"+s3.hashCode()); System.out.println(\"sb1的hashCode:\"+sb1.hashCode()); System.out.println(\"sb2的hashCode:\"+sb2.hashCode()); System.out.println(\"sb3的hashCode:\"+sb3.hashCode()); &#125;&#125; 输出结果：12345678hs1:[aaa]hs2:[aaa, aaa, aaa]s1的hashCode:96321s2的hashCode:96321s3的hashCode:96321sb1的hashCode:356573597sb2的hashCode:1735600054sb3的hashCode:21685669 从打印结果来看，我们是不能用 HashSet 来存放 String 类型的重复字符串的(如hs1)，但我们是可以用HashSet来存放 StringBuilder 类型的重复字符串。 3. 为什么？从打印的 hashCode 来看，String 类型，相同字符串的不同 String 对象哈希值是一样的。而对于 StringBuilder 类型，相同字符串的不同对象哈希值是不同的。 要知道这个问题的答案，我们首先得了解 JDK 是如何判断两个对象是否相同的。 那 JDK 是如何判断两个对象是否相同的呢？参考解答： JDK 会先判断两个对象的 hashCode 是否相同，如果 hashCode 不同，则说明肯定是两个不同的对象了；如果 hashCode 相同再通过 equals() 方法进行进一步比较，如果 equals 方法返回 true，则说明两个对象是相同的，如果equals方法返回 false 说明两个对象不同。 具体验证思路如果你感兴趣，请查看: JDK 是如何判断两个对象是否相同的？判断的流程是什么？ 那为什么相同字符串的不同 String 对象哈希值是一样的，而且还被 JDK 判断为相同的对象了呢？因为 String 类复写了 Object 类的 hashCode() 和 equals() 方法，并实现了自己的 hashCode 值生成算法和 equals 的比较规则，具有相同字符串内容的不同 String 对象在初始化时生成的 hashCode 值是一样的，并且 String 类 equals() 方法比较的是两个字符串的内容，而不是内存地址值，这两个条件同时成立， 这使得 JDK 把具有相同内容的不同 String 对象判断为相同的对象了，就不会存入 HashSet 集合中。 而 StringBuilder 为什么就可以呢？它相同内容的不同对象的哈希值值为什么是不同的？查看 StringBuilder 类的源码你会发现，因为 StringBuilder 并没有复写 Object 类的 hashCode() 方法和 equals() 方法，StringBuilder 用的是父类 Object 类的 hashCode 生成算法，也就是用 native 层的 hashCode 生成算法，很大概率产生的哈希值是不一样的，即使产生了一样的哈希值，Object 类的 equals() 方法比较的是两个对象的内存地址，而不是两个对象的内容，这就使得 JDK 把具有相同内容的 StringBuilder 对象判断为不同的对象，就可以存入 HashSet 集合中了。","categories":[{"name":"Java 内功强化系列","slug":"Java-内功强化系列","permalink":"https://www.alankeene.com/categories/Java-内功强化系列/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.alankeene.com/tags/Java/"},{"name":"HashSet","slug":"HashSet","permalink":"https://www.alankeene.com/tags/HashSet/"},{"name":"String","slug":"String","permalink":"https://www.alankeene.com/tags/String/"}]},{"title":"JDK是如何判断两个对象是否相同的？判断的流程是什么？","slug":"how-jdk-distinguish-object","date":"2019-02-21T16:17:40.000Z","updated":"2020-12-20T05:34:05.661Z","comments":true,"path":"2019/0222/how-jdk-distinguish-object.html","link":"","permalink":"https://www.alankeene.com/2019/0222/how-jdk-distinguish-object.html","excerpt":"有一种学得快的方法，就是不要一次学太多。 JDK 是如何判断两个对象是否相同的呢？判断的流程是什么？ 参考解答：JDK 会先判断两个对象的hashCode是否相同，如果hashCode不同，则说明肯定是两个不同的对象了；如果hashCode相同再通过equals()方法进行进一步比较，如果equals方法返回true，则说明两个对象是相同的，如果equals方法返回false说明两个对象不同。","text":"有一种学得快的方法，就是不要一次学太多。 JDK 是如何判断两个对象是否相同的呢？判断的流程是什么？ 参考解答：JDK 会先判断两个对象的hashCode是否相同，如果hashCode不同，则说明肯定是两个不同的对象了；如果hashCode相同再通过equals()方法进行进一步比较，如果equals方法返回true，则说明两个对象是相同的，如果equals方法返回false说明两个对象不同。 如何验证怎么来验证这个问题呢？我们知道HashSet是不允许存储相同的键值的。所以我们可以用HashSet存储两个相同的键值来模拟，看 JDK 是如何做判断和识别的，从而验证我们的猜想。 12345678910111213141516// 先自定义一个类并复写 hashCode 和 equals 方法public class CustomClass &#123; @Override public int hashCode() &#123; System.out.println(\"判断 hashCode\"); return 1; // 返回1，说明所有新建的对象的哈希值都为1，也就是相同 &#125; @Override public boolean equals(Object o) &#123; System.out.println(\"判断 equals\"); return true; // 返回true &#125;&#125; 接下来我们用HashSet来存储两个自定义的CustomClass的对象，代码如下：12345678910111213public class HashSetTest &#123; public static void main(String[] args) &#123; HashSet&lt;CustomClass&gt; hs = new HashSet&lt;&gt;(); CustomClass cs1 = new CustomClass(); CustomClass cs2 = new CustomClass(); hs.add(cs1); hs.add(cs2); System.out.println(\"----hs添加完毕\"); System.out.println(\"hs:\"+hs); // 打印一下hashSet集合看里面存放了什么 &#125;&#125; 打印结果如下：123456判断 hashCode 判断 hashCode判断 equals----hs添加完毕判断 hashCode // 此处的判断是打印输出语句执行时调用的，与分析本问题无关hs:[com.alankeene.javalib.collections.CustomClass@1] 结果分析：执行 hs.add(cs1) 语句的时候，JDK 会先判断 cs1 所指向对象的hashCode，因为是第一次往HashSet集合里面存放元素，该元素 hashCode 在集合中肯定是还没存在的，这是个新的元素，所以直接存放进集合中，不用调用 cs1 所指向对象的 equals 方法。当执行 hs.add(cs2) 语句时，这是第二次往集合里存放元素，有新的元素 cs2 要添加进来，那先要调用 cs2 所指向对象的 hashCode 方法看看它的哈希值是不是与集合中已有元素的哈希值重复了，发现重复了，哈希值都是1，那有可能是同一个对象，那就要调用 cs2 所指向对象的 equals 方法做进一步判断，发现 equals 方法返回 true，则判断为是重复的元素，就不往集合里添加了。 所以最终打印 HashSet 集合的时候可以看到，集合中只存放了一个元素。 我们再反证一下，把 equals 方法改为返回 false，模拟两个hashCode相同，但是是两个不同的对象的情景。1234567891011121314public class CustomClass &#123; @Override public int hashCode() &#123; System.out.println(\"判断 hashCode\"); return 1; // 返回1，说明所有新建的对象的哈希值都为1，也就是相同 &#125; @Override public boolean equals(Object o) &#123; System.out.println(\"判断 equals\"); return false; // 返回false &#125;&#125; 打印结果会如下：1234567判断 hashCode 判断 hashCode判断 equals----hs添加完毕判断 hashCode // 此处的判断是打印输出语句执行时调用的，与分析本问题无关判断 hashCode // 此处的判断是打印输出语句执行时调用的，与分析本问题无关hs:[com.alankeene.javalib.collections.CustomClass@1, com.alankeene.javalib.collections.CustomClass@1] 会发现，HashSet集合中存放了两个元素了，说明虽然 cs1 和 cs2 的哈希值相同，但是 JDK 判断为不同的元素并存入集合中了。 由此，验证了我们的猜想。JDK 是先判断 hashCode，如果 hashCode 相同再通过 equals 去判断两个对象是否相同的。","categories":[{"name":"Java 内功强化系列","slug":"Java-内功强化系列","permalink":"https://www.alankeene.com/categories/Java-内功强化系列/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.alankeene.com/tags/Java/"}]},{"title":"你有没有想过，为什么Java中String是不可变的？","slug":"why-string-imutable","date":"2019-02-19T08:49:34.000Z","updated":"2020-12-20T05:36:34.871Z","comments":true,"path":"2019/0219/why-string-imutable.html","link":"","permalink":"https://www.alankeene.com/2019/0219/why-string-imutable.html","excerpt":"有一种学得快的方法，就是不要一次学太多。 解答：有三点：1）String 在底层是用一个 private final 修饰的字符数组 value 来存储字符串的。final 修饰符保证了 value 这个引用变量是不可变的，private 修饰符则保证了 value 是类私有的，不能通过对象实例去访问和更改 value 数组里存放的字符。 注：有很多地方说 String 不可变是 final 起的作用，其实不严谨。因为即使我不用 final 修改 value ，但初始化完成后我能保证以后都不更改 value 这个引用变量和 value[] 数组里存放的值，它也是从没变化过的。final 只是保证了 value 这个引用变量是不能更改的，但不能保证 value[] 数组里存放的字符是不能更改的。如果把 private 改为 public 修饰，String类的对象是可以通过访问 value 去更改 value[] 数组里存放的字符的，这时 String 就不再是不可变的了。所以不如说 private 起的作用更大一些。后面我们会通过 代码1处 去验证。 2）String 类并没有对外暴露可以修改 value[] 数组内容的方法，并且 String 类内部对字符串的操作和改变都是通过新建一个 String 对象去完成的，操作完返回的是新的 String 对象，并没有改变原来对象的 value[] 数组。 注：String 类如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，也是不能保证 String 是不可变的。后面我们会通过 代码2处 去验证。 3）String 类是用 final 修饰的，保证了 String 类是不能通过子类继承去破坏或更改它的不可变性的。 注：如果 String 类不是用 final 修饰的，也就是 String 类是可以被子类继承的，那子类就可以改变父类原有的方法或属性。后面我们会通过 代码3处 去验证。 以上三个条件同时满足，才让 String 类成了不可变类，才让 String 类具有了一旦实例化就不能改变它的内容的属性。","text":"有一种学得快的方法，就是不要一次学太多。 解答：有三点：1）String 在底层是用一个 private final 修饰的字符数组 value 来存储字符串的。final 修饰符保证了 value 这个引用变量是不可变的，private 修饰符则保证了 value 是类私有的，不能通过对象实例去访问和更改 value 数组里存放的字符。 注：有很多地方说 String 不可变是 final 起的作用，其实不严谨。因为即使我不用 final 修改 value ，但初始化完成后我能保证以后都不更改 value 这个引用变量和 value[] 数组里存放的值，它也是从没变化过的。final 只是保证了 value 这个引用变量是不能更改的，但不能保证 value[] 数组里存放的字符是不能更改的。如果把 private 改为 public 修饰，String类的对象是可以通过访问 value 去更改 value[] 数组里存放的字符的，这时 String 就不再是不可变的了。所以不如说 private 起的作用更大一些。后面我们会通过 代码1处 去验证。 2）String 类并没有对外暴露可以修改 value[] 数组内容的方法，并且 String 类内部对字符串的操作和改变都是通过新建一个 String 对象去完成的，操作完返回的是新的 String 对象，并没有改变原来对象的 value[] 数组。 注：String 类如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，也是不能保证 String 是不可变的。后面我们会通过 代码2处 去验证。 3）String 类是用 final 修饰的，保证了 String 类是不能通过子类继承去破坏或更改它的不可变性的。 注：如果 String 类不是用 final 修饰的，也就是 String 类是可以被子类继承的，那子类就可以改变父类原有的方法或属性。后面我们会通过 代码3处 去验证。 以上三个条件同时满足，才让 String 类成了不可变类，才让 String 类具有了一旦实例化就不能改变它的内容的属性。 12345678910111213141516171819public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final char[] value; // 用 private final 修饰的字符数组存储字符串 private int hash; private static final long serialVersionUID = -6849794470754667710L;\\ public String() &#123; this.value = \"\".value; &#125; public String(String var1) &#123; this.value = var1.value; this.hash = var1.hash; &#125; public String(char[] var1) &#123; this.value = Arrays.copyOf(var1, var1.length); &#125; ......&#125; 面试问题：String 类是用什么数据结构来存储字符串的？由上面 String 的源码可见，String 类是用数组的数据结构来存储字符串的。 代码1处：我们来看看如果把 private 修饰符换成 public，看看会发生什么？ 12345678910111213141516 // 先来模拟一个String类，初始化的时候将 String 转成 value 数组存储public final class WhyStringImutable &#123; public final char[] value; // 修饰符改成了 public public WhyStringImutable() &#123; this.value = \"\".toCharArray(); &#125; public WhyStringImutable(String str)&#123; this.value = str.toCharArray(); // 初始化时转为字符数组 &#125; public char[] getValue()&#123; return this.value; &#125;&#125; 1234567891011public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; WhyStringImutable str = new WhyStringImutable(\"abcd\"); System.out.println(\"原str中value数组的内容为：\"); System.out.println(str.getValue()); // 打印str对象中存放的字符数组 System.out.println(\"----------\"); str.value[1] = 'e'; // 通过对象实例访问value数组并修改其内容 System.out.println(\"修改后str中value数组的内容为：\"); System.out.println(str.getValue()); // 打印str对象中存放的字符数组 &#125;&#125; 输出结果：12345原str中value数组的内容为：abcd----------修改后str中value数组的内容为：aecd 由此可见，private 修改为 public 后，String 是可以通过对象实例访问并修改所保存的value 数组的，并不能保证 String 的不可变性。 代码2处：我们如果对外暴露可以更改 value[] 数组的方法，如 setter 方法，看看又会发生什么？123456789101112131415161718192021public final class WhyStringImutable &#123; private final char[] value; public WhyStringImutable() &#123; this.value = \"\".toCharArray(); &#125; public WhyStringImutable(String str)&#123; this.value = str.toCharArray(); &#125; // 对外暴露可以修改 value 数组的方法 public void setValue(int i, char ch)&#123; this.value[i] = ch; &#125; public char[] getValue()&#123; return this.value; &#125;&#125; 1234567891011public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; WhyStringImutable str = new WhyStringImutable(\"abcd\"); System.out.println(\"原str中value数组的内容为：\"); System.out.println(str.getValue()); // 打印str对象中存放的字符数组 System.out.println(\"----------\"); str.setValue(1,'e'); // 通过set方法改变指定位置的value数组元素 System.out.println(\"修改后str中value数组的内容为：\"); System.out.println(str.getValue()); // 打印str对象中存放的字符数组 &#125;&#125; 输出结果：12345原str中value数组的内容为：abcd----------修改后str中value数组的内容为：aecd 由此可见，如果对外暴露了可以更改 value[] 数组内容的方法，也是不能保证 String 的不可变性的。 代码3处：如果 WhyStringImutable 类去掉 final 修饰，其他的保持不变，又会怎样呢？123456789101112131415public class WhyStringImutable &#123; private final char[] value; public WhyStringImutable() &#123; this.value = \"\".toCharArray(); &#125; public WhyStringImutable(String str)&#123; this.value = str.toCharArray(); // 初始化时转为字符数组 &#125; public char[] getValue()&#123; return this.value; &#125;&#125; 写一个子类继承自WhyStringImutable 并修改原来父类的属性，实现子类自己的逻辑：1234567891011121314151617public class WhyStringImutableChild extends WhyStringImutable &#123; public char[] value; // 修改字符数组为 public 修饰，不要 final public WhyStringImutableChild(String str)&#123; this.value = str.toCharArray(); &#125; public WhyStringImutableChild() &#123; this.value = \"\".toCharArray(); &#125; @Override public char[] getValue() &#123; return this.value; &#125;&#125; 1234567891011public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; WhyStringImutableChild str = new WhyStringImutableChild(\"abcd\"); System.out.println(\"原str中value数组的内容为：\"); System.out.println(str.getValue()); System.out.println(\"----------\"); str.value[1] = 's'; System.out.println(\"修改后str中value数组的内容为：\"); System.out.println(str.getValue()); &#125;&#125; 运行结果：12345原str中value数组的内容为：abcd----------修改后str中value数组的内容为：ascd 由此可见，如果 String 类不是用 final 修饰的，是可以通过子类继承来修改它原来的属性的，所以也是不能保证它的不可变性的。 总结综上所分析，String 不可变的原因是 JDK 设计者巧妙的设计了如上三点，保证了String 类是个不可变类，让 String 具有了不可变的属性。考验的是工程师构造数据类型，封装数据的功力，而不是简单的用 final 来修饰，背后的设计思想值得我们理解和学习。 拓展从上面的分析，我们知道，String 确实是个不可变的类，但我们就真的没办法改变 String 对象的值了吗？不是的，通过反射可以改变 String 对象的值。 但是请谨慎那么做，因为一旦通过反射改变对应的 String 对象的值，后面再创建相同内容的 String 对象时都会是反射改变后的值，这时候在后面的代码逻辑执行时就会出现让你 “摸不着头脑” 的现象，具有迷惑性，出了奇葩的问题你也很难排除到原因。后面在 代码4处 我们会验证这个问题。 先来看看如何通过反射改变 String 对象的内容：1234567891011121314public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; String str = new String(\"123\"); System.out.println(\"反射前 str:\"+str); try &#123; Field field = String.class.getDeclaredField(\"value\"); field.setAccessible(true); char[] aa = (char[]) field.get(str); aa[1] = '1'; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; System.out.println(\"反射后 str：\"+str);&#125; 打印结果：12反射前 str:123反射后 str：113 // 可见，反射后，str 的值确实改变了 代码4处:下面我们来验证因为一旦通过反射改变对应的 String 对象的值，后面再创建相同内容的 String 对象时都会是反射改变后的值的问题：12345678910111213141516171819public class WhyStringImutableTest &#123; public static void main(String[] args) &#123; String str = new String(\"123\"); System.out.println(\"反射前 str:\"+str); try &#123; Field field = String.class.getDeclaredField(\"value\"); field.setAccessible(true); char[] aa = (char[]) field.get(str); aa[1] = '1'; &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; System.out.println(\"反射后 str：\"+str); String str2 = new String(\"123\"); System.out.println(\"str2:\"+str2); // 我们来看 str2 会输出什么，会输出 113？ System.out.println(\"判断是否是同一对象：\"+str == str2); // 判断 str 和 str2 的内存地址值是否相等 System.out.println(\"判断内容是否相同：\"+str.equals(str2)); // 判断 str 和 str2 的内容是否相等&#125; 执行结果如下：12345反射前 str:123反射后 str：113str2:113 // 竟然不是123？？而是输出113，说明 str2 也是反射修改后的值。判断是否是同一对象：false // 输出 false，说明在内存中确实创建了两个不同的对象判断内容是否相同：true // 输出true，说明依然判断为两个对象内容是相等的 由上面的输出结果，我们可知，反射后再新建相同内容的字符串对象时会是反射修改后的值，这就造成了很大迷惑性，在实际开发中要谨慎这么做。","categories":[{"name":"Java 内功强化系列","slug":"Java-内功强化系列","permalink":"https://www.alankeene.com/categories/Java-内功强化系列/"}],"tags":[{"name":"String","slug":"String","permalink":"https://www.alankeene.com/tags/String/"}]},{"title":"Android Studio mac 快捷键","slug":"AndroidStudio-mac-shortcuts","date":"2019-01-06T04:38:27.000Z","updated":"2019-01-07T05:45:48.522Z","comments":true,"path":"2019/0106/AndroidStudio-mac-shortcuts.html","link":"","permalink":"https://www.alankeene.com/2019/0106/AndroidStudio-mac-shortcuts.html","excerpt":"","text":"Android Studio 常用 mac 快捷键 快捷键 用法 ⌃+⇧+Space 初始化对象时，输入 new 后，按此快捷键快速输入类名 ⌥⌘B 快速导航到抽象方法的实现类 ⌥⌘V mEditorPane.setBorder(BorderFatory.createEmptyBorder(5,5,5,5));选中BorderFatory.createEmptyBorder(5,5,5,5), 然后按此快捷键，自动提取出如下代码：Border emptyBorder = BorderFactory.createEmptyBorder(5,5,5,5);myEditorPane.setBorder(emptyBorder); ⌃Space 新建一个变量时，按此快捷键，编辑器会推荐一个变量名 ⌘P 如果光标位于方法调用的括号之间，则按⌘P将显示有效参数列表。","categories":[{"name":"记录","slug":"记录","permalink":"https://www.alankeene.com/categories/记录/"}],"tags":[{"name":"mac快捷键","slug":"mac快捷键","permalink":"https://www.alankeene.com/tags/mac快捷键/"}]},{"title":"Pre-built binaries not found for fsevents@1.1.3 and node@11.6.0","slug":"fsevents-didnot-soppurt-node11","date":"2019-01-02T14:40:08.000Z","updated":"2019-02-19T17:29:54.148Z","comments":true,"path":"2019/0102/fsevents-didnot-soppurt-node11.html","link":"","permalink":"https://www.alankeene.com/2019/0102/fsevents-didnot-soppurt-node11.html","excerpt":"用 npm install 安装 fsevent 插件， 发现如下图提示： 搜索了一圈发现原来是 fsevents 目前还没支持 node v11+，笔者用的是 brew install node 下载的 node，默认下载的是最新的版本，用 node -v 命令查看 node 的版本呢，笔者的 node 是 v11.6.0。","text":"用 npm install 安装 fsevent 插件， 发现如下图提示： 搜索了一圈发现原来是 fsevents 目前还没支持 node v11+，笔者用的是 brew install node 下载的 node，默认下载的是最新的版本，用 node -v 命令查看 node 的版本呢，笔者的 node 是 v11.6.0。 详情请参阅： Build binary for Node 11 No binary found on s3 for Node v8.0 知道了原因那在 mac 下如何快速降低 node 的版本呢？ 看这： https://apple.stackexchange.com/a/207883","categories":[{"name":"日常解决问题集锦","slug":"日常解决问题集锦","permalink":"https://www.alankeene.com/categories/日常解决问题集锦/"}],"tags":[{"name":"fsevents","slug":"fsevents","permalink":"https://www.alankeene.com/tags/fsevents/"},{"name":"node","slug":"node","permalink":"https://www.alankeene.com/tags/node/"}]},{"title":"最安全的hexo多台电脑同步博客解决方案--非新建分支","slug":"hexo-perfect-synchronize","date":"2019-01-02T07:42:05.000Z","updated":"2019-02-19T17:27:21.665Z","comments":true,"path":"2019/0102/hexo-perfect-synchronize.html","link":"","permalink":"https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html","excerpt":"","text":"我们经常有这样一个需求场景：需要在多台电脑间完成 Hexo 博客的撰写和发布，这就涉及到如何多台电脑同步博客的问题。 我最近也遇到了这个问题，网上看了很多方案，都是通过新建一个分支来存放博客源文件。但这样一来，我很多第三方插件配置的密钥信息不就暴露了吗？会不会存在数据安全隐患？有没有什么办法不暴露这些信息？对了，用一个私有仓库来存放博客源文件不就结了嘛。虽然 Github 的私有仓库是收费的，但是我的博客是同时部署在 Github 和 Coding 的，而 Coding 是可以新建私有仓库的。Nice，完美解决。 当我准备写遍博客来分享（xuan yao）这个解决方案时，最后还是荣幸的发现一遍文章已经分享了这个方案，只是在搜索引擎中不太好搜出来。本着“不重复造轮子的原则”，笔者就不重写了，而且他已经写的很好了。但是有几个问题需要特别注意一下： 该文中删除主题的 .git 配置，如果你有多个主题文件夹的话，需要都删除(如 NexT 主题)。然后删除的命令那位笔者不小心写错了，应该是： rm -rf ./themes/next/.git/ 用这条命令来删除你对应主题文件夹里的.git 文件夹，注意 .git 是一个隐藏文件夹。 .gitignore 文件夹在 Hexo 的根目录下可能已经存在了，可以打开和该文中的忽略事项比对一下，如果一样，接着 git init 初始化 git 仓库就好；如果没有该 .gitignore 文件夹就新建一个添加相应忽略事项再 git init 初始化。 这点需要特别注意，否则可能导致迁移失败： 虽然我们第 1 步中删除了主题的 .git 配置，第 2 步中Hexo项目根目录的 .gitignore 文件也并没有忽略掉 theme 这个文件夹。但是！！ NexT 主题的文件夹原来是用 git 来管理的，里面还有一个 .gitignore 文件，把 themes/next/source/lib 目录下的很多文件给忽略掉了。 这就导致了你上传到私有仓库时，你以为你把 themes 文件下的所有内容都上传到仓库了，但其实 “偷偷”的把 themes/next/source/lib 目录下的很多必要的文件也忽略掉了，并没有上传。然后在新电脑上拉下来的时候，hexo g、hexo s 一预览，你会奇怪的发现：所有的 FontAwesome 相关的图标都不见了，其他的功能一切正常。 正确的做法是：在新机器上把私有仓库上的博客源文件 clone 下来后，因为还缺点原来的文件，所以应该去原来机器上 themes/next/source/lib 目录下，把整个 lib 目录下的文件全部复制粘贴到新机器对应的 themes/next/source/lib 目录下，这样就能正常生成站点文件了。 注意：同理，如果你的 themes 目录下有多个主题配置文件的话，可以查看是否有 .gitignore 文件，用 git 上传私有仓库时是否也忽略了一些必要资源，如果有再新电脑上对应复制过来就 OK 了。 关于这个问题的详情，可查看：https://github.com/theme-next/hexo-theme-next/issues/564#issuecomment-451385682 在新电脑上 npm install 下载 hexo 所需的环境的时候，要切到 hexo 的根目录下，再执行 npm install。 当你在新电脑用 npm install 下载依赖的第三插件时，由于 node 的版本、众多第三方插件、跨平台等原因，可能有的插件会存在兼容性问题，导致下载不下来，笔者想迁移到 Mac 上就遇到兼容性问题了，fsevent 插件目前不支持 node v11+ 版本，而刚配置新电脑的 node 环境时，默认安装的是最新版的 node，需要降低 node 的版本才能下载成功。 node 11 无法安装 fsevents 插件的解决方案 至于如何降低 node 的版本，其实你不用删除，有一个叫 nvm （Node Version Manager）的工具，专门用来管理多个版本的 node 环境的，你可以下载多个版本的 node 存在你的机器中，用 nvm 的命令行就可以实现不同版本 node 环境的随意切换，非常方便。 这是 nvm 的 github 地址 好，当你在新的电脑上写完博客，本地预览也没问题，准备用 hexo d 部署到 Github 和 Coding 上前，别忘了把新电脑的 SSH 公钥配置到 Github 和 Coding 上。 然后用 hexo d部署时，由于在新机器上，SSH 密钥和之前的不一样，第一次尝试连接 Github 主机时会提示：The authenticity of host github.com can&#39;t be established.Are you sure you want continue connecting? 输入 yes 就好，同理 coding 仓库也会提示，同样输入yes。至此，新电脑上写完的博客也成功同步更新到 Github 和 Coding 的仓库上了。 更新完博客后，记得 用 git push 将新电脑上改动的博客源文件也 push 到私有仓库中，实现博客源文件的同步更新。 当你在另一台电脑上准备开始写博客前，记得把远程私有仓库的最新博客源文件拉到本地，但记得不要用 git pull 的方式，用如下两条命令： 123git fetch --all #将远程git仓库上最新的内容拉取到本地,将本地库所关联的远程库更新至最新git reset --hard origin/master #强制将本地库的内容指向最新远程仓库的master分支 最后附上该篇博客的地址： 最完美的Hexo多电脑同步方法 从此，你就可以在多台电脑间愉快地写博客啦～ 本迁移解决方案博主亲测有效，请放心迁移，迁移过程中如果还遇到什么问题欢迎和我交流。 2019.1.8 最新更新： 好消息是：Github 从 2019.1.8 日起可以免费使用私有仓库了，那大家也可以选择把博客源文件传到 Github 私有仓库上，维护起来更加方便了。","categories":[{"name":"经验","slug":"经验","permalink":"https://www.alankeene.com/categories/经验/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.alankeene.com/tags/hexo/"},{"name":"多电脑同步博客","slug":"多电脑同步博客","permalink":"https://www.alankeene.com/tags/多电脑同步博客/"}]},{"title":"dryrun 在 windows 上的使用教程","slug":"use-dryrun-in-windows","date":"2018-06-18T05:30:51.000Z","updated":"2020-12-20T05:20:32.104Z","comments":true,"path":"2018/0618/use-dryrun-in-windows.html","link":"","permalink":"https://www.alankeene.com/2018/0618/use-dryrun-in-windows.html","excerpt":"有些坑别人踩过了，希望你不用再踩一遍。 dryrun 的作者使用的是 Mac，本文主要介绍 dryrun 在 windows 上配置使用的方法以及容易导致配置不成功的关键点，为想在 windows 上也能使用 dryrun 的 Android 开发者提供参考。","text":"有些坑别人踩过了，希望你不用再踩一遍。 dryrun 的作者使用的是 Mac，本文主要介绍 dryrun 在 windows 上配置使用的方法以及容易导致配置不成功的关键点，为想在 windows 上也能使用 dryrun 的 Android 开发者提供参考。 dryrun 是个什么工具？能帮我们提高什么效率？简单来说，dryrun 是帮助 Android 开发者快速预览 Github 上开源 Android 项目在真机上的实际运行效果的工具。 使用 dryrun 工具，可以避免下载解压、导入项目、编译、运行在手机上一系列的动作，简单一行命令 dryrun + Github 上的项目地址 就可以把 Github 上的 Android 项目安装到真机上预览实际的效果了。 dryrun 的 Github 地址 windows 上安装和配置 dryrun 所需环境请参考： Windows 环境下的 dryrun 使用教程 但笔者按照以上教程并没有配置成功，有几个坑点上文中尚未提及，需要另外注意一下： 关于下载哪个版本的 Ruby 和 DevKit 据网上说，Ruby 最新版已经内置了 DevKit，但笔者尝试了最新版的 Ruby 的安装，发现安装过程及配置稍微复杂，不适合完全不懂 Ruby 的小白，而我们作为想使用 dryrun 工具 的Android 开发者，只是需要 ruby 的一个环境，并不需要用到 Ruby 的最新特性，所以笔者建议如果你不太了解最新版的 Ruby 如何去安装和配置的话，像笔者一样下载： 2.3.3 版本的 Ruby 和 DevKit For use with Ruby 2.0 to 2.3 然后按照教程以及容易忽略的坑点去安装和配置即可。 需要配置 JAVA_HOME 环境变量。 由于新版的 Android Studio 已经帮我们内置了 JDK ,我们 Android 开发者不需要再像以前那样需要单独的配置 JAVA 环境，所以容易忽略了 dryrun 安装时需要的 JAVA 环境。 如果你的机器尚未配置 JAVA 环境变量，按照教程执行到 gem install dryrun --source http://rubygems.org 安装 dryrun 的步骤时，会安装不成功，仔细看日志会发现是缺少了 JAVA 环境变量。配置好 JAVA_HOME 环境变量再执行安装命令就能安装成功了。 至于如何配置 JAVA 环境变量，想必想使用 dryrun 的人应该都会了，如果你恰巧不会或忘了，网上也有很多配置教程可以找到，不用担心。 需要配置 ANDROID_HOME 环境变量。 安装好了 dryrun 后，执行 dryrun + Github 项目地址 去在真机上下载并预览项目时，如果没有配置 Android_HOME 环境变量，会发现项目下载不下来。配置一下 ANDROID_HOME 环境变量即可，也就是配置一下 SDK 的路径。 好了，在 windows 上使用 dryrun 的方法以及容易忽略的几个坑点已经讲解完毕了，希望你们都能愉快的一次性就安装成功，不用踩坑，然后就是愉快的逛 Github 去学习啦~","categories":[{"name":"提高开发效率的工具","slug":"提高开发效率的工具","permalink":"https://www.alankeene.com/categories/提高开发效率的工具/"}],"tags":[{"name":"dryrun 使用","slug":"dryrun-使用","permalink":"https://www.alankeene.com/tags/dryrun-使用/"},{"name":"dryrun windows 使用","slug":"dryrun-windows-使用","permalink":"https://www.alankeene.com/tags/dryrun-windows-使用/"}]},{"title":"Android Things 官方开发文档(中文版)","slug":"Android-Things","date":"2018-04-21T13:44:41.000Z","updated":"2019-01-02T07:23:26.256Z","comments":true,"path":"2018/0421/Android-Things.html","link":"","permalink":"https://www.alankeene.com/2018/0421/Android-Things.html","excerpt":"有的人是因为看到才会相信，有的人是因为相信才会看到。 这是笔者最喜欢的一张图片了，作为一个沉稳严谨的工程师，每当笔者看到这个图片时，都不免心潮澎湃一下。 而今，全世界都在憧憬万物互联，在谈论IOT，未来会是什么样？什么时候来？ 也许在互联网的世界里，未来很快就有可能到来，也许来了也会是和我们想象的形态不一样。但有一点我们可以坚信，物联网是趋势，而且肯定会来。 如果你对 Android Things 已经有一定了解，可以直接参阅笔者翻译的一本电子书：Android Things 官方开发文档(中文版)，跳过下面介绍的阅读，或者直接跳到第二部分看麻省理工流体界面实验室研发出来的 Reality Editor.","text":"有的人是因为看到才会相信，有的人是因为相信才会看到。 这是笔者最喜欢的一张图片了，作为一个沉稳严谨的工程师，每当笔者看到这个图片时，都不免心潮澎湃一下。 而今，全世界都在憧憬万物互联，在谈论IOT，未来会是什么样？什么时候来？ 也许在互联网的世界里，未来很快就有可能到来，也许来了也会是和我们想象的形态不一样。但有一点我们可以坚信，物联网是趋势，而且肯定会来。 如果你对 Android Things 已经有一定了解，可以直接参阅笔者翻译的一本电子书：Android Things 官方开发文档(中文版)，跳过下面介绍的阅读，或者直接跳到第二部分看麻省理工流体界面实验室研发出来的 Reality Editor. Android Things 简介Android Things 正是 Google 布局物联网领域的一个操作系统，蕴含着 Google 在物联网领域的野心。 正如官方介绍的那样： If you can build an app, you can build a device. Android Things 的前身是 Goolge 2015 年发布的物联网平台 Birllo，除了继承 Brillo 的功能外，还加入了 Android Studio、 Android SDK、 Google Play 服务以及 Google 云平台等 Android 开发者熟悉的工具和服务。任何 Android 开发者现在都可以利用 Android API 和 Google 服务轻松构建智能联网设备。 连接智能手机有 Android 操作系统，连接智能穿戴设备有 Android Wear，连接平板有 Android Tablets，连接智能电视有 Android TV，连接汽车有 Android AUTO，PC端的还有 Chrome OS。很显然，Google 是想基于 Android 连接一切，打通你生活中的所有需求。 自 2016.12 发布第一个开发者预览版以来，目前 Android Things 依然在孵化中，截至笔者写稿的此时，孵化到了 Developer Preview 8，开发者预览版 8 。 Android Things 会不会在物联网领域发展起来时大展宏图不能确定，但看目前 Android Things 的演进，Google 还是对其抱有梦想。 而作为 Android 开发者，这是值得让我们兴奋的事，Android 充满了更多的可能。 笔者非常看好 Android 和 Android Things 的未来，也是从 Android Things 预览版发布开始就一直关注 Android Things 的动态。笔者认为只要我们的计算平台还是手机，Android 的前景就是光明的，互联网的变革之后，现在我们的人在哪？就在手机里。人在哪服务就会在哪，未来会有更多先进的技术、服务集成到手机里推到“人”这一端，比如现在研究出来的很多 AI 技术在努力的寻找落地应用场景，嗷嗷待哺。而手机中，Android 的全球市场份额占到了 85.9%，并且每年都还在增长，Android 操作系统在体验上也优化的越来越好。 笔者在 2017.5 翻译了 Android Things 的官方开发文档，并做成了一本 Gitbook 电子书，如果你想要更加详细的了解 Android Things 或者是 Android Things 的开发者，可以获得参考，免费的哦~ 电子书地址：Android Things 官方开发文档(中文版) 麻省理工的 Reality Editor下面分享一下麻省理工流体界面实验室花了3年时间研发出来的一款增强现实应用，叫 Reality Editor，实现了设备功能的连接。 Reality Editor的概念是通过手机摄像头取景，以增强现实的方式将用户周围的智能设备连接在一起，通过手指滑动即可将一系列相关的设备联通。 下面就是激动人心的视频啦：(前方高能，非战斗人员迅速撤离)","categories":[{"name":"Android Things","slug":"Android-Things","permalink":"https://www.alankeene.com/categories/Android-Things/"}],"tags":[{"name":"Android Things","slug":"Android-Things","permalink":"https://www.alankeene.com/tags/Android-Things/"},{"name":"IOT","slug":"IOT","permalink":"https://www.alankeene.com/tags/IOT/"}]},{"title":"面向对象的设计原则--一文带你理解清楚","slug":"principles-of-OOD","date":"2018-04-18T05:20:42.000Z","updated":"2019-01-02T07:23:26.257Z","comments":true,"path":"2018/0418/principles-of-OOD.html","link":"","permalink":"https://www.alankeene.com/2018/0418/principles-of-OOD.html","excerpt":"设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 本文主要分享对面向对象程序设计的设计原则的理解，以供想了解 OOD 设计原则的人士作参考。 主要内容包括：对设计原则和设计模式概念的理解，对 OOD 设计原则的理解，对继承和多态的理解。","text":"设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 本文主要分享对面向对象程序设计的设计原则的理解，以供想了解 OOD 设计原则的人士作参考。 主要内容包括：对设计原则和设计模式概念的理解，对 OOD 设计原则的理解，对继承和多态的理解。 什么是设计原则？什么是设计模式?什么是设计原则？怎么理解设计原则？如果要做个比喻，设计原则就像我们的宪法，而设计模式就像我们具体的基于宪法的各部法律，如：劳动法、海商法等等。 也就是说，设计原则是我们设计面向对象程序的纲领性指导，各种设计模式也是基于设计原则而设计的。 什么是设计模式？怎么理解设计模式？设计模式是帮助开发人员在设计应用程序或系统时，解决常见问题的正式最佳实践。 也就是说，设计模式是无数前辈工程师们在日常编码过程中总结出来的一些经验，它告诉你在某种具体的需求场景下该用什么样的方式编写代码才会最好，写出来的代码扩展性和可维护性才会更强，代码更高级，解决的是具体的需求。 Java 的设计模式共有23种，分为3大类，有部分在实际工作中也不常用。 但是，理论上设计模式可以有无数种，而并非23种，因为如上所述，设计模式解决的是具体某种需求场景的设计经验，而随着时间的推移和时代的变化，需求可以发生很多变化，而对应的设计模式理论上也可以被创造出来。 而设计原则就那么几条，相对固定，只要按这几条原则去设计和组织你的代码，解决你的需求，理论上就是在创造一种新的设计模式，如果这种编码方式不属于那23条里面而且也没有人使用过的话。 所以说，设计模式也好，架构也好，都是为需求服务的；好的程序遵循的是设计原则，而不是设计模式。 我们应该怎样学习和掌握设计原则？在我们的日常工作中，初级工程师，甚至是高级工程师，在实际的编码工作中并不会真真切切的用到设计原则，用的更多的是设计模式去解决工作中具体的需求。 也就是说，实际工作要求我们掌握的其实更多是设计模式，而并非设计原则。所以掌握设计模式是我们的重点，是向优秀工程师迈进的必备技能。 我们为什么还要学习和掌握设计原则呢？就像如果你不是立法机构的话，你似乎并不需要了解和掌握宪法，在日常生活中你碰到劳动相关问题了你就去了解劳动法，碰到海上贸易纠纷问题了你就去了解海商法即可。但是，这些具体的法律都是基于宪法的，如果你不了解宪法的话，你就不知道它们为什么是这样来设计的，虽然并不影响你用来解决实际问题，但你却不知道为什么。 同理，学习和掌握设计原则的目的也是如此。而且更重要的是，其实设计原则很容易理解和掌握，因为基本原则也就 5 条。当你理解了设计原则，再回来理解设计模式时，就会理解他为什么要这样写代码？为什么这样写代码是更加好的，扩展性和可维护性是更强的？ 换句话说，在理解了设计原则的基础上去掌握设计模式，就会理解的更加透彻，而不仅仅是只会使用设计模式而不知道为什么要这样设计。也能以不变应万变，不变的是设计原则，变得是设计模式。 而且，理解了设计原则再去学习设计模式，会相对容易记住和掌握，并大概率是以后都不会容易忘记。否则很有可能是这种情况：在工作中遇到问题去学习一下设计模式，看懂了用来解决了实际的需求，但过几天就忘了，设计模式相关的知识学了又忘，忘了又学，反反复复，好像总是掌握不了设计模式。笔者就经历过这样的一个过程，因为设计模式虽然只有23种，但涉及的相关知识点其实很多，要想想那可是多少人多少年来才总结出来的那么点经验啊，岂能是初学者一下就能完全掌握和记住的，单纯23种设计模式的写法和对应的使用场景都不容易理解和记忆。 但如果你理解了设计原则，情况就会变得好些，在学习具体的某种设计模式的时候，你就会知道它用了什么设计原则，代码为什么是这样写的？这么写的好处是什么? SOLID 设计原则好，了解了为什么要学习设计原则，接下来就要学习和理解设计原则了。 首先，面向对象的设计原则一共有几条？表述不一，江湖上有三种表述方法：有的说面向对象的七大原则，有的说六大原则，有的说五大原则。不过这只是不同的理解方式，对学习来说并不影响。 不过笔者参阅了维基百科 SOLID (面向对象设计)) 的解释，笔者的理解方式是：面向对象程序设计有五条基本原则，其他两条原则也学习了解，但不在基本原则的表述里。 而这五大基本原则，首字母简写就是 “SOLID” , 英文 “solid” 是固体的意思，固体的形态也意味着相对固定不变，很符合设计原则的思想，所以为了方便记忆，笔者也将面向对象的 SOLID 原则称为 “固体原则”。 S (Single reponsibility principle) - 单一职责原则概念：认为 “对象应该仅有一种单一功能”。 换句话说，你在设计一个类的时候，应该有职责单一的特性，就是将一组相关性很高的函数、数据封装到一个类中。 潜台词是：尽量拆分到最小单位，解决复用和组合的问题。 O (Open/closed principle) - 开闭原则概念： 认为 “软件体应该是对于扩展是开放的，但对于修改是封闭” 的。 什么意思呢？ 换句话说，一个类对于扩展是开放的，但对于修改是封闭的。如：我们升级、维护 APP 或系统需要增加新的功能时，应该尽量通过扩展去实现新的功能，而不是通过修改已有的代码来实现，以免带来一些难以发现的Bug。 试想一下，如果你要给一个系统增加新的功能，你通过修改源代码来实现，为了让新增的功能模块能正常运行，改了很多源代码，这时集成到系统中一测试，发现整个系统无法正常运行了，而且这个系统是已经在线上运行为用户提供服务的，你怎么办？你还要百分之百的还原原来的源码吗？ 所以，开闭原则能帮我们避免一些修改风险。 潜台词: 控制需求变动时的风险，缩小维护成本 L (Liskov substitution principle) - 里氏替换原则概念： 认为 “程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的” 。 本质上说，就是告诉我们要好好利用 继承 和 多态。 从技术上简单的描述，就是以父类的形式声明的变量(或形参)，赋值为任何继承于这个父类的子类后不影响程序的执行。 潜台词：尽量使用精准的抽象类或接口。 代码举例：123456789101112131415161718192021222324252627282930//窗口类public class Window &#123; public void show(View child) &#123; child.onDraw(); //调用抽象类View的抽象方法--onDraw方法 &#125;&#125;//抽象类Viewpublic abstract class View &#123; public abstract void onDraw(); public void onMeasure(int width, int length) &#123; //测量视图的大小 ... &#125;&#125;//继承抽象类View的子View,复写抽象方法onDraw()public class Button extends View &#123; public void onDraw() &#123; //绘制一个按钮 ... &#125;&#125;public class TextView extends View &#123; public void onDraw() &#123; //绘制文本 ... &#125;&#125; 实例代码解释: Window 类中的 show 函数需要传入 View, 并且调用 View 对象的 onDraw() 方法，而每个继承于 View 的子类对象都要实现 onDraw() 方法，不存在继承于 View 却没实现 onDraw() 方法的子类对象(abstract方法必须实现)。我们在抽象类 View 的设计时就是运用了里氏替换原则。 而当我们在调用窗口类 Window 的 show() 方法时，可以传入抽象类 View 的任何实现子类 Button类 或 TextView类，均不会影响程序的正常执行：123show(new Button());或show(new TextView()); 这样，你就可以实现在窗口上绘制任意一个的视图的需求了，一旦有增加新的视图的需求时，你只需要继承抽象类view并实现它的抽象方法 onDraw() 即可，作为参数传入 Window 类的 show() 方法中，Window 类就可以帮你把它绘制出来。 比如，你现在学习学累了，想在窗口上画个饼充饥，就可以实现一个画饼的子类：123456789public class Cake extends View &#123; public void onDraw() &#123; //画个饼充饥 ... &#125;&#125;//功能实现完了，然后作为参数传入 Windows 类的 show() 方法show(new Cake()); 其实，这种设计思想无处不在，你每天都能遇到，Android 中的 View 的绘制就是使用了这种思想。 如何理解多态和继承？多态的概念：同一个行为具有多个不同的表现形式或形态的能力。 举例：Window类的 show() 方法都是调用 View.onDraw() 的功能，但 TextView 和 Button 各自的 onDraw() 方法的表现形式不一样。 多态的好处：可以使程序有良好的扩展性，并可以对所有类的对象进行通用处理。用通俗的话说就是：一键修改，到处应用。 举例：实现抽象类 View 的抽象方法 onDraw() ,TextView 和 Button 实现了不同的绘制行为，即多态，扩展成不同的需求或功能。而与此同时，如果修改了抽象父类 View 的绘制行为，所有调用 View 的 Window 对象相应的 show() 行为也统一进行了更改。 笔者想到我们的一句俚语，用来帮助理解继承和多态再合适不过了：“一母生九子，连母十个样”。 “母”即父类，“九子”则继承自“母”这个父类，“连母十个样”：说明子类和父类都可以有不同的行为，也就是多态。 注意：Java 中类只能单继承，但可以多实现。用俚语帮助理解就是：每个人只能有一个爸爸(单继承)，但可以有多个兄弟(多实现)。 I(Interface segregation principle) - 接口隔离原则概念：认为 “多个特定客户端接口要好于一个宽泛用途的接口”。 也就是说，类之间的依赖关系应该建立在最小的接口上。其原则是将非常庞大的、臃肿的接口拆分成更小的更具体的接口。 潜台词： 尽量拆分成功能更具体的接口。 D(Dependency inversion principle) - 依赖反转原则概念：认为 “一个方法应该遵从依赖于抽象而不是一个实例” 。我们常用的依赖注入就是该原则的一种实现方式。 也就是说，要实现解耦，使得高层次的模块不依赖于低层次模块的具体实现细节，二者都应该依赖其抽象(抽象类或接口)。 其实，在我们用的 Java 语言中，抽象就是指接口或者抽象类，二者都是不能直接实例化的；细节就是实现类，实现接口或者继承抽象类而产生的类，就是细节。 使用 Java 语言描述就简单了，就是各个模块之间相互传递的参数声明为抽象类型，而不是声明为具体的类。 潜台词: 要面向抽象编程，解耦调用者和被调用者。 OK, 至此五大基本原则就解释完了，剩下两条原则我们也了解一下，帮助理解。 迪米特原则 - Law of Demeter也称：最少知识原则，认为 “一个对象应当对其他对象有尽可能少的了解”。 也就是说，一个类应该对自己调用的类的实现细节知道的越少越好。 举例：假设类 A 实现了某个功能，类 B 需要调用类 A 去执行这个功能，那么类 A 应该只暴露一个方法(函数)给类 B 去调用即可，而不是让类 A 把实现这个功能的细节(所有细分的方法和成员)暴露给 B 。 其实，这也是面向对象程序设计的最基本思想，是面向对象程序设计语言与面向过程程序设计语言最显著的差异。 潜台词：不要和陌生人说话，有事去找中介。 组合复用原则 - Composite Reuse Principle简称：CRP，也称聚合复用原则 - Aggregate Reuse Principle，简称ARP。或者连起来称：组合/聚合复用原则，简称CARP。 概念：认为 “如果只是为了达到复用的目的，应尽量使用对象组合与聚合，而不是继承。 因为继承的耦合性更大，而组合、聚合只是引用类的方法，没有这么维护风险同时也实现了复用的目的。 潜台词：我只是用了你的方法去实现我要的功能，我们不是同类，没有继承关系。 总结至此，我们把面向对象的设计原则讲解完了。你可能会突然发现：哦，原来这么熟悉，原来面向对象的设计原则就在我们身边。是的，其实它就在我们每天的日常编码工作中，只是可能没发现并试图理解它。 而且设计原则东西就这么点，也很容易学习和掌握。为了帮助读者学习理解并掌握，以及对后面学习设计模式产生帮助，本文花了不少篇幅介绍为什么要学习设计原则，学了有什么好处？真正讲解设计原则方面的知识其实你也发现了，也就那么点。 OK，最后总结一下本文重点：设计原则和设计模式的概念以及怎么去理解，为什么要学习设计原则，面向对象的设计原则(SOLID),怎么理解多态和继承。 下篇预告：学习完了设计原则，我们就要来讲解 设计模式 了。","categories":[{"name":"OOD设计原则","slug":"OOD设计原则","permalink":"https://www.alankeene.com/categories/OOD设计原则/"}],"tags":[{"name":"OOD","slug":"OOD","permalink":"https://www.alankeene.com/tags/OOD/"},{"name":"设计原则","slug":"设计原则","permalink":"https://www.alankeene.com/tags/设计原则/"}]},{"title":"Android 简史","slug":"Android-history","date":"2018-04-17T05:36:17.000Z","updated":"2019-01-02T07:23:26.256Z","comments":true,"path":"2018/0417/Android-history.html","link":"","permalink":"https://www.alankeene.com/2018/0417/Android-history.html","excerpt":"有一种了解一个事物的方法，那就是了解它的发展历史。 本文将持续更新记录 Android 的发展简史，以供喜欢 Android 和想了解 Android 的爱好者作参考。 Android 自 2008 年正式发布至今(2018)，已经走过了十个年头了。像一个小孩的长大一样，十年，对于一生来说，说长不长，仿佛不知不觉就长大了，说短也不短，至少我们不少人都错过了见证 Android 的成长历程，笔者也是 2015 年才开始对 Android 感兴趣并开始了解 Android 的。","text":"有一种了解一个事物的方法，那就是了解它的发展历史。 本文将持续更新记录 Android 的发展简史，以供喜欢 Android 和想了解 Android 的爱好者作参考。 Android 自 2008 年正式发布至今(2018)，已经走过了十个年头了。像一个小孩的长大一样，十年，对于一生来说，说长不长，仿佛不知不觉就长大了，说短也不短，至少我们不少人都错过了见证 Android 的成长历程，笔者也是 2015 年才开始对 Android 感兴趣并开始了解 Android 的。 这十年，Android 已经迭代了好多个版本，解决或优化了一些人们常诟病的问题，也有许多优秀的体验和设计方面的创新，至今已经占有约 85.9% 的全球市场份额，而且我们相信，Android 还会发展的越来越好。那么，接下来我们一起看看 Android 的发展简史吧。 Android 前传即 Android 操作系统的孵化阶段。 Android 是由 Google 和开放手持设备联盟共同开发发展而来的。 Android 在正式发布之前，最开始拥有两个内测版，并且以著名的机器人名称来对其进行命名，它们分别是：铁臂阿童木(Astro boy) 和发条机器人(Bender)。后来，由于涉及版权问题，Google 将其命名规则变更为用 甜点 作为它们系统版本的代号的命名方法。 “甜点命名法”开始于第三版 Android 1.5(实际上是第四版，因为 Android 1.0 其实有两版)。而从 Android 1.6 Donut(甜甜圈) 开始，项目组才正式确定将 Android 开发代号首字母从 “C” 一直延续下去。 Android 命名的由来Android 一词最早出现于法国作家利尔亚当（Auguste Villiers de l’Isle-Adam）在1886年发表的科幻小说《未来夏娃》（L’Ève future）中。他将外表像人的机器人取名为 Android。 Android 的生日5.11 被认为是 Android 的生日。 Android 的标志Android 是一个全身绿色的机器人，颜色采用了 PMS 376C 和 RGB 中十六进制的 #A4C639 来绘制，这是 Android 操作系统的品牌象征。 Android 的标志是由 Ascender 公司设计的，其中的文字使用了 Ascender 公司专门制作的称之为 “Google Droid” 的字体。 Android 发展简史 时间线 发布概述 版本号 版本代号 API 等级 基于的Linux Kernel版本 2008.9.23 Android 1.0 第一个正式版公布。全球第一台 Android 设备 HTC Dream(G1) 搭配的就是 Android 1.0 Android 1.0 Astro “铁臂阿童木” 1 2009.2.2 Android 1.1发布 Android 1.1 Bender “发条机器人” [内部也叫 Petit Four”花式小蛋糕”] 2 2009.4.30 Android 1.5 发布 Android 1.5 Cupcake “纸杯蛋糕” [从此版本开始决定用“甜点命名法”] 3 2.6.27 2009.9.15 Android 1.6 发布 Android 1.6 Donut “甜甜圈” [从此版本开始决定将代号首字母从 “C,D…” 一直延续下去] 4 2.6.29 2009.10.26 Android 2.0 发布 Android 2.0 Eclair “松饼” 5 2.6.29 2009.12.3 Android 2.0.1 发布 Android 2.0.1 Eclair “松饼” 6 2.6.29 2010.1.12 Android 2.1 发布 Android 2.1 Eclair “松饼” 7 2.6.29 2010.5.20 Android 2.2 发布 Android 2.2 Froyo “冻酸奶” 8 2.6.32 2010.12.7 Android 2.3 发布 Android 2.3 Gingerbread “姜饼” 9 2.6.35 2010.12 Android 2.3.3 更新包于 2011.2.9 正式发布，仅对上一个版本进行了API改进 Android 2.3.3 Gingerbread “姜饼” 10 2.6.35 2011.2.2 Android 3.0 发布，Android 3.0 是第一个 Android 平板操作系统，全球第一个使用该版本操作系统的设备是摩托罗拉公司于 2011.2.24 发布的 Motorlola Xoom 平板电脑 Android 3.0 Honeycomb “蜂巢” 11 2.6.36 2011.5.10 Android 3.1 发布 Android 3.1 Honeycomb “蜂巢” 12 2.6.36 2011.7.15 Android 3.2 发布，全球第一台使用该版本操作系统的设备是华为公司制造生产的 MediaPad 平板电脑 Android 3.2 Honeycomb “蜂巢” 13 2.6.36 2011.10.19 Android 4.0 于2011年4月在 Google I/O 大会上首次被宣布，并于 2011.10.19 正式发布 Android 4.0 和搭载 Android 4.0 的 Galaxy Nexus 智能手机。 Android 4.0 Ice Cream Sandwich “雪糕三明治” 14 3.0.1 2011.12.16 Android 4.0.3 发布 Android 4.0.3 Ice Cream Sandwich “雪糕三明治” 15 3.0.1 2012.6.28 Android 4.1 在 Google I/O 大会上和搭载 Android 4.1 的 Nexus 7 平板电脑一起发布 Android 4.1 JellyBean “果冻豆” 16 3.4.0 2012.10.30 Android 4.2 以新闻稿的形式发布。Google原本预计于2012年10月29日于纽约发布Android 4.2，但因为飓风桑迪吹袭被取消，而改以新闻稿发布，以“一种新口味的果冻豆”（A new flavor of Jelly Bean）作口号。首款搭载Android 4.2的手机LG Nexus 4及平板电脑Nexus 10于2012年11月23日上市。 Android 4.2 JellyBean “果冻豆” 17 3.4.0 2013.7.25 Android 4.3 发布 Android 4.3 JellyBean “果冻豆” 18 3.4.0 2013.10.31 Android 4.4 发布，Android 在此版本封锁了Adobe Flash Player 功能，此版本后不再支持 Falsh。 Android 4.4 Kitkat “奇巧巧克力” 19 3.4.0 2014.6.20 Android 4.4.4 发布 Android 4.4.4 Kitkat “奇巧巧克力” 20 3.4.0 2014.10.16 Android 5.0 发布。2014.6.25 在 Google I/O 大会上展示 Android L 的开发者预览版本，并开放下载。并于 2014.10.16 正式发布 Android 5.0 且命名为 Lollipop。此后，Android 沿袭了这种版本演进和发布的方式。此版本后，采用全新的 Material Design 界面，我们喜爱的 MD 设计诞生了。 Android 5.0 Lollipop “棒棒糖” 21 3.4.0 2015.3.10 Android 5.1 发布 Android 5.1 Lollipop “棒棒糖” 22 3.4.0 2015.10.5 Android 6.0 发布。2015.5.29 Google 在 I/O 大会啥昂展示 Android M 的开发者预览版，并于 2015.10.5 正式发布 Android 6.0 并将其命名为 Marshmallow。沿袭了上一版本的演进方式，以至于每年猜测和讨论 Android 版本的最终命名代号成了 Android 爱好者的一大乐趣。 Android 6.0 Marshmallow “棉花糖” 23 3.14.52 2016.8.22 Android 7.0 正式发布。2016.3.9 Google 发布 Android N 的开发者预览版并开放下载。于2016.8.22 正式发布 Android 7.0 并将其命名为 Nougat。 Android 7.0 Nougat “牛扎糖” 24 3.4.0 2016.10.4 Android 7.1 发布 Android 7.1 Nougat “牛扎糖” 25 2017.8.21 Android 8.0 正式发布。2017.3.21 Google 发布 Android O 的开发者预览版，并于 2017.8.21 正式发布 Android 8.0 并将其命名为 Oreo。 Android 8.0 Oreo “奥利奥” 26 2017.12.5 Android 8.1 发布 Android 8.1 Oreo “奥利奥” 27 2018.3.7 Google 发布 Android P 的开发者预览版并开放下载。 历史待续而来.. 笔者猜测叫 Pizza “披萨” 待续… … … … … … … 如果还想了解各版本技术特性上的演进史和更多演进细节，请参阅： Android version history Android历史版本","categories":[{"name":"Android","slug":"Android","permalink":"https://www.alankeene.com/categories/Android/"}],"tags":[{"name":"Android简史","slug":"Android简史","permalink":"https://www.alankeene.com/tags/Android简史/"}]},{"title":"用 hexo 搭建博客踩过的坑","slug":"next-problems","date":"2018-04-12T13:43:47.000Z","updated":"2019-01-02T07:23:26.256Z","comments":true,"path":"2018/0412/next-problems.html","link":"","permalink":"https://www.alankeene.com/2018/0412/next-problems.html","excerpt":"路是人走出来的，但有些路，希望你不用再摸索着走一遍。 本文将持续更新记录使用 hexo 框架 NexT 主题搭建博客过程中遇到并解决的坑。以供使用此方式搭建博客的人作参考之用，避免再重复踩坑。","text":"路是人走出来的，但有些路，希望你不用再摸索着走一遍。 本文将持续更新记录使用 hexo 框架 NexT 主题搭建博客过程中遇到并解决的坑。以供使用此方式搭建博客的人作参考之用，避免再重复踩坑。 hexo-leancloud-counter-security插件当你需要按照 这篇教程 去集成 hexo-leancloud-counter-security 插件时，一定要注意要先让 Counter 初始化成功后，再集成 hexo-leancloud-counter-security 插件，否则文章阅读次数的地方会显示未初始化。 也就是说：你需要先别配置部署 hexo-leancloud-counter-security 插件，而只需按照 这篇教程 去为 NexT 主题添加文章阅读量统计功能，登陆LeanCloud后台看到 Counter 初始化成功并有数据后，再回来按照 这篇教程 的步骤去集成 hexo-leancloud-counter-security 插件。 原因: 当初是先有 为NexT主题添加文章阅读量统计功能 这个功能，然后考虑到阅读次数统计数据的安全性，防止被恶意篡改，才产生了 hexo-leancloud-counter-security 这个插件去解决这个问题的。所以老用户直接按照教程直接升级是不可能遇到这个坑的，因为他们原本就已经初始化了 Counter 。而如果你是初次添加 为NexT主题添加文章阅读统计功能 ，而且也是初次集成 hexo-leancloud-counter-security 插件，则必须先初始化 Counter。 关于 必须先初始化 Counter, 再集成 hexo-leancloud-counter-security 插件 这点说明，官方的使用教程 ([中文版] [English]) 目前好像还没有很明确的说明。如果你是按照官方使用教程的说明来操作，则需要注意这点，避免踩到坑。 注： 由于时间有限，并没有制作针对小白的详细操作步骤，如果你按照本避坑说明集成 hexo-leancloud-counter-security 插件还是遇到问题，可通过邮件联系我获得具体每一步的操作指导。 让 MarkdownPad 编辑器支持表格如果在 Windows 系统下用 MarkdownPad 来写 hexo 博客，MarkdownPad编辑器的默认设置是不支持显示表格的。即常用的Markdown语法书写表格的方式(|:—-:|:—:|)在MarkdownPad编辑器中是无法正确识别并预览的。 所以，你需要修改 MarkdownPad 编辑器默认的处理器。修改方式如下： 点击: Tools –&gt; Options –&gt; Markdown –&gt; Markdown Processor,改成Markdown (Extra) 即可。 如果你是中文环境，点击: 工具 –&gt; 选项 –&gt; Markdown –&gt; Markdown 处理器，改成 Markdown (扩展) 即可。 hexo g 出错怎么办当你写完博客，hexo g 出错，若报错如下: 12345FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: unexpected end of file at Object._prettifyError 说明 hexo 框架无法正常渲染你的文章，很有可能是你在书写文章时一不小心哪里的格式没写对造成的。 举个例子，使用 NexT 的 centerquote 标签时，如果不小心在关闭标签 endcenterquote的 { 和 % 之间多加了一个空格，写成了：{ % centerquote %}。 则会出现上述的 hexo 无法帮你渲染文章的错误，而这种格式的错误当你写完长篇的文章后，是很难再发现的。 所以，在你写文章之前，一定要熟悉 hexo 和 NexT 的文档和写作指南，避免因书写格式不对而造成无法渲染。 hexo的标签使用说明 NexT的内建标签使用说明 当然，当你遇到 Template render error 文章无法渲染的问题时，可按提示参阅 hexo的问题解答 查看其他常见的问题，看是否可以找到对应的解决方案。 关于 Gitment 评论系统无法登陆的问题如果你是按照 NexT 默认的方式去配置 Gitment 评论插件的话，你会发现 Gitment 现在登陆不了了。 授权登陆 Github 时会发生 Object ProgressEvent 异常。 因为 https://gh-oauth.imsun.net 域名的 HTTPS 证书今年九月份就过期了，导致无法再正常访问，作者也一直没有更新维护。 详情请参见： https://github.com/imsun/gitment/issues/170 gitment 登录失败 Gitment 的安全性争议 目前网上也有一些对这个问题的解决方案，总结来说就是需要自己搭建个服务器，或者用别人搭好的服务器替换，但万一哪天别人换了你就又不能用了，不是长久之计，所以如果还想用 Gitment 最好还是能自己搭服务器，不然就用别的评论系统吧，比如来必力。而且，网上也存在 Gitment 安全性争议的讨论。","categories":[{"name":"那些踩过的坑","slug":"那些踩过的坑","permalink":"https://www.alankeene.com/categories/那些踩过的坑/"}],"tags":[{"name":"踩的NexT坑","slug":"踩的NexT坑","permalink":"https://www.alankeene.com/tags/踩的NexT坑/"}]}]}